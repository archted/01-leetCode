## 子序列系列

### 目录导航



![68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732fe58aa8e68081e8a784e588922de5ad90e5ba8fe58897e997aee9a298e680bbe7bb932e6a7067](https://i0.wp.com/tvax3.sinaimg.cn/large/00496yplgy1gvo4szuptcj60ti0ow0w402.jpg)

### 总结

**对于两个字符串求子序列的问题，都是用两个指针`i`和`j`分别在两个字符串上移动，大概率是动态规划思路**。

由于要考虑空字符串，当题目涉及两个数组时，`dp[i][j]`一般定义为s1的[0,i-1]和s2的[0,j-1]子序列进行比较，目的是为了方便dp数组的初始化。



### 子序列（连续）

**滑动窗口算法就是专门处理子串/子数组问题的，但是分析题意的话不好用滑动窗口算法去解决，取而代之的是贪心算法更好去解决。**

**概括来说：不连续递增子序列的跟前0-i 个状态有关，连续递增的子序列只跟前一个状态有关**

#### 674. 最长连续递增序列

题目链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。

示例 2： 输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。  提示：

- 0 <= nums.length <= 10^4

- -10^9 <= nums[i] <= 10^9

---



方法一、动态规划

dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。

如果 nums[i + 1] > nums[i]，dp[i + 1] = dp[i] + 1;

本题相对于昨天的[动态规划：300.最长递增子序列](https://mp.weixin.qq.com/s/f8nLO3JGfgriXep_gJQpqQ)最大的区别在于“连续”。

```c
class Solution {
public:
    int findLengthOfLCIS(vector<int> &nums)
    {
        if (nums.size() == 0)
            return 0;
        int result = 1;
        vector<int> dp(nums.size(), 1);
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) {  // 连续记录
                dp[i + 1] = dp[i] + 1;
            }
            if (dp[i + 1] > result)
                result = dp[i + 1];
        }
        return result;
    }
};
```

方法二、贪心

这道题目也可以用贪心来做，也就是遇到nums[i + 1] > nums[i]的情况，count就++，否则count为1，记录count的最大值就可以了。这个所谓的贪心做法其实就是dp的状态压缩而已。

代码如下：

```c
class Solution {
public:
    int findLengthOfLCIS(vector<int> &nums)
    {
        if (nums.size() == 0)
            return 0;
        int result = 1;  // 连续子序列最少也是1
        int count = 1;
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) {  // 连续记录
                count++;
            } else {
                // 不连续，count从头开始
                count = 1;
            }
            if (count > result)
                result = count;
        }
        return result;
    }
};
```

#### 53. 最大子序和

题目地址：https://leetcode-cn.com/problems/maximum-subarray/

给定一个整数数组 nums ，找到一个具有最大和的连续子数组**（子数组最少包含一个元素）**，返回其最大和。

示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

---

方法一、动态规划

dp[i]：**以下标i结尾的数组的最大连续子数组和为dp[i]。**

`dp[i] = max(dp[i - 1] + nums[i], nums[i]);`   

`dp[i - 1] + nums[i]`表示选择前面的最大连续累积和，`nums[i]`表示不选择前面的最大连续累积和，从当前数开始累加

`dp[0] = nums[0]。`

```c
class Solution {
public:
    int maxSubArray(vector<int> &nums)
    {
        if (nums.size() == 0)
            return 0;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int result = dp[0];
            /*  如果没有子数组最少包含一个元素的限制
                max(dp[i-1],0)表示是否选择前面的最大连续累积和
                max(0,nums[i])表示是否选择当前元素
	            dp[i] = max(max(dp[i-1],0) + max(0,nums[i]))
            */
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(max(dp[i - 1],0) + nums[i]);  // 由dp数组的定义可知，一定是选择nums[i]的
            if (dp[i] > result)
                result = dp[i];  // result 保存dp[i]的最大值
        }
        return result;
    }
};
```

方法二、贪心

  - 局部最优：当连续和为负时立刻放弃，从下一个数开始累加连续和；全局最优：选取最大的连续和

  ```c++
  class Solution {
  public:
      int maxSubArray(vector<int> &nums)
      {
          int result = INT32_MIN;
          int count = 0;
          for (int i = 0; i < nums.size(); i++) {
              count  = count+ nums[i];
              if (count > result) {  // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                  result = count;
              }
              if (count <= 0)
                  count = 0;  // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
          }
          return result;
      }
  };
  ```



#### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。  提示：

- 1 <= len(A), len(B) <= 1000
- 0 <= A[i], B[i] < 100

---

**注意题目中说的子数组，其实就是连续子序列。**这种问题动规最拿手

`dp[i][j] `：**以下标i - 1为结尾的A**，和以下标j - 1为结尾的B，最长重复子数组长度为`dp[i][j]。`

双层循环找出所有的 i, j 组合，时间复杂度 $O(m * n)$，其中 m 和 n分别为 A 和 B 的 ⻓度。

当A[i - 1] 和B[j - 1]相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1`;

否则，`dp[i][j] = 0`

循环过程记录最⼤值即可。

![image-20210514142111646](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210514142111646.png)

```c
class Solution {
public:
    int findLength(vector<int> &A, vector<int> &B)
    {
        vector<vector<int>> dp(A.size() + 1, vector<int>(B.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= A.size(); i++) {
            for (int j = 1; j <= B.size(); j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result)
                    result = dp[i][j];
            }
        }
        return result;
    }
};
```



### 子序列(不连续)

注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。

#### 300.最长递增子序列LIS

题目链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/

最长递增子序列（Longest Increasing Subsequence，简写 LIS）

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4

示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1  提示：

- 1 <= nums.length <= 2500
- -10^4 <= nums[i] <= 104

---

方法一、动态规划$O(n^2)$

按照动态规划定义状态的套路，我们有**两种常见**的定义状态的方式：

- dp[i] : 以 i 结尾（一定包括 i）所能形成的最长上升子序列长度, 答案是 max(dp[i])，其中 i = 0,1,2, ..., n - 1
- dp[i] : 以 i 结尾（可能包括 i）所能形成的最长上升子序列长度，答案是 dp[-1] （-1 表示最后一个元素）

我们选择第一种。

1.dp[i]的定义

**dp[i] 表示以 i 结尾（一定包括 i）所能形成的最长上升子序列长度**。

2.状态转移方程

位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

所以：`if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);`

3.dp[i]的初始化

每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1.

4.确定遍历顺序

dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。

5.举例推导dp数组

```c
class Solution {
public:
    int lengthOfLIS(vector<int> &nums)
    {
        if (nums.size() <= 1)
            return nums.size();
        vector<int> dp(nums.size(), 1); 
        //int[] dp = new int[nums.length];  Arrays.fill(dp, 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = max(dp[i], dp[j] + 1);
            }
        }
         for (int i = 1; i < nums.size(); i++) {       
             if (dp[i] > result)
                result = dp[i];  // 取长的子序列
         }
        return result;
    }
};
```

动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历dp[0…i−1] 的所有状态，所以时间复杂度：$O(n^2)$

方法二、二分查找法：扑克牌O(nlogn)

#### 1143.最长公共子序列LCS

最长公共子序列（Longest Common Subsequence，简称 LCS）

给定两个字符串 text1 和 text2，返回这两个字符串的**最长公共子序列的长度。**

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:

输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。

示例 2:
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。

示例 3:
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。

提示:

- 1 <= text1.length <= 1000
- 1 <= text2.length <= 1000 输入的字符串只含有小写英文字符。

---

本题和[动态规划：718. 最长重复子数组](https://mp.weixin.qq.com/s/U5WaWqBwdoxzQDotOdWqZg)区别在于这里不要求是连续的了，但要有相对顺序

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：**长度为[0, i - 1]的字符串text1**与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`

2. 确定递推公式

主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同

如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1;`

如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。

即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);`

3. dp数组初始化

dp初始化为0即可。

```c
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2)
    {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```



#### 1035.不相交的线

我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。

现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。

以这种方法绘制线条，并返回我们可以绘制的最大连线数。

![image-20210514143926663](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210514143926663.png)

---

直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 本题**其实就是求两个字符串的最长公共子序列的长度！**那么本题就和我们刚刚讲过的这道题目[动态规划：1143.最长公共子序列](https://mp.weixin.qq.com/s/Qq0q4HaE4TyasCTj2WGFOg)就是一样一样的了。

### 编辑距离(不连续)

编辑距离问题必然是不连续的子序列。

#### [392.判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

题目链接：

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

示例 1： 输入：s = "abc", t = "ahbgdc" 输出：true

示例 2： 输入：s = "axc", t = "ahbgdc" 输出：false

---

**解法一**、1143.最长公共子序列的变形题，dp定义：最长公共子序列为`dp[i][j]`

```c
1.先求得最长公共子序列
2.判断dp[text1.size()][text2.size()] == s.length()即可;
class Solution {
public:
    int isSubsequence(string s, string t)  
    {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[s.size()][t.size()] == s.length();
    }
};
```

**解法二**、编辑距离，dp定义：相同子序列的长度为`dp[i][j]`

这道题应该算是编辑距离的入门题目，因为只需要计算删除的情况，不用考虑增加和替换的情况。

动态规划五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j] `表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t可以随便删除元素，相同子序列的长度为`dp[i][j]`**。

2. 确定递推公式

`if (s[i - 1] == t[j - 1])`，那么`dp[i][j] = dp[i - 1][j - 1] + 1;`，因为找到了一个相同的字符，相同子序列长度自然要在`dp[i-1][j-1]`的基础上加1

 `if (s[i - 1] != t[j - 1])`，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么`dp[i][j] `的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：`dp[i][j] = dp[i][j - 1];`

3. dp数组如何初始化

`从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，所以dp[0][0]和dp[i][0]是一定要初始化的。`

这里大家已经可以发现，在定义`dp[i][j]`含义的时候为什么要**表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为`dp[i][j]`**,因为这样的定义在dp二维矩阵中可以留出初始化的区间

![image-20210514175230810](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210514175230810.png)


4. 确定遍历顺序

从递推公式可以看出`dp[i][j]`都是依赖于`dp[i - 1][j - 1] 和 dp[i][j - 1]`，那么遍历顺序也应该是从上到下，从左到右

![image-20210514175323058](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210514175323058.png)

5. 举例推导dp数组

如果`dp[s.size()][t.size()]` 与 字符串s的长度相同说明：s与t的相同子序列就是s，那么s 就是 t 的子序列。

```c
class Solution {
public:
    bool isSubsequence(string s, string t)
    {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = dp[i][j - 1];
            }
        }
        if (dp[s.size()][t.size()] == s.size())
            return true;
        return false;
    }
};
```

与解法一代码比较，简直非常相似了。

解法三、双指针

本题询问的是，s 是否是 t 的子序列，因此只要能找到任意一种 s 在 t 中出现的方式，即可认为 s 是 t 的子序列。

而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。

这样，我们初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。

最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。

![image-20210729165230284](https://i0.wp.com/tvax3.sinaimg.cn/large/00496yplgy1gvnwo7d4onj60jh08jmzy02.jpg)

```c
bool isSubsequence(string s, string t) {
    int i = 0, j = 0;
    while (i < s.size() && j < t.size()) {
        if (s[i] == t[j]) i++;
        j++;
    }
    return i == s.size();
}
```

时间复杂度：O(n+m)

空间复杂度：O(1)。

所以如果单纯只考本道题的话，双指针解法应该是最优的。如果仅仅是这个问题，这个解法就够好了，**不过这个问题还有 follow up**：

如果给你一系列字符串 `s1,s2,...` 和字符串 `t`，你需要判定每个串 `s` 是否是 `t` 的子序列（可以假定 `s` 较短，`t` 很长）。

```c
boolean[] isSubsequence(String[] sn, String t);
```

你也许会问，这不是很简单吗，还是刚才的逻辑，加个 for 循环不就行了？

可以，但是此解法处理每个 `s` 时间复杂度仍然是 O(N)，而如果巧妙运用二分查找，可以将时间复杂度降低，大约是 O(MlogN)。由于 N 相对 M 大很多，所以后者效率会更高。

解法四、二分思路

二分思路主要是对 `t` 进行预处理，用一个字典 `index` 将每个字符出现的索引位置按顺序存储下来：

```c
int m = s.length(), n = t.length();
ArrayList<Integer>[] index = new ArrayList[256];
// 先记下 t 中每个字符出现的位置
for (int i = 0; i < n; i++) {
    char c = t.charAt(i);
    if (index[c] == null) 
        index[c] = new ArrayList<>();
    index[c].add(i);
}
```

![92993c52d1f4fe48f554be91b3d173a5a134e1a1](https://i0.wp.com/tva2.sinaimg.cn/large/00496yplgy1gvo4tf17v9j60zk0k0gnh02.jpg)

比如对于这个情况，匹配了 "ab"，应该匹配 "c" 了：

![580a9bcc9b0981209f290fb534aded734025c123](https://i0.wp.com/tvax4.sinaimg.cn/large/00496yplgy1gvo4tqexidj60zk0k0tab02.jpg)



按照之前的解法，我们需要 `j` 线性前进扫描字符 "c"，但借助 `index` 中记录的信息，**可以二分搜索** **`index[c]`** **中比 j 大的那个索引**，在上图的例子中，就是在 `[0,2,6]` 中搜索比 4 大的那个索引：

这样就可以直接得到下一个 "c" 的索引。现在的问题就是，如何用二分查找计算那个恰好比 4 大的索引呢？答案是，寻找左侧边界的二分搜索就可以做到。

![image-20210729191007456](https://i0.wp.com/tvax3.sinaimg.cn/large/00496yplgy1gvnwo6x0ddj60j1090q6702.jpg)

对于搜索**左侧边界**的二分查找，有一个特殊性质：

即从pos位置开始，[pos,...]之后的数值都≥ value.

什么意思呢，就是说如果在数组 `[0,1,3,4]` 中搜索元素 2，算法会返回索引 2，也就是元素 3 的位置，元素 3 是数组中≥ 2 的最小元素。所以我们可以利用二分搜索避免线性扫描。

代码如下：

```c
class Solution {
    public boolean isSubsequence(String s, String t) {
        int m = s.length(), n = t.length();
        // 对 t 进行预处理
        ArrayList<Integer>[] index = new ArrayList[256];
        for (int i = 0; i < n; i++) {
            char c = t.charAt(i);
            if (index[c] == null)
                index[c] = new ArrayList<>();
            index[c].add(i);
        }

        int j = 0; // 串 t 上的指针
        // 借助 index 查找 s[i]
        for (int i = 0; i < m; i++) {
            char c = s.charAt(i);
            // 整个 t 压根儿没有字符 c
            if (index[c] == null)
                return false;
            int pos = left_bound(index[c], j);// s中的字符ch在t的index[ch]数组中找到起始下标≥上个搜索到的位置
            // 二分搜索区间中没有找到字符 c
            if (pos == index[c].size())
                return false;
            // 向前移动指针 j
            j = index[c].get(pos) + 1;
        }
        return true;
    }

    // 查找左侧边界的二分查找
    int left_bound(ArrayList<Integer> arr, int tar) {
        int lo = 0, hi = arr.size();
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (tar > arr.get(mid)) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        return lo;
    }

    public static void main(String[] args) {
        String s = "acb";
        String t = "ahbgdc";
        boolean subsequence = new Solution().isSubsequence(s, t);
        System.out.println(subsequence);
    }
}
```

`int pos = left_bound(nums, value);`

pos表示数组nums中小于value值的元素个数，pos返回三类值：0、idx(value值的左边界)、`nums.length`,它们分别表示数组中小于j的元素个数为：0个、idx个和nums.length个；

即nums[pos]表示值大于等于value值的数中最小的那一个，正好符合题意。

#### [115.不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

![image-20210708113639047](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210708113639047.png)

这道题目如果不是子序列，而是要求连续序列的，那就可以考虑用KMP。

但相对于刚讲过的[动态规划：392.判断子序列](https://mp.weixin.qq.com/s/2pjT4B4fjfOx5iB6N6xyng)就有难度了，这道题目双指针法可就做不了了，来看看动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：**以i-1为结尾的s可以随便删除元素，出现以j-1为结尾的t的个数为`dp[i][j]`。**

2. 确定递推公式

这一类问题，基本是要分析两种情况

- s[i - 1] 与 t[j - 1]相等
- s[i - 1] 与 t[j - 1] 不相等

当s[i - 1] 与 t[j - 1]相等时，`dp[i][j]`可以有两部分组成。

一部分是用s[i - 1]来匹配，那么个数为`dp[i - 1][j - 1]`。

一部分是不用s[i - 1]来匹配，个数为`dp[i - 1][j]`。

这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。

例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。

当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。

所以当s[i - 1] 与 t[j - 1]相等时，`dp[i][j]` = `dp[i - 1][j - 1]` + `dp[i - 1][j]`;

当s[i - 1] 与 t[j - 1]不相等时，`dp[i][j]`只有一部分组成，不用s[i - 1]来匹配，即：`dp[i - 1][j]`

所以递推公式为：`dp[i][j]` = `dp[i - 1][j]`;

3. dp数组如何初始化

`dp[i][0]` 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。

那么`dp[i][0]`一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。

`dp[0][j]`：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。

那么`dp[0][j]`一定都是0，s如论如何也变成不了t。

最后就要看一个特殊位置了，即：`dp[0][0]` 应该是多少。

`dp[0][0]`应该是1，空字符串s，可以删除0个元素，变成空字符串t。

初始化分析完毕，代码如下：

```c
vector<vector<long long>> dp(s.size() + 1, vector<long long>(t.size() + 1));
for (int i = 0; i <= s.size(); i++)
    dp[i][0] = 1;
for (int j = 1; j <= t.size(); j++)
    dp[0][j] = 0;
```

4. 确定遍历顺序

遍历的时候一定是从上到下，从左到右

5. 举例推导dp数组

以s："baegg"，t："bag"为例，推导dp数组状态如下：

![image-20210517140805222](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210517140805222.png)

```c
class Solution {
public:
    int numDistinct(string s, string t)
    {
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));
        for (int i = 0; i < s.size(); i++)
            dp[i][0] = 1;
        for (int j = 1; j < t.size(); j++)
            dp[0][j] = 0;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

#### 583. 两个字符串的删除操作

题目链接：https://leetcode-cn.com/problems/delete-operation-for-two-strings/

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

示例：

输入: "sea", "eat"
输出: 2 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"

---

**方法一、LCS题目的变形**

题目让我们计算将两个字符串变得相同的最少删除次数，那我们可以思考一下，最后这两个字符串会被删成什么样子？

删除的结果不就是它俩的最长公共子序列嘛！

那么，要计算删除的次数，就可以通过最长公共子序列的长度推导出来：

```c
int minDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    // 复用前文计算 lcs 长度的函数
    int lcs = longestCommonSubsequence(s1, s2);
    return m - lcs + n - lcs;
}
```



---

**方法二、根据题意定义dp**

本题和[动态规划：115.不同的子序列](https://mp.weixin.qq.com/s/1SULY2XVSROtk_hsoVLu8A)相比，其实就是两个字符串可以都可以删除了，情况虽说复杂一些，但整体思路是不变的。

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。

2. 确定递推公式

- 当word1[i - 1] 与 word2[j - 1]相同的时候
- 当word1[i - 1] 与 word2[j - 1]不相同的时候

当word1[i - 1] 与 word2[j - 1]相同的时候，`dp[i][j]` = `dp[i - 1][j - 1]`;

> 这里我的理解是这样，当word1[i - 1]  ==  word2[j - 1]时，可以选择匹配，也可以选择删掉这两个单词其中一个进行匹配，即
>
> `dp[i][j] = min({dp[i-1][j-1], dp[i - 1][j] + 1, dp[i][j - 1] + 1})`
>
> 但是题目是需要求操作的最小步数，所以肯定是直接匹配得到的步数最小，即`dp[i][j]` = `dp[i - 1][j - 1]`;
>
> leetcode提交结果也验证了我这一点

当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：

情况一：删word1[i - 1]，最少操作次数为`dp[i - 1][j]` + 1

情况二：删word2[j - 1]，最少操作次数为`dp[i][j - 1]` + 1

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：

` dp[i][j] = min({dp[i - 1][j] + 1, dp[i][j - 1] + 1});`

3. dp数组如何初始化

`dp[i][0]`：word2为空字符串，以i-1为结尾的字符串word2要删除多少个元素，才能和word1相同呢，很明显`dp[i][0] `= i。

`dp[0][j]`的话同理，所以代码如下：

```c
vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
for (int i = 0; i <= word1.size(); i++)
    dp[i][0] = i;
for (int j = 0; j <= word2.size(); j++)
    dp[0][j] = j;
```

4. 确定遍历顺序

从上到下，从左到右

5. 举例推导dp数组

```c
class Solution {
public:
    int minDistance(string word1, string word2)
    {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i <= word1.size(); i++)
            dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++)
            dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

![image-20210708142224234](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210708142224234.png)

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j]` 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为`dp[i][j]`**。

2. 确定递推公式

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```c
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```

也就是如上四种情况。

`if (word1[i - 1] == word2[j - 1]) `那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j]` = `dp[i - 1][j - 1]`;

解释：回顾上面讲过的`dp[i][j]`的定义，word1[i - 1] 与 word2[j - 1]相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串word2的最近编辑距离`dp[i - 1][j - 1]` 就是 `dp[i][j]`了。

`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

![image-20210708151221316](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210708151221316.png)

操作一：word2删掉一个单词，此时编辑距离 `dp[i][j] = dp[i][j - 1] + 1`；

操作二：word1删掉一个单词，此时编辑距离 `dp[i][j] = dp[i - 1][j] + 1`；

操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。

即即 `dp[i][j]` = `dp[i - 1][j - 1]` + 1;

综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：`dp[i][j]` = min({`dp[i - 1][j - 1]`, `dp[i - 1][j]`, `dp[i][j - 1]`}) + 1;

3. dp数组如何初始化

`dp[i][0]` ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为`dp[i][0]`。

那么`dp[i][0]`就应该是i，对word1里的元素全部做删除操作，即：`dp[i][0]` = i;

同理`dp[0][j]` = j;

4. 确定遍历顺序

从左到右从上到下

5. 举例推导dp数组

```c
class Solution {
public:
    int minDistance(string word1, string word2)
    {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++)
            dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++)
            dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### 
