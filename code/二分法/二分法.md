# 二分法

## 基础知识

使用二分法唯一注意的一点：

**明确mid的含义和left、right的取值。寻找左侧边界看left，寻找右侧边界看right**

### 1代码模板

二分查找到底有能运用在哪里？最常见的就是教科书上的例子，在**有序数组**中搜索给定的某个目标值的索引。

常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。

#### a)寻找一个数

[704.二分查找](https://leetcode-cn.com/problems/binary-search)

##### a.1)左闭右闭

```c
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}
```

##### a.2)左闭右开

```java
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length; 
    while(left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}
```



#### b)寻找左侧边界

##### b.1)左闭右闭

```java
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // ① 不可以直接返回，应该继续向左边找，即 [left..mid - 1] 区间里找
            right = mid - 1;
        }
    }
// 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，寻找左侧边界看left，此时 left 才是第 1 次元素出现的位置
    // 因此还需要特别做一次判断
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}
```

1.终止条件

`while(left <= right)` 终止的条件是 `left == right+1`，此时搜索区间 `[right+1, right]` 为空，所以可以正确终止。

2.**为什么该算法能够搜索左侧边界**？

先理解一下这个「左侧边界」有什么特殊含义：

对于`nums = [1,2,2,2,3],target = 2,left =  1`。这个 1 的含义可以这样解读：`nums` 中小于 2 的元素有 1 个。

**对于有序数组 `nums = [2,3,5,7],target = 1, left =  0`，含义是：`nums` 中小于 1 的元素有 0 个。**

**再比如说 `nums = [2,3,5,7], target = 8，left =  4`，含义是：`nums` 中小于 8 的元素有 4 个。**

可以看出， `left` 变量的值取值区间是闭区间 `[0, nums.length]`，因此使用下面两行代码就可以正确得到左侧边界

```java
    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;

```

nums[mid] == target 的时候，在 [left, mid - 1] 区间里找，有没有可能 nums[mid] 就是第 1次出现的位置，有可能，但不要紧，退出循环的时候 right 指针在左，left 在右。如果数组里存在 target，那么 left 一定位于 target 出现的第 1个位置



##### b.2)**左闭右开**

```java
int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; 

    while (left < right) { 
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            // ① 不可以直接返回，应该继续向左边找，即 [left..mid) 区间里找
            right = mid; 
        }
    }
// 此时 left 和 right 的位置关系是left == right，注意上面的 ①，寻找左侧边界看left，left是闭区间，此时 left 才是第 1 次元素出现的位置

    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}
```



#### c)寻找右侧边界

##### c.1)左闭右闭

```java
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            //①  不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找
            left = mid + 1;
        }
    }
// 此时 left 和 right 的位置关系是[right,left]，注意上面的 ①，寻找右侧边界看right，此时 right 才是第 1 次元素出现的位置
    // 最后要检查 right 越界的情况
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```

##### c.2)左闭右开

```java
int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            //①  不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找
            left = mid + 1; 
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    
// 此时 left 和 right 的位置关系是left == right,注意上面的 ①，寻找右侧边界看right，因为right是开区间，因此right-1是第1次元素出现的位置
    if (right == 0 ||nums[right-1] !=target) 
        return -1;

    return right  - 1; // 注意
}
```

#### 总结:左边界和右边界返回值详解





1、左闭右闭和左闭右开区间写法的区别：

while(left <= right) 在退出循环的时候 left = right + 1，即 right 在左，left 在右；
while(left < right) 在退出循环的时候，有 left == right 成立。

2、寻找左边界返回值详解

`int pos = left_bound(nums, value);`

* pos含义：pos表示数组nums中小于value值的元素个数

* pos返回值：
  * 0：表示数组中小于value的元素个数为0个
  * idx(0 < idx < nums.length):表示数组中小于value的元素个数为idx个，idx为value值左边界下标
  * nums.length:表示数组中小于value的元素个数为nums.length个

左边界含义：

**1.在它左边有pos个比value小的数；**

**2.从pos位置开始，[pos,...]之后的数值都≥ value，nums[pos]表示nums数组中元素值≥value值的数中最小的那一个。**

3、寻找右侧边界返回值详解

`int pos = right_bound(nums, value);`

* pos含义：pos表示数组nums中大于value值的元素个数

* pos返回值：
  * 0：表示数组中大于value的元素个数为0个
  * idx(0 < idx < nums.length):表示数组中大于value的元素个数为idx个，idx为value值右边界下标
  * nums.length:表示数组中大于value的元素个数为nums.length个

右边界含义：

**1.在它右边有nums.length-pos-1个比value大的数；**

**2.即截止到位置pos，[...，pos]之前的数值都 ≤ value，nums[pos]表示nums数组中元素值≤ value值的数中最大的那一个，**



题目：

[34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

分析：相当于寻找target的左边界和右边界

- 时间复杂度：O*(log*N)，这里 N 是数组的长度，两个子问题都是二分查找；
- 空间复杂度：O*(1)，只使用了常数个数的辅助变量。







## 四大应用

对于最左和最右二分，简单用两句话总结一下：

1. 最左二分不断收缩右边界，最终返回左边界
2. 最右二分不断收缩左边界，最终返回右边界



能力检测和计数二分本质差不多，都是**普通二分** 的泛化。

前缀和二分和插入排序二分，本质都是在**构建有序序列**。



## **普通二分**的泛化

能力检测和计数二分本质差不多，都是**普通二分** 的泛化。

### 最左最右二分

#### [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

![image-20210809111905977](https://i0.wp.com/tvax3.sinaimg.cn/large/00496yplgy1gvnwonrcuuj60gl0b6jth02.jpg)

题目可以描述为求`目标值^2≤x`的右边界。

**二分法关键点：明确mid含义及左右边界**

mid：我们要找的x平方根的值

left：左边界为0；

right：右边界为x；

一、转换为long类型再相乘

* > 易错:`long cur = (long) mid * (long) mid;`

```java
class Solution {
    public int mySqrt(int x) {
        // mid含义：我们要找的x平方根的值
        int left = 0;
        int right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;// 防止分母为0
            long cur = (long) mid * (long) mid;
            if (cur < x) {
                left = mid + 1; // 在[mid+1,right]中继续找
            } else if (cur > x) {
                right = mid - 1;
            } else {
                return mid;
            }
        }
        // 循环结束时[right,left],right是闭区间,因此,直接返回right
        return right;
    }

    public static void main(String[] args) {
        int mySqrt = new Solution().mySqrt(2147395599);
        System.out.println(mySqrt);
    }
}
```

二、使用除法

因为`mid = left + (right - left) / 2`,当`left == 0 && (right-left)/2 == 0 ，即right = 0 or 1时，mid==0`,因此需要在使用除法前对这两种情况作出判断。

```java
class Solution {
    public int mySqrt(int x) {
        // 解区间[0,x]
        // mid含义：我们要找的x平方根的值
        //排除mid==0的情况
        if (x == 0) {
            return 0;
        }
        if (x == 1) {
            return 1;
        }
        int left = 0;
        int right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mid <= x / mid) {
                left = mid + 1; // 在[mid+1,right]中继续找
            } else {
                right = mid - 1;
            }
        }
        // 循环结束时[right,left],因为目标值在[mid+1,right]中继续找，right是闭区间，因此结果返回right
        return right;
    }

    public static void main(String[] args) {
        int mySqrt = new Solution().mySqrt(2147395599);
        System.out.println(mySqrt);
    }
}
```

#### [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

![image-20210809110557435](https://i0.wp.com/tvax2.sinaimg.cn/large/00496yplgy1gvnwonvf2dj60la0ha79602.jpg)

题目可以描述为求 isBadVersion(mid)=true的左边界

**二分法关键点：明确mid含义及左右边界**

mid为要求的版本号，左边界left=1，右边界right=n

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        // 题目可以描述为求 isBadVersion(mid)=true的左边界，mid为要求的版本号，左边界left=1，右边界right=n
        int left = 1;
        int right = n;
        while (left <= right) { //1. [left,right]
            int mid = left + ((right - left) >> 1);
            if (isBadVersion(mid)) {
                right = mid - 1; //2. 在[left,mid-1]中继续搜索
            } else {
                left = mid + 1;
            }
        }
        //3. 由于在[left,mid-1]中继续搜索，当跳出循环时，返回left即是左边界
        return left;
    }
}
```

#### [475. 供暖器](https://leetcode-cn.com/problems/heaters/)

![image-20210810142204197](https://i0.wp.com/tva1.sinaimg.cn/large/00496yplgy1gvnwomvr7aj60km0hcjw802.jpg)



这个题目还是比较有趣的，解题的关键在于读懂题意：

1、**我们要对任意一个房屋供暖，要么用前面的暖气，要么用后面的暖气，两者之间取最近的，这就是距离。**

2、同时，如果要覆盖到所有的房屋，我们要选择上述距离中最大的一段，这就是最小的加热半径。

![图片.png](https://pic.leetcode-cn.com/ecdd4e4521c5acbc0810dcabd2b4c0e27cd0099f32a107acee602564b6c92de9-%E5%9B%BE%E7%89%87.png)

当然，我们可以采用暴力题解，通过双层遍历，第一层：遍历所有的房子，第二层：遍历加热器，找出距离该房子的最小距离。但是我们其实可以通过二分搜索来优化这个过程。

一、暴力法代码如下：

```java
class Solution {
    public int findNearest(int num, int[] heaters){//找到离num最近的供暖器
        int ans = Integer.MAX_VALUE;
        for(int i = 0; i < heaters.length; i++){
            ans = Math.min(ans, Math.abs(heaters[i] - num));
        }
        return ans;
    }
    public int findRadius(int[] houses, int[] heaters) {
        int res = 0;
        for(int i = 0; i < houses.length; i++){
            //供暖器取离得最近的那个的半径
            //最小加热半径要取所有半径中最大的
            res = Math.max(res, findNearest(houses[i], heaters));
        }
        return res;
    }
}
```

二、使用二分法优化findNearest函数：

```java
class Solution {
    public int findRadius(int[] houses, int[] heaters) {
        int res = 0;
        Arrays.sort(heaters);
        for (int i = 0; i < houses.length; i++) {
            int dis = findNearest(houses[i], heaters);
            res = Math.max(dis, res);
        }
        return res;
    }

    int findNearest(int num, int[] heaters) {// 找到离num最近的供暖器
        int left = 0;
        int right = heaters.length - 1;
        // 寻找左边界
        while (left <= right) {
            // mid含义：满足heaters[mid] == nums的下标左边界
            int mid = left + ((right - left) >> 1);
            if (heaters[mid] < num) {
                left = mid + 1;
            } else {
                right = mid - 1;// 在[left,mid-1]中继续查找
            }
        }
        /**
         * left下标含义：heaters数组中小于nums的个数，
         * left=0时，表示所有元素>nums;
         * left=nums.length时，表示所有元素<nums;
         * 0<left<nums.length时，表示当idx≥left时，heaters[idx]>=nums;
         */
        if (left == 0) {
            return heaters[left] - num;
        } else if (left == heaters.length) {
            return num - heaters[heaters.length - 1];
        } else if (heaters[left] == num) {
            return 0;
        } else { // headters[left] > nums
            return Math.min(num - heaters[left - 1], heaters[left] - num);
        }
    }
}
```

可以看到，`findNearest()`函数就是寻找左侧边界模板的换皮，我觉得自己已经理解了寻找左侧边界函数返回值的含义哈哈哈。

### 能力检测二分

能力检测二分一般是：定义函数 possible， 参数是 mid，返回值是布尔值。外层根据返回值调整"解空间"。

示例代码（以最左二分为例）：

```python
def ability_test_bs(nums):
  def possible(mid):
    pass
  left, right = 0, len(A) - 1
  while left <= right:
      mid = left + (right - left) // 2
      # 只有这里和最左二分不一样
      if possible(mid): right = mid - 1 # 在[left,mid-1]中继续查找
      else: left = mid + 1
  return left
```

和最左最右二分这两种最最基本的类型相比，能力检测二分**只是将 while 内部的 if 语句调整为了一个函数罢了**。

#### [875.爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas)

![cb85d759a86036b3e1b13a6c93c27909d036af01](https://i0.wp.com/tva4.sinaimg.cn/mw690/00496yplgy1gvo4lzxxilj60jz0gyn0j02.jpg)

---

只要从 1 开始穷举到 `max(piles)`，一旦发现发现某个值可以在 `H` 小时内吃完所有香蕉，这个值就是最小速度：

```java
int minEatingSpeed(int[] piles, int H) {
	// piles 数组的最大值
    int max = getMax(piles);
    for (int speed = 1; speed < max; speed++) {
    	// 以 speed 是否能在 H 小时内吃完香蕉
        if (canFinish(piles, speed, H))
            return speed;
    }
    return max;
}
```

**注意这个 for 循环，就是在连续的空间线性搜索，这就是二分查找可以发挥作用的标志。**由于我们要求的是最小速度，所以可以用一个搜索左侧边界的二分查找来代替线性搜索，提升效率：

```c
int minEatingSpeed(int[] piles, int H) {
    // 套用搜索左侧边界的算法框架
    int left = 1, right = getMax(piles) + 1;
    while (left < right) {
        // 防止溢出
        int mid = left + (right - left) / 2;
        if (canFinish(piles, mid, H)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

// 时间复杂度 O(N)
boolean canFinish(int[] piles, int speed, int H) {
    int time = 0;
    for (int n : piles) {
        time += timeOf(n, speed);
    }
    return time <= H;
}

int timeOf(int n, int speed) {
    return (n / speed) + ((n % speed > 0) ? 1 : 0);
}

int getMax(int[] piles) {
    int max = 0;
    for (int n : piles)
        max = Math.max(n, max);
    return max;
}
```



#### [1011.在D天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days)

传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。

 

示例 1：

输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 

---

其实本质上和 Koko 吃香蕉的问题一样的，不同的是确定 `cap` 的最小值和最大值分别为 `max(weights)` 和 `sum(weights)`。

```c
// 寻找左侧边界的二分查找
int shipWithinDays(int[] weights, int D) {
	// 载重可能的最小值
    int left = getMax(weights);
	// 载重可能的最大值 + 1
    int right = getSum(weights) + 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (canFinish(weights, D, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

// 如果载重为 cap，是否能在 D 天内运完货物？
boolean canFinish(int[] w, int D, int cap) {
    int i = 0;
    for (int day = 0; day < D; day++) {
        int maxCap = cap;
        while ((maxCap -= w[i]) >= 0) {
            i++;
            if (i == w.length)
                return true;
        }
    }
    return false;
}
```



#### [778. 水位上升的泳池中游泳](https://leetcode-cn.com/problems/swim-in-rising-water/)

![image-20210810154420295](https://i0.wp.com/tva4.sinaimg.cn/large/00496yplgy1gvnwomkninj60l50li0zm02.jpg)

题目可以描述为：给定水位t，当矩阵中数值≤t时，这些区域可以连通，求t的最小值，使得左上角到右下角连通。

题意分析：dfs+二分法

mid表示时间水位为mid时可以实现左上角到右下角的联通；

解空间为[left,right],其中left=0;right = max(nums)（**解空间只要保证正确就可以，没有必要那么精确**，如果要写的更精确一点，就是`left=grid[n-1][n-1]`）

因此一个简单的思路是一个个试。

- 试试 a 可以不
- 试试 a+1 可以不
- 。。。

**试试 x 是否可行**就是能力检测，是二分应用的一种。

```java
class Solution3 {

    public int swimInWater(int[][] grid) {
        int n = grid.length;
        int max = 0;
        for (int[] arr : grid) {
            for (int num : arr) {
                max = Math.max(max, num);
            }
        }
        int left = grid[n - 1][n - 1];
        int right = max;
        while (left <= right) {// 寻找左边界
            boolean[][] visited = new boolean[n][n];
            // 表示（水位为mid）可以实现左上角到右下角的联通；
            int mid = left + (right - left) / 2;
            boolean isOk = help1(grid, visited, 0, 0, n, mid);
            if (isOk) {
                right = mid - 1; // 在[left,mid-1]继续查找
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    // 将水位≤t的坐标连通，判断(x,y)能否连通到(n-1,n-1);
    // 将水位≤t的值看作0，水位＞t的值看作1
    boolean help1(int[][] grid, boolean[][] visited, int x, int y, int n, int t) {
        if (x < 0 || x > n - 1 || y < 0 || y > n - 1) {
            return false;
        }
        if (grid[x][y] > t) {
            return false;
        }
        if (grid[x][y] <= t && (x == n - 1 && y == n - 1)) {
            return true;
        }
        // 坐标非右下角，且水位≤t
        if (visited[x][y]) {
            return false;
        }
        visited[x][y] = true;
        boolean res = 
            help1(grid, visited, x + 1, y, n, t) || 
            help1(grid, visited, x - 1, y, n, t) || 
            help1(grid, visited, x, y + 1, n, t) || 
            help1(grid, visited, x, y - 1, n, t);
        return res;

    }
}
```

### 计数二分

计算小于等于 x 的有多少，然后根据答案更新解空间。

#### [719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)

![image-20210812111208833](https://i0.wp.com/tvax2.sinaimg.cn/large/00496yplgy1gvnwolm62ej60ig0cw76u02.jpg)



最容易想到的是暴力解法，使用map统计所有数字对的距离差和个数，即`{距离差：个数}`，然后找出第 k 小的距离对。

```python
class Solution(object):
    def smallestDistancePair(self, nums, k):
        dist = dict()
        size = len(nums) 
        for i in range(size):
            for j in range(i+1, size):
                distance = abs(nums[i]-nums[j])
                if distance in dist:
                    dist[distance]+= 1
                else:
                    dist[distance] = 1
        #  找出第 k 小的距离对          
        count = 0
        for i in range(0,1000000):
            if i in dist:
                count += dist[i]     
                if count>=k: return i
```

但是这种方法肯定会超时。像这种题，观察数据量级很重要。一看n=10^4，O(n2)基本是超时的，O(n)又不太现实，所以想到O(nlogn)，自然就知道用二分了.

转换思路，我们先对数组排序，我们知道排序后，数对距离一定在` [0,nums[len(nums)-1] - nums[0]]`之间 然后我们在这个区间枚举距离d，看对于每个d，有多少对数字的距离 <= d（假设为count个），如果 count大于k了，这个距离肯定不是要求的距离，然后我们缩小范围，这里可以采用二分的思想求距离d。  伪代码如下：

```python
def smallestDistancePair(nums, k): #  找出第 k 小的距离对 
  def count_not_greater(mid): 
    pass
  left, right = 0, len(A) - 1
  while left <= right:
      mid = left + (right - left) // 2 # mid即为枚举的距离
      # 只有这里和最左二分不一样
      count= count_not_greater(mid) # count为距离小于等于mid的距离对数量
      if count > k: right = mid - 1 # 在[left,mid-1]中继续查找
      else: left = mid + 1
  return left
```

采用双指针求`count_not_greater()`.

具体做法： 如果对于每个i，如果能得到 j为起始坐标，刚好满足nums[i] - nums[j] <=mid, 那么对于nums[i], 有（i - j）个距离对符合要求。（因为是刚好满足，所以对于下标小于j的数字 ，与nums[i]的距离会增大，就大于mid了）.

对于每个nums[i]，j无需从头遍历，因为nums[i]-nums[j]<= mid的首尾下标i,j是刚好满足条件时的值， 那么我们得到nums[i]-nums[j-1]肯定不满足条件，即nums[i] - nums[j-1] > mid， 那么nums[i+1]-nums[j-1]距离只会更大，所以只需要判断nums[i+1]-nums[j]能否满足条件了。 所以找count的时间复杂度为O(len(nums)+max(j))， max(j)为i= nums[n-1]时，刚好满足条件nums[n-1]-nums[j]<=mid时的下标j。 伪代码如下：

```python
def getCount(i,j,nums):
    count, j= 0, 0
    for i in range(1,n):
        while j<len(nums) and nums[i]-nums[j]>mid: 
            j+=1
        count += i-j  
    return count
```

完整代码如下：

```python
class Solution(object):
    def count_not_greater(self, d, nums, size): # 距离小于等于d的距离对数量
        j,count = 0, 0
        for i in range(1, size):
            while nums[i]-nums[j] > d: j+=1
                count += i-j
                return count
            
    def smallestDistancePair(self,nums, k): #  找出第 k 小的距离对 
      nums.sort()
      left, right = 0, len(A) - 1
      while left <= right:
          mid = left + (right - left) // 2 # mid即为枚举的距离d
          # 只有这里和最左二分不一样
          count= count_not_greater(mid)
          if count > k: right = mid - 1 # 在[left,mid-1]中继续查找
          else: left = mid + 1
      return left
```



## 构建有序序列

**构建有序序列**的方法包括直接排序二分、前缀和二分和插入排序二分。

### 直接排序二分

代码表示：

```python
nums.sort()
bisect.bisect_left(nums, x) # 最左二分
bisect.bisect_right(nums, x) # 最右二分
```



### 前缀和二分

如果数组全是正的，那么其前缀和就是一个严格递增的数组，基于这个特性，我们可以在其之上做二分。类似的有单调栈/队列。

#### [528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)

Difficulty: **中等**


给定一个正整数数组 `w` ，其中 `w[i]` 代表下标 `i` 的权重（下标从 `0` 开始），请写一个函数 `pickIndex` ，它可以随机地获取下标 `i`，选取下标 `i` 的概率与 `w[i]` 成正比。

例如，对于 `w = [1, 3]`，挑选下标 `0` 的概率为 `1 / (1 + 3) = 0.25` （即，25%），而选取下标 `1` 的概率为 `3 / (1 + 3) = 0.75`（即，75%）。

也就是说，选取下标 `i` 的概率为 `w[i] / sum(w)` 。

**示例 1：**

```
输入：
["Solution","pickIndex"]
[[[1]],[]]
输出：
[null,0]
解释：
Solution solution = new Solution([1]);
solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。
```

**示例 2：**

```
输入：
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
输出：
[null,1,1,1,1,0]
解释：
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。

由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
诸若此类。
```

**提示：**

*   `1 <= w.length <= 10000`
*   `1 <= w[i] <= 10^5`
*   `pickIndex` 将被调用不超过 `10000` 次



* 二分法变形题
* 应用场景：轮盘赌策略，遗传算法，word2vec负采样，kmeans++选初始中心都有用到

拿 `[3, 2, 4]` 来举例子，我们需要根据权重获取随机数，所以需要从头开始将权重值进行逐步累积，累积后前缀和为`[3, 5, 9]`，即

```python
preSum    3    5    9
w         3    2    4
idx       0    1    2
```

然后使用Random产生一个`[0, 15)`之间的随机数

题目要求随机数取到 下标0的概率为3/9，取到下标1的概率为2/9，取到下标2的概率为4/9.

计算区间长度容易得知，随机数取到 `[0, 3)` 范围内的概率为3/9，取到 `[3, 5)` 范围内的概率为2/9，取到`[5, 9)`范围内的概率为4/9

而在前缀和数组中，下标i = 0、1、2对应的preSum[i]恰好就为3、 5、 9，即题目要求的取到前缀和中该下标的概率就等于取到前缀和区间的概率。

**所以取下标的问题就转换为判断该随机数位于前缀和数组中哪个区间的问题。**

因为前缀和有序，需要使用二分法来**找到前缀和大于 `target` 的的最小下标。**



* 上述过程可以描述为下面的步骤：

1.求出前缀和数组 p，其中$p[x] = \sum_{i=0}^{x}w[i]$。

2.在范围[0,tot) 中随机选择一个整数targ。

3.使用二分查找来找到下标 x，其中 x 是满足p[x] > targ的最小下标。



```java
class Solution {
    int[] preSum;
    Random random = new Random();

    public Solution(int[] w) {
        preSum = new int[w.length];
        for (int i = 0; i < w.length; i++) {
            preSum[i] = i == 0 ? w[0] : preSum[i - 1] + w[i];
        }
    }

    // 寻找左侧边界的变形
    public int pickIndex() {
        int left = 0;
        int right = preSum.length - 1;//搜索区间[left,right]
        int target = random.nextInt(preSum[preSum.length - 1]);
        while (left < right) { //当left == right时退出，变形①
            int mid = left + (right - left) / 2; // mid含义：preSum[mid]>target的最小下标
            if (preSum[mid] > target) {
                right = mid;// 在[left,mid]中继续查找，变形②
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```

时间复杂度：O(N)的预处理。priceIndex 需要花费O(log(N)) 的时间,因此时间复杂度为O(N)。
空间复杂度：O(N)。




### 插入排序二分

遍历过程维护一个新的有序序列，有序序列的内容为**已经遍历过的值的集合**。

比如无序数组 [3,2,10,5]，遍历到索引为 2 的项（也就是值为 10 的项）时，我们构建的有序序列为 [2,3,10]。

![image-20210816141747371](https://i0.wp.com/tvax4.sinaimg.cn/large/00496yplgy1gvnwol16d6j607g05tmxh02.jpg)

代码表示：

```python
d = SortedList() # Python 可使用 SortedList 来实现， Java 可用 TreeSet 代替。
for a in A:
    d.add(a) # 将 a 添加到 d，并维持 d 中数据有序
```

上面代码的 d 就是有序序列。

> 注意我描述的是有序序列，并不是指数组，链表等具体的数据结构。而实际上，这个有序序列很多情况下是平衡二叉树。后面题目会体现这一点。



## 其他高频题目

### 「搜索旋转排序数组」

见专题介绍。

### 二维数组

二维数组的二分查找和一维没有本质区别， 我们通过两个题来进行说明。

#### [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

![image-20210806105756490](https://i0.wp.com/tvax4.sinaimg.cn/large/00496yplgy1gvnwop4ujcj60et0ciwh502.jpg)

![image-20210806105732718](https://i0.wp.com/tvax2.sinaimg.cn/large/00496yplgy1gvnwop8igoj60es0dxdhb02.jpg)

一、根据矩阵特征选择往上或者往右运动

根据题意已知，二维数组从左往右递增，从上往下递增，所以得出以下结论：

1. 某列的某个数字，该数之上的数字，都比其小；
2. 某行的某个数字，该数右侧的数字，都比其大；

- 所以，解题流程如下所示：
  1. 以二维数组左下角为原点，建立直角坐标轴。
  2. 若当前数字大于了查找数，查找往上移一位。
  3. 若当前数字小于了查找数，查找往右移一位。



```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int rows = matrix.length - 1, columns = 0;
        while (rows >= 0 && columns < matrix[0].length) {
            int num = matrix[rows][columns];
            if (num == target) {
                return true;
            } else if (num > target) {
                rows--;
            } else {
                columns++;
            }
        }
        return false;
    }
}
```

- 时间复杂度：$O(\log{m} + \log{n})=O(\log m*n)$
- 空间复杂度：$O(1)$

二、当然，因为将二维矩阵的行尾和行首连接，也具有单调性。

我们可以将「二维矩阵」当做「一维矩阵」来做。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        int low = 0, high = m * n - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int x = matrix[mid / n][mid % n];
            if (x < target) {
                low = mid + 1;
            } else if (x > target) {
                high = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    }
}
```

- 时间复杂度：$$O(\log{(m * n)})$$
- 空间复杂度：$O(1)$

#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

![image-20210806112647112](https://i0.wp.com/tvax4.sinaimg.cn/large/00496yplgy1gvnwop0ka3j60l30je0wr02.jpg)

每行数组，从左到右升序

每列数组，从下到上降序

因此，选择左下角元素开始二分。

跟74. 搜索二维矩阵 解法一模一样

# 题目推荐（代办）

- [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)
- [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/)
- [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)
- [面试题 17.08. 马戏团人塔](https://leetcode-cn.com/problems/circus-tower-lcci/)

> 后面三个题建议一起做

![image-20210806140022877](https://i0.wp.com/tvax1.sinaimg.cn/large/00496yplgy1gvnwool4ubj607w0cvdhn02.jpg)

## 其他

#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

题目：统计一个数字在排序数组中出现的次数。

分析：有序数组，查找target出现的左边界和右边界，再判断target是否存在来返回target的数量。

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = left_bound(nums, target);
        int right = right_bound(nums, target);
        if (left == -1) { // target不存在，此时left==-1&&right==-1成立
            return 0;
        }
        return right - left + 1;
    }
}
```



#### [162\. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

Difficulty: **中等**


峰值元素是指其值大于左右相邻值的元素。

给你一个输入数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2：**

```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

**提示：**

*   `1 <= nums.length <= 1000`
*   -2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1
*   对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

**进阶：**你可以实现时间复杂度为 `O(logN)`的解决方案吗？



* 二分法变形
* 定义区间[left,right],后续代码发生了种种变形

首先要注意题目条件，在题目描述中出现了 `nums[-1] = nums[n] = -∞`，这就代表着 **只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值**

根据上述结论，我们就可以使用二分查找找到峰值

根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，**如果 m 较大**，则左侧存在峰值，r = m，**如果 m + 1 较大**，则右侧存在峰值，l = m + 1

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1; //区间[left,right]
        while (left < right) {// left==right时退出循环 变形①
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {// 峰值在左侧
                right = mid;//变形②
            } else {
                left = mid + 1;// 峰值在右侧
            }
        }
        return left;
    }
}
```

#### [287\. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

Difficulty: **中等**


给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `1` 到 `n`之间（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，找出 **这个重复的数** 。

你设计的解决方案必须不修改数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

**示例 3：**

```
输入：nums = [1,1]
输出：1
```

**示例 4：**

```
输入：nums = [1,1,2]
输出：1
```

**提示：**

*   1 <= n <= 10<sup>5</sup>
*   `nums.length == n + 1`
*   `1 <= nums[i] <= n`
*   `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

**进阶：**

*   如何证明 `nums` 中至少存在一个重复的数字?
*   你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？





方法一、快慢指针O(n)

使用环形链表II的方法解题（142.环形链表II），使用 142 题的思想来解决此题的关键是要理解如何将输入的数组看作为链表。  
首先明确前提，整数的数组 `nums` 中的数字范围是 `[1,n]`。考虑一下两种情况：

1.  如果数组中没有重复的数，以数组 `[1,3,4,2]`为例，我们将数组下标 `n` 和数 `nums[n]` 建立一个映射关系 f(n)，其映射关系 `n->f(n)`为：  
    0->1  
    1->3  
    2->4  
    3->2  
    我们从下标为 0 出发，根据 f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。这样可以产生一个类似链表一样的序列。  
    `0->1->3->2->4->null`

2.  如果数组中有重复的数，以数组 `[1,3,4,2,2]` 为例,我们将数组下标 `n` 和数 `nums[n]` 建立一个映射关系 f(n)，其映射关系 `n->f(n)` 为：  
    0->1  
    1->3  
    2->4  
    3->2  
    4->2  
    同样的，我们从下标为 0 出发，根据 f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。  
    0->1->3->2->4->2->4->2->……  
    这里 `2->4` 是一个循环，那么这个链表可以抽象为下图：  
    ![287.png](https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png)

从理论上讲，数组中如果有重复的数，那么就会产生多对一的映射，这样，形成的链表就一定会有环路了，

**综上  
1.数组中有一个重复的整数 `<==>` 链表中存在环  
2.找到数组中的重复整数 `<==>` 找到链表的环入口**

至此，问题转换为 142 题。那么针对此题，快、慢指针该如何走呢。根据上述数组转链表的映射关系，可推出  
142 题中慢指针走一步 slow = slow.next ==> 本题 slow = nums\[slow\]  
142 题中快指针走两步 fast = fast.next.next ==> 本题 fast = nums\[nums\[fast\]\]

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        slow = nums[slow];
        fast = nums[nums[fast]];
        while(slow != fast){
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        int pre1 = 0;
        int pre2 = slow;
        while(pre1 != pre2){
            pre1 = nums[pre1];
            pre2 = nums[pre2];
        }
        return pre1;
    }
}
```

遍历了一遍数组，时间复杂度O(n)；只使用常量级的变量，空间复杂度O(1)。

方法二：二分法O(nlogn) 超时

使用二分法查找一个有范围的整数（结合抽屉原理）

抽屉原理：把 10 个苹果放进 9 个抽屉，一定存在某个抽屉放至少 2 个苹果。

二分查找的思路是先猜一个数（有效范围 [left..right] 里位于中间的数 mid），然后统计原始数组中 小于等于 mid 的元素的个数 cnt：

如果 cnt 严格大于 mid。根据抽屉原理，重复元素就在区间 [left..mid] 里；
否则，重复元素就在区间 [mid + 1..right] 里。

```java
public class Solution {

    public int findDuplicate(int[] nums) {
        int len = nums.length;
        int left = 1;
        int right = len - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            int cnt = 0;
            for (int num : nums) {
                if (num <= mid) {
                    cnt += 1;
                }
            }

            // 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个，此时重复元素一定出现在 [1..4] 区间里
            if (cnt > mid) {
                // 重复元素位于区间 [left..mid]
                right = mid;
            } else {
                // if 分析正确了以后，else 搜索的区间就是 if 的反面区间 [mid + 1..right]
                left = mid + 1;
            }
        }
        return left;
    }
}
```

时间复杂度：O(NlogN)，二分法的时间复杂度为 O(logN)，在二分法的内部，执行了一次 for 循环，时间复杂度为 O(N)，故时间复杂度为 O(NlogN)。



#### [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/)

![image-20210810120553369](https://i0.wp.com/tva2.sinaimg.cn/large/00496yplgy1gvnwon3q6jj60ld0l8dmq02.jpg)

![image-20210810120607913](https://i0.wp.com/tvax3.sinaimg.cn/large/00496yplgy1gvnwomzqhoj60la06wwf902.jpg)

题目描述：相当于在山脉数组中寻找target出现的第一个下标，有点类似旋转数组。

题意分析：

* 二分法

第 1 步：先找到山顶元素 `mountaintop` 所在的索引。

![fig1](https://assets.leetcode-cn.com/solution-static/1095/1095_fig1.png)

第 2 步：在前有序且升序数组中找 target 所在的索引，如果找到了，就返回；

第 3 步：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引。

```java
class Solution {
    public int findInMountainArray(int target, MountainArray mountainArr) {
        int n = mountainArr.length();
        //找到i
        int i = binarySearchTop(mountainArr, 0, n);
        //二分查找
        int res1 = binarySearch1(mountainArr, 0, i + 1, target);
        if(res1 != -1){
        	return res1;
        }
        int res2 = binarySearch2(mountainArr, i + 1, n, target);
		return res2;
    }

    private int binarySearchTop(MountainArray mountainArr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            if (mid + 1 < mountainArr.length() && mountainArr.get(mid) < mountainArr.get(mid + 1)) {
                return binarySearchTop(mountainArr, mid + 1, right);
            } else {
                return binarySearchTop(mountainArr, left, mid);
            }
        }
        return left;
    }

    private int binarySearch1(MountainArray mountainArr, int left, int right, int target) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) == target) {
                return mid;
            } else if (mountainArr.get(mid) > target) {
                return binarySearch1(mountainArr, left, mid, target);
            } else {
                return binarySearch1(mountainArr, mid + 1, right, target);
            }
        }
        return -1;
    }

    private int binarySearch2(MountainArray mountainArr, int left, int right, int target) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) == target) {
                return mid;
            } else if (mountainArr.get(mid) > target) {
                return binarySearch2(mountainArr, mid + 1, right, target);
            } else {
                return binarySearch2(mountainArr, left, mid, target);
            }
        }
        return -1;
    }
}

```



#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

一、动态规划$O(n^2)$

二、二分查找法：扑克牌O(nlogn)

其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

![image-20210806172007240](https://i0.wp.com/tva1.sinaimg.cn/large/00496yplgy1gvnwooat2zj60kv04jq4802.jpg)



**处理这些扑克牌要遵循以下规则**：

只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。

![image-20210806172035053](https://i0.wp.com/tva4.sinaimg.cn/large/00496yplgy1gvnwoo56omj60kv0a2aci02.jpg)

为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。

按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，证明略。

![ba781198ca3e6d3a012bc6d27bf3d7d4190f5e11](https://i0.wp.com/tvax1.sinaimg.cn/mw690/00496yplgy1gvo4nk6qizj60pb0ebwfk02.jpg)

我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是**有序**吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。

```c
public int lengthOfLIS(int[] nums) {
    int[] top = new int[nums.length];
    // 牌堆数初始化为 0
    int piles = 0;
    for (int i = 0; i < nums.length; i++) {
        // 要处理的扑克牌
        int poker = nums[i];

        /***** 搜索左侧边界的二分查找 *****/
        int left = 0, right = piles;
        while (left < right) {
            int mid = (left + right) / 2;
            if (top[mid] > poker) {
                right = mid;
            } else if (top[mid] < poker) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        /*********************************/

        // 没找到合适的牌堆，新建一堆
        if (left == piles) piles++;
        // 把这张牌放到牌堆顶
        top[left] = poker;
    }
    // 牌堆数就是 LIS 长度
    return piles;
}
```



#### 

#### [35\. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

Difficulty: **简单**


给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

**示例 4:**

```
输入: nums = [1,3,5,6], target = 0
输出: 0
```

**示例 5:**

```
输入: nums = [1], target = 0
输出: 0
```

**提示:**

*   `1 <= nums.length <= 10<sup>4</sup>`
*   `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`
*   `nums` 为**无重复元素**的**升序**排列数组
*   `-10<sup>4</sup> <= target <= 10<sup>4</sup>`



经过分析，题目是要求二分法左侧边界`int pos= left_bound(int[]nums,int target)`，因为左侧边界`pos`的定义就是nums数组中在pos位置左边有pos个小于`nums[pos]`的数。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        return left_bound(nums, target);
    }

    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // ① 不可以直接返回，应该继续向左边找，即 [left..mid - 1] 区间里找
                right = mid - 1;
            }
        }
        return left;
    }
}
```

#### [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)

![image-20210622170003281](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210622170003281.png)



面试做算法题的时候，题目一般都会要求算法的时间复杂度，如果你发现 O(NlogN) 这样存在对数的复杂度，一般都要往二分查找的方向上靠，这也算是个小套路。



做法二、二分法

这个题目非常关键的字眼是：**非负整数数组**、**非空** 和 **连续**。

挖掘单调性：使用二分查找的一个前提是「数组具有单调性」，我们就去想想有没有单调性可以挖掘，不难发现：

如果设置「数组各自和的最大值」很大，那么必然导致分割数很小；
如果设置「数组各自和的最大值」很小，那么必然导致分割数很大。

仔细想想，这里「**数组各自和的最大值**」就决定了一种分割的方法。那么，我们就可以通过调整「数组各自和的最大值」来达到：使得分割数恰好为 `m` 的效果。这里要注意一个问题：

注意事项：如果某个 数组各自和的最大值 恰恰好使得分割数为 m ，此时不能放弃搜索，因为我们要使得这个最大值 最小化，此时还应该继续尝试缩小这个 数组各自和的最大值 ，使得分割数超过 m ，超过 m 的最后一个使得分割数为 m 的 数组各自和的最大值 就是我们要找的 最小值。

这里想不太明白的话，可以举一个具体的例子：

例如：（题目中给出的示例）输入数组为 [7, 2, 5, 10, 8] ，m = 2 。如果设置 数组各自和的最大值 为 21，那么分割是 [7, 2, 5, | 10, 8]，此时 m = 2，此时，这个值太大，尝试一点一点缩小：

设置 数组各自和的最大值 为 20，此时分割依然是 [7, 2, 5, | 10, 8]，m = 2；
设置 数组各自和的最大值 为 19，此时分割依然是 [7, 2, 5, | 10, 8]，m = 2；
设置 数组各自和的最大值 为 18，此时分割依然是 [7, 2, 5, | 10, 8]，m = 2；
设置 数组各自和的最大值 为 17，此时分割就变成了 [7, 2, 5, | 10, | 8]，这时 m = 3。
m 变成 3 之前的值 数组各自和的最大值 18 是这个问题的最小值，所以输出 18。

```java
public class Solution {

    public int splitArray(int[] nums, int m) {
        int max = 0;
        int sum = 0;

        // 计算「子数组各自的和的最大值」的上下界
        for (int num : nums) {
            max = Math.max(max, num);
            sum += num;
        }

        // 使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，
        // 使得它对应的「子数组的分割数」恰好等于 m
        // 寻找左侧边界
        int left = max;
        int right = sum;
        while (left < right) {
            int mid = left + (right - left) / 2;

            int splits = split(nums, mid);
            if (splits > m) {
                // 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大
                // 下一轮搜索的区间是 [mid + 1, right]
                left = mid + 1;
            } else {
                // 下一轮搜索的区间是上一轮的反面区间 [left, mid]
                right = mid;
            }
        }
        return left;
    }

    /***
     *
     * @param nums 原始数组
     * @param maxIntervalSum 子数组各自的和的最大值
     * @return 满足不超过「子数组各自的和的最大值」的分割数
     */
    private int split(int[] nums, int maxIntervalSum) {
        // 至少是一个分割
        int splits = 1;
        // 当前区间的和
        int curIntervalSum = 0;
        for (int num : nums) {
            // 尝试加上当前遍历的这个数，如果加上去超过了「子数组各自的和的最大值」，就不加这个数，另起炉灶
            if (curIntervalSum + num > maxIntervalSum) {
                curIntervalSum = 0;
                splits++;
            }
            curIntervalSum += num;
        }
        return splits;
    }
}
```

总结：枚举子数组各自的和的最大值与分割数相对应，二分法查找左边界

扩展阅读：https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/er-fen-fen-ge-zi-shu-zu

做法三、动态规划

