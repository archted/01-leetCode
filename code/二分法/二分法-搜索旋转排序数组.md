## 搜索旋转排序数组

「搜索旋转排序数组」是二分法的一种应用。

LeetCode 33 题：搜索旋转排序数组
LeetCode 81 题：搜索旋转排序数组-ii
LeetCode 153 题：寻找旋转排序数组中的最小值
LeetCode 154 题：寻找旋转排序数组中的最小值-ii
可以分为 3 类：

33、81 题：搜索特定值
153、154 题：搜索最小值
81、154 题：包含重复元素

### 搜索特定值

其中 81 题是在 33 题的基础上增加了`包含重复元素`的可能，实际上 33 题的进阶就是 81 题。

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

![image-20210806140822717](https://i0.wp.com/tva4.sinaimg.cn/large/00496yplgy1gvnwooev6aj60l90lg44a02.jpg)

题目要点：nums元素唯一，需要使用O(nlogn)方法。

首先要知道，我们随便选择一个点，将数组分为前后两部分，其中一部分一定是有序的。

- 我们可以先找出 mid，然后根据 mid 来判断，mid 是在有序的部分还是无序的部分。**根据旋转数组的特性，当元素不重复时，如果 nums[i] <= nums[j]，说明区间 [i,j] 是「连续递增」的。**i、j 可以重合，所以这里使用的比较运算符是「小于等于」。

![image.png](https://pic.leetcode-cn.com/f7a76bf084aa4e3296eacedd0f3845d5a68ee7064a42f2a0affe62054cca1882-image.png)

1)如上图所示，`nums[mid]>left && nums[mid]>right`,则 mid 一定在左边有序部分，即 [left,mid]部分有序。

![image.png](https://pic.leetcode-cn.com/f4e1d8b0ec3cd903037611666236efb9fd311e3022d12fb7071a995259e564d9-image.png)

2)如上图所示， `nums[mid] < nums[left] && nums[mid] < nums[right]`，则 mid 一定在右边有序部分，即 [mid,end] 部分有序。

3)在旋转矩阵题目中，如果数组元素唯一，

如果使用`if (nums[mid] >= nums[left])`or`if (nums[mid] <= nums[left])`判断条件，当且仅当`left == right`or`right = left+1`时，等号成立，即`nums[mid] == nums[left]`

如果使用`if (nums[mid] >= nums[right])`or`if (nums[mid] <= nums[right)`判断条件，当且仅当`left == right`时，等号成立，即`nums[mid] == nums[right]`

**综上所述，`if (nums[mid] >= nums[left])`判断左边有序,`if (nums[mid] <= nums[right)`判断右边有序，这样就包含了等于的情况。简而言之，判断左边有序使用左边界，判断右边有序使用右边界。**

* 然后我们继续判断 target 在哪一部分， 就可以舍弃另一部分了。

只需要比较 target 和**有序部分**的边界关系就行了。 比如 mid 在右侧有序部分，即[mid,end] 有序。那么我们只需要判断`target <= nums[right] && target > nums[mid]`就能知道 target 在右侧有序部分，我们就 可以舍弃左边部分了(通过 left= mid + 1 实现)， 反之target在左侧，舍弃右边部分。



```java
class Solution {
    public int search(int[] nums, int target) {
        //左右指针
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right-left)>>1);
            if (nums[mid] == target) {
                return mid;
            }
			//左边有序, 当mid==left时，right==left/left+1,nums[mid] == nums[left]
            if (nums[mid] >= nums[left]) {
				
                if (nums[mid] > target && target >= nums[left]) {
                       right = mid - 1;
                } else{
                       left = mid + 1;
                } 
            }else if (nums[mid] <= nums[right]) {
		//右边有序  or写成  if(nums[mid] < nums[left]) or  直接else
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else{
                    right = mid - 1;
                }
            } 
        }
        //没有查找到
        return -1;
    }
}
```





#### [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

![image-20210805170059917](https://i0.wp.com/tvax4.sinaimg.cn/large/00496yplgy1gvnwo3sf0nj60kz0k3grm02.jpg)



假如nums = [3,1,1,3,3,3,3]或者[3,3,3,1,1,3]

![image-20210819142712398](https://i0.wp.com/tva2.sinaimg.cn/large/00496yplgy1gvnwoj5ay9j604l04e3yb02.jpg)![image-20210819142721971](https://i0.wp.com/tvax1.sinaimg.cn/large/00496yplgy1gvnwoizkmvj604903r3yb02.jpg)  

，`nums[mid] == nums[left]`，分不清到底是前面有序还是后面有序。此时 left++ 即可。相当于去掉一个重复的干扰项。

> 有的同学会担心”会不会错失目标元素？“。其实这个担心是多余的，前面我们已经介绍了”搜索区间“。**由于搜索区间同时包含 left和 mid ，因此去除一个 left，我们还有 mid。**假如 3 是我们要找的元素， 这样进行下去绝对不会错过，而是收缩”搜索区间“到一个元素 3 ，我们就可以心安理得地返回 3 了。**因此，必须使用[] (左闭右闭)的搜索空间。**

其他部分的代码基本和第33题代码一样。

```java
class Solution {
    public boolean search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                return true;
            }
            if (nums[mid] == nums[left]) {
                left++;
                continue;
            }
            if (nums[mid] > nums[left]) {
                if (nums[mid] > target && target >= nums[left]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return false;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(log N)$
- 空间复杂度：$O(1)$

### 搜索最小值

上面全部都是找到给定值，这次我们试图寻找最值（最小或者最大）。我们以最小为例，讲解一下这种题如何切入。

#### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

![image-20210806115327351](https://i0.wp.com/tva2.sinaimg.cn/large/00496yplgy1gvnwooqb8dj60lb0kjgrc02.jpg)

![image.png](https://pic.leetcode-cn.com/f7a76bf084aa4e3296eacedd0f3845d5a68ee7064a42f2a0affe62054cca1882-image.png)![image.png](https://pic.leetcode-cn.com/f4e1d8b0ec3cd903037611666236efb9fd311e3022d12fb7071a995259e564d9-image.png)

和查找指定值的思路一样。我们还是：

- 初始化首尾指针 l 和 r
- `if(nums[mid] >= nums[l])`，说明 mid 在左侧有序部分，由于最小的一定在右侧，因此可以收缩左区间，即 l = mid + 1
- 否则收缩右侧，即 r = mid（不可以 r = mid - 1）

- 当 l == r 或者 nums[l] < nums[r] 的时候直接返回，实际上是不会跳出循环的。

**代码（Python）**

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1  # [l,r]

        while l <= r: 
            # important
            if nums[l] < nums[r] or l == r: # 如果 [left,right] 递增 或者l == r时，直接返回
                return nums[l]
            mid = (l + r) // 2
            # left part
            if nums[mid] >= nums[l]: # 左边有序
                l = mid + 1
            else: 
                # right part
                r = mid # 不可以 r = mid - 1
        return -1 # 实际上是不会跳出循环
```

#### [154.寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

![image-20210819115416428](https://i0.wp.com/tvax3.sinaimg.cn/large/00496yplgy1gvnwojd2wcj60nz0kjn3e02.jpg)

题目分析：与153题的区别，本题数组包含重复元素。

假如nums = [3,1,1,3,3,3,3]或者[3,3,3,1,1,3]

![image-20210819142712398](https://i0.wp.com/tva2.sinaimg.cn/large/00496yplgy1gvnwoj5ay9j604l04e3yb02.jpg)![image-20210819142721971](https://i0.wp.com/tvax1.sinaimg.cn/large/00496yplgy1gvnwoizkmvj604903r3yb02.jpg)  

，`nums[mid] == nums[left]`，分不清到底是前面有序还是后面有序。此时 left++ 即可。相当于去掉一个重复的干扰项。

> **因此，对于包含重复元素的数组，必须使用[] (左闭右闭)的搜索空间，才可以left++**

其他部分的代码基本和第153题代码一样。与81题对比33题的做法一模一样。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1  # [l,r]

        while l <= r: 
            # important
            if nums[l] < nums[r] or l == r: # 如果 [left,right] 递增 或者l == r时，直接返回
                return nums[l]

            mid = (l + r) // 2
            if nums[l] == nums[mid]:
                l += 1
                continue
            # left part
            if nums[mid] > nums[l]: # 左边有序
                l = mid + 1
            else: 
                # right part
                r = mid # 不可以 r = mid - 1
        return -1 # 实际上是不会跳出循环
```

### 总结

1.不包含重复元素的数组。

![image.png](https://pic.leetcode-cn.com/f7a76bf084aa4e3296eacedd0f3845d5a68ee7064a42f2a0affe62054cca1882-image.png)![image.png](https://pic.leetcode-cn.com/f4e1d8b0ec3cd903037611666236efb9fd311e3022d12fb7071a995259e564d9-image.png)

**根据旋转数组的特性，当元素不重复时，如果 nums[i] <= nums[j]，说明区间 [i,j] 是「连续递增」的。**`if (nums[mid] >= nums[left])`判断左边有序(左图),`if (nums[mid] <= nums[right)`判断右边有序（右图），这样就包含了等于的情况。简而言之，判断左边有序使用左边界，判断右边有序使用右边界。

2.包含重复元素的数组

与不包含重复元素数组的解法，只有一个区别：

假如nums = [3,1,1,3,3,3,3]或者[3,3,3,1,1,3]：

![image-20210819142712398](https://i0.wp.com/tva2.sinaimg.cn/large/00496yplgy1gvnwoj5ay9j604l04e3yb02.jpg)![image-20210819142721971](https://i0.wp.com/tvax1.sinaimg.cn/large/00496yplgy1gvnwoizkmvj604903r3yb02.jpg)  

当`nums[mid] == nums[left]`时，分不清到底是前面有序还是后面有序。此时 left++ 即可。相当于去掉一个重复的干扰项。因此，对于包含重复元素的数组，必须使用[] (左闭右闭)的搜索空间，才可以left++。

