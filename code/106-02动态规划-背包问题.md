# 背包问题



背包问题力扣题目大纲如下：

![image-20210513101228972](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210513101228972.png)

关于这⼏种常⻅的背包，其关系如下：

![image-20210513101109665](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210513101109665.png)

## 01 背包

有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。

### 回溯法

#### 二叉树单个节点是否选取的回溯方式

每⼀件物品其实只有两个状态，取或者不取，所以可以使⽤回溯法搜索出所有的情况，那么时间复杂度就是O(2^n)，这⾥的n表示物品数量。

时间复杂度太高，每层回溯中都存在冗余，不推荐。

![image-20210712152907103](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210712152907103.png)

- ```c++
  /*
  函数意义：在物品重量小于w的情形下，在数组中[0-i]下标的范围中选物品，能获得的最大收益;
  参数：alreadyWeight 不包括i下标之前的范围中选取物品的重量
  */
  public static int process1(int[] weight, int[] values, int i, int alreadyWeight, int bag) {
    if (alreadyWeight > bag) {
        return Integer.MIN_VALUE;
    }
    if (i == -1) {
        return 0;
    }
    //不取当前物品
    int num1 = process1(weight, values, i - 1, alreadyWeight, bag);
    //取当前物品
    int num2 = values[i] + process1(weight, values, i - 1, alreadyWeight + weight[i], bag)
    /*
    显示回溯
    //取当前物品
    alreadyWeight += weight[i];
    int num2 = values[i] + process1(weight, values, i - 1,alreadyWeight , bag);
    alreadyWeight -= weight[i];
    */
    return Math.max(num1,num2);
  }
  
  process1(weight,values,weight.size()-1,0,bag);
  ```

#### 二叉树集合中选取元素的回溯方式

时间复杂度O(n!)

- ```c++
  class Solution {
  private:
    int maxValue = 0;
    int maxWeight = 0;
    int curValue = 0;
    int curWeight = 0;
    vector<int> result;
    vector<int> path;
    //回溯解决在子集中递归查找子集的问题
    /*
    递归三部曲：
    1、函数意义：在idx为开始下标的集合中选择题目要求的元素，并加入集合;
    2、参数：idx起始下标
    3、返回值：void
    */
    void backtracking(vector<int> &weight, vector<int> &value, int w, int idx)
    {
        if (curValue > maxValue) {
            maxValue = curValue;
            result = path;
        }
        //单层逻辑 子集范围
        for (int i = idx; i < weight.size(); i++) {  //递归终止条件
            if (curWeight + weight[i] > w)
                continue;
            path.push_back(value[i]);
            curValue += value[i];
            curWeight += weight[i];
            backtracking(weight, value, w, idx + 1);
            path.pop_back();
            curValue -= value[i];
            curWeight -= weight[i];
        }
    }
    public:
        vector<int> package(vector<int> &weight, vector<int> &value, int w)
        {
            backtracking(weight, value, w, 0);
            return result;
        }
  };
  ```

### ⼆维dp数组

* 要点



**`dp[i][j]`表示从下标为[0-i]的物品⾥任意取，放进容量为j的背包，价值总和最⼤是多少。**

`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`

**二维dp数组先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。**



在下面的讲解中，我举一个例子：

背包最大重量为4。

物品    重量  价值
物品0	1	15
物品1	3	20
物品2	4	30
问背包能背的物品最大价值是多少？

- 动规五部曲分析⼀波。

1. 确定dp数组（dp table）以及下标的含义
   **使⽤⼆维数组，即`dp[i][j]`表示从下标为[0-i]的物品⾥任意取，放进容量为j的背包，价值总和最⼤是多少。**
   ![1619754400600](https://i0.wp.com/tvax3.sinaimg.cn/mw690/00496yplgy1gvo4ood5u1j60k70ayq4402.jpg)
    要时刻记着这个dp数组的含义，下⾯的⼀些步骤都围绕这dp数组的含义进⾏的，如果哪⾥看懵了，就来回顾⼀下i代表什么，j⼜代表什么。

2. 确定递推公式

那么可以有两个⽅向推出来`dp[i][j]`

- `由dp[i - 1][j]`推出，即背包容量为j，⾥⾯不放物品i的最⼤价值，此时`dp[i][j]`就是`dp[i - 1][j]`
- 由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]]` 为背包容量为j - weight[i]的时候不放物品i的最⼤价值，那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值），就是背包放物品i得到的最⼤价值

**`所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`**

3. dp数组如何初始化
   关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。

⾸先从`dp[i][j]`的定义触发，如果背包容量j为0的话，即`dp[i][0]`，⽆论是选取哪些物品，背包价值总和⼀定为0。

在看其他情况。状态转移⽅程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 可以看出i 是由 i-1 推导出来，那么i为0的时候就⼀定要初始化。

`dp[0][j]`，即：i为0，从编号0的物品选择物品存放的时候，各个容量的背包所能存放的最⼤价值。

```c++ 
    // 初始化
    for (int j = weight[0]; j <= bagWeight; j++) {
        dp[0][j] = value[0];
    }
```

此时dp数组初始化情况如图所示：

![image-20210705202755655](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210705202755655.png)



4. 确定遍历顺序

   **二维dp数组先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。**

   那么我先给出先遍历物品，然后遍历背包重量的代码。

```c++
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量 
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 这个是为了展现dp数组里元素的变化
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）

例如这样：

```c
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

为什么也是可以的呢？

**要理解递归的本质和递推的方向**。

`dp[i-1][j]`和`dp[i - 1][j - weight[i]]` 都在`dp[i][j]`的左上角方向（包括正左和正上两个方向）。虽然两个for循环遍历的次序不同，但是`dp[i][j]`所需要的数据就是左上角，根本不影响`dp[i][j]`公式的推导！

但先遍历物品再遍历背包这个顺序更好理解。

5. 举例推导dp数组
   来看一下对应的dp数组的数值，最终结果就是`dp[2][4]`。
   ![image-20210705203937275](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210705203937275.png)

6. 完整代码如下：

```c++
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));
    
    // 初始化
    for (int j = weight[0]; j <= bagWeight; j++) {
        dp[0][j] = value[0];
    }
    
    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    
        }
    }
    
    cout << dp[weight.size() - 1][bagWeight] << endl;
}
```

### 滚动数组

---

* 要点

**dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。**

`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`

**一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。**

---

在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`
其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);`
于其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）

动态规划五部曲：

1.确定dp数组（dp table）以及下标的含义

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

2.dp数组如何初始化

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

3.确定递推公式

```php
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

4.确定遍历顺序

**一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。**

**倒叙遍历是为了保证物品i只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次

**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），**如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。**

**所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！**，这一点大家一定要注意。

5.举例推导dp数组

来看一下对应的dp数组的数值，最终结果就是`dp[2][4]`。
![image-20210705203937275](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210705203937275.png)

6.完整代码如下：

```c++
  // 初始化
  vector<int> dp(bagWeight + 1, 0);
  for(int i = 0; i < weight.size(); i++) { // 遍历物品
      for(int j = bagWeight; j >= weight[i]; j--) { // 倒序遍历背包容量
          dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
      }
  }
```



## 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

```c++
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j < bagWeight ; j++) { // 从小到大去遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

**纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。**

因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。

```c++
// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
    cout << endl;
}
```

## 多重背包

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

```c
for (int i = 0; i < nums.size(); i++) {
    while (nums[i] > 1) {  // nums[i]保留到1，把其他物品都展开
        weight.push_back(weight[i]);
        value.push_back(value[i]);
        nums[i]--;
    }
}
for (int i = 0; i < weight.size(); i++) {           // 遍历物品
    for (int j = bagWeight; j >= weight[i]; j--) {  // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

