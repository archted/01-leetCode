## 练习题目

### 未归类

#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)



![image-20210710142923055](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210710142923055.png)

![image-20210710142941484](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210710142941484.png)

**选择从右往左扫描**

- 星号的前面肯定有一个字符，星号也只影响这一个字符，它就像一个拷贝器。

- s、p 串是否匹配，取决于：最右端是否匹配、剩余的子串是否匹配。
- 只是最右端可能是特殊符号，需要分情况讨论而已。

**情况1：s[i-1]和 p[j-1] 是匹配的**

- 最右端的字符是匹配的，那么，大问题的答案 = 剩余子串是否匹配。
  ![f817caaa40b0c39fc3ddabfa1383a8218ab364b8e49b30e5ce85cb30a3cdc503-image](https://i0.wp.com/tva4.sinaimg.cn/large/00496yplgy1gvo4puyqquj61ld0ahahn02.jpg)

**情况2：s[i-1] 和 p[j-1]是不匹配的**

* 右端不匹配，还不能判死刑——可能是 p[j-1]为星号造成的不匹配，星号不是真实字符，它不匹配不算数。
* 如果 p[j-1]p[j−1] 不是星号，那就真的不匹配了。

![fe763378879a0a52e9f17171e3bc1db18cfc83bf59f14efcd31ec9edb37adfac-image](https://i0.wp.com/tvax2.sinaimg.cn/large/00496yplgy1gvo4qieu6aj61nm09xdnm02.jpg)

**情况2.1：`p[j-1] != "*",那么dp[i][j]=false;`**

**情况2.2：p[j−1]=="∗"，且 s[i-1]和 p[j-2]匹配**

p[j−1] 是星号，并且 s[i-1] 和 p[j-2] 匹配，要考虑三种情况：
p[j-1] 星号可以让 p[j−2] 在 p 串中消失、出现 1 次、出现 >=2 次。
只要其中一种使得剩余子串能匹配，那就能匹配，见下图 a1、a2、a3。

![a1cc0caf806f7d7f5419d820e0e7be7a364c96656a98ca4d7f351661d6a62aa6-image](https://i0.wp.com/tvax1.sinaimg.cn/large/00496yplgy1gvo4r4egjfj61cp0w8kfh02.jpg)

* a3 情况：假设 s 的右端是一个 a，p 的右端是 a * ，* 让 a 重复 >= 2 次
  * 星号不是真实字符，s、p是否匹配，要看 s 去掉末尾的 a，p 去掉末尾一个 a，剩下的是否匹配。
  * 星号拷贝了 >=2 个 a，拿掉一个，剩下 >=1 个a，p 末端依旧是 a* 没变。
  * s 末尾的 a 被抵消了，继续考察 s(0,i-2) 和 p(0,i-1) 是否匹配。

**情况2.3：p[j−1]=="∗"，但 s[i-1] 和 p[j-2] 不匹配**

s[i−1] 和 p[j−2]不匹配，还有救，p[j−1] 星号可以干掉p[j−2]，继续考察 s(0,i−1) 和 p(0,j-3)。



![dabf2195c460052e2719340de8f2d22f791694d4443424478201be3b5d601fe1-image](https://i0.wp.com/tva2.sinaimg.cn/large/00496yplgy1gvo4rh0plaj61t90btk2z02.jpg)

**base case**

* p为空串，s不为空串，肯定不匹配。
* s为空串，但p不为空串，要想匹配，只可能是右端是星号，它干掉一个字符后，把 p 变为空串。
* s、p都为空串，肯定匹配。



```java
class Solution {
    public boolean isMatch(String s, String p) {
        char[] cs = s.toCharArray();
        char[] cp = p.toCharArray();

        // dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
        boolean[][] dp = new boolean[cs.length + 1][cp.length + 1];

        // 初期值
        // s为空，p为空，能匹配上
        dp[0][0] = true;
        // p为空，s不为空，必为false(boolean数组默认值为false，无需处理)

        // s为空，p不为空，由于*可以匹配0个字符，所以有可能为true
        for (int j = 1; j <= cp.length; j++) {
            if (cp[j - 1] == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }

        // 填格子
        for (int i = 1; i <= cs.length; i++) {
            for (int j = 1; j <= cp.length; j++) {
                // 文本串和模式串末位字符能匹配上
                if (cs[i - 1] == cp[j - 1] || cp[j - 1] == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (cp[j - 1] == '*') { // 模式串末位是*
                    // 模式串*的前一个字符能够跟文本串的末位匹配上
                    if (cs[i - 1] == cp[j - 2] || cp[j - 2] == '.') {
                        dp[i][j] = dp[i][j - 2] // *匹配0次的情况
                                || dp[i - 1][j - 2] // *匹配1次的情况
                                || dp[i - 1][j]; // *匹配多次的情况
                    } else { // 模式串*的前一个字符不能够跟文本串的末位匹配
                        dp[i][j] = dp[i][j - 2]; // *只能匹配0次
                    }
                }
            }
        }
        return dp[cs.length][cp.length];
    }
}

```

#### [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

![image-20210710145011068](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210710145011068.png)

现在问你，**最坏**情况下，你**至少**要扔几次鸡蛋，才能**确定**这个楼层`F`呢？

PS：F 可以为 0，比如说鸡蛋在 1 层都能摔碎，那么 F = 0。

也就是让你找摔不碎鸡蛋的最高楼层`F`，但什么叫「最坏情况」下「至少」要扔几次呢？我们举个例子就明白了。

**最好的策略**是使用二分查找思路，我先去第`(1 + 7) / 2 = 4`层扔一下：

如果碎了说明`F`小于 4，我就去第`(1 + 3) / 2 = 2`层试……

如果没碎说明`F`大于等于 4，我就去第`(5 + 7) / 2 = 6`层试……

以这种策略，**最坏情况**应该是试到第 7 层鸡蛋还没碎（`F = 7`），或者鸡蛋一直碎到第 1 层（`F = 0`）。然而无论那种最坏情况，只需要试`log7`向上取整等于 3 次，比刚才的 7 次要少，这就是所谓的**至少**要扔几次。

PS：这有点像 Big O 表示法计算算法的复杂度。





实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，**现在给你了鸡蛋个数的限制`K`，直接使用二分思路就不行了**。

有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？

很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。

如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次(每个10层试一次*9层+最后10层中尝试每一层=20)。

最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。



思路分析：

**对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。**

**「状态」很明显，就是当前拥有的鸡蛋数`K`和需要测试的楼层数`N`**。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。

**「选择」其实就是去选择哪层楼扔鸡蛋**。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。

现在明确了「状态」和「选择」，**动态规划的基本思路就形成了**：肯定是个二维的`dp`数组或者带有两个状态参数的`dp`函数来表示状态转移；**外加一个 for 循环来遍历所有选择**，择最优的选择更新结果 。

比方说你有 2 个鸡蛋，面对 10 层楼，你得拿一个鸡蛋去某一层楼扔对吧？那选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于鸡蛋碎没碎，下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。

```python
# 当前状态为 (K 个鸡蛋，N 层楼)
# 返回这个状态下的最优结果
def dp(K, N):
    int res
    for 1 <= i <= N:
        res = min(res, 这次在第 i 层楼扔鸡蛋)
    return res
```

这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。

我们在第`i`层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。**注意，这时候状态转移就来了**：

**如果鸡蛋碎了**，那么鸡蛋的个数`K`应该减一，搜索的楼层区间应该从`[1..N]`变为`[1..i-1]`共`i-1`层楼；

**如果鸡蛋没碎**，那么鸡蛋的个数`K`不变，搜索的楼层区间应该从 `[1..N]`变为`[i+1..N]`共`N-i`层楼。

![image-20210825151130969](https://i0.wp.com/tvax4.sinaimg.cn/large/00496yplgy1gvnwohfggij60ax0ik41802.jpg)

PS：细心的读者可能会问，在第`i`层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第`i`层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第`i`层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。

因为我们要求的是**最坏情况**下扔鸡蛋的次数，所以鸡蛋在第`i`层楼碎没碎，取决于那种情况的结果**更大**：

```python
def dp(K, N):
    if K == 1: return N
    if N == 0: return 0
    for 1 <= i <= N:
        # 最坏情况下的最少扔鸡蛋次数
        res = min(res, 
                  max( 
                        dp(K - 1, i - 1), # 碎
                        dp(K, N - i)      # 没碎
                     ) + 1 # 在第 i 楼扔了一次
                 )
    return res
```

递归的 base case 很容易理解：当楼层数`N`等于 0 时，显然不需要扔鸡蛋；当鸡蛋数`K`为 1 时，显然只能线性扫描所有楼层。

> 什么叫「最坏情况」下「至少」要扔几次呢？我的理解是针对状态dp(K,N),有N个不同的楼层可以选择去扔，每次做出选择后面对两种状态：鸡蛋碎了和没碎。「至少」表示结果要取最优的那个选择策略，「最坏情况」表示每次选择后一直试到第1层或第N层鸡蛋还没碎。

至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：

```python
def superEggDrop(K: int, N: int):

    memo = dict()
    def dp(K, N) -> int:
        # base case
        if K == 1: return N
        if N == 0: return 0
        # 避免重复计算
        if (K, N) in memo:
            return memo[(K, N)]

        res = float('INF')
        # 穷举所有可能的选择
        for i in range(1, N + 1):
            res = min(res, 
                      max(
                            dp(K, N - i), 
                            dp(K - 1, i - 1)
                         ) + 1
                  )
        # 记入备忘录
        memo[(K, N)] = res
        return res

    return dp(K, N)
```

**动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度**。

函数本身的复杂度:`dp`函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。

子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。

所以算法的总时间复杂度是 $O(K*N^2)$, 空间复杂度为子问题个数，即 O(KN)。



其实，这个问题还有更好的解法，因为状态转移方程的函数图像具有单调性，因此，修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 $O(K*N*logN)$；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 $O(K*logN)$，空间复杂度达到 O(1)。

* 二分法优化

状态转移方程：$$dp[i][j] = \min_{1 \le k \le i} \left(\max(dp[k - 1][j - 1], dp[i - k][j]) + 1 \right)$$

首先我们根据`dp(K, N)`数组的定义（有`K`个鸡蛋面对`N`层楼，最少需要扔 dp(K, N) 次），**很容易知道`K`固定时，这个函数随着`N`的增加一定是单调递增的**。那么注意`dp(K - 1, i - 1)`和`dp(K, N - i)`这两个函数，如果我们固定`K`和`N`，**把这两个函数看做关于`i`的函数，前者随着`i`的增加应该也是单调递增的，而后者随着`i`的增加应该是单调递减的**：

![image-20210825163224383](https://i0.wp.com/tvax4.sinaimg.cn/large/00496yplgy1gvnwogxb71j60f708wtaa02.jpg)

这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。

回顾这两个`dp`函数的曲线，我们要找的最低点其实就是这种情况：

```python
for (int i = 1; i <= N; i++) {
    if (dp(K - 1, i - 1) == dp(K, N - i))
        return dp(K, N - i);
}
```

这不就是相当于求 Valley（山谷）值嘛，因此，可以用二分查找来快速寻找这个点

二分法的代码为：

```python
def superEggDrop(self, K: int, N: int) -> int:

    memo = dict()
    def dp(K, N):
        if K == 1: return N
        if N == 0: return 0
        if (K, N) in memo:
            return memo[(K, N)]

        # for 1 <= i <= N:
        #     res = min(res, 
        #             max( 
        #                 dp(K - 1, i - 1), 
        #                 dp(K, N - i)      
        #                 ) + 1 
        #             )

        res = float('INF')
        # 用二分搜索代替线性搜索
        lo, hi = 1, N
        while lo <= hi: #[lo,hi]
            mid = (lo + hi) // 2
            broken = dp(K - 1, mid - 1) # 碎
            not_broken = dp(K, N - mid) # 没碎
            # res = min(max(碎，没碎) + 1)
            if broken > not_broken:
                hi = mid - 1
                res = min(res, broken + 1)
            else:
                lo = mid + 1
                res = min(res, not_broken + 1)

        memo[(K, N)] = res
        return res

    return dp(K, N)
```

**动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度**。

函数本身的复杂度是 O(logN),子问题个数也就是不同状态组合的总数，复杂度为O(KN),所以算法的总时间复杂度是$ O(K*N*logN)$, 空间复杂度 O(KN)。



方法二、使用动态规划思维:dp

第 1 步：定义状态

`dp[i][j]`：一共**有 `i` 层楼梯**（注意：这里 `i` 不表示高度）的情况下，使用 `j` 个鸡蛋的最少实验的次数。

说明：

1. `i` 表示的是楼层的大小，**不是高度（第几层）的意思**，例如楼层区间 `[8, 9, 10]` 的大小为 33。

2. `j` 表示可以使用的鸡蛋的个数，它是约束条件。这里的约束只有鸡蛋的个数，因此，为了消除鸡蛋的个数对递推的过程中造成的影响，我们在设置状态的时候要在后面加上一个维度，这种做法叫消除「后效性」，是常见的套路。在「打家劫舍」问题一、问题三还有「股票」的 6 道问题用的就是这个技巧。一般而言，一个约束对应一个维度的状态。约束越多，状态的维数就越多

   

第 2 步：推导状态转移方程

推导状态转移方程经常做的事情是「分类讨论」，这里「分类讨论」的依据就是，在指定的层数里扔下鸡蛋，根据这个鸡蛋是否破碎，就把问题拆分成了两个子问题。

设指定的楼层为 k，k >= 1 且 k <= i：

* 如果鸡蛋破碎，测试 `F` 值的实验就得在 `k` 层以下做（不包括 k 层），这里已经使用了一个鸡蛋，因此测出 `F` 值的最少实验次数是：`dp[k - 1][j - 1]`；
* 如果鸡蛋完好，测试 `F` 值的实验就得在 `k` 层以上做（不包括 k 层），这里这个鸡蛋还能使用，因此测出 `F` 值的最少实验次数是：`dp[i - k][j]`

**最坏情况下，是这两个子问题的较大者**，由于在第 k 层扔下鸡蛋算作一次实验，k 的值在 1≤k≤i，对于每一个 k 都对应了一组值的最大值，**取这些 k 下的最小值（最优子结构）**，因此：

$$dp[i][j] = \min_{1 \le k \le i} \left(\max(dp[k - 1][j - 1], dp[i - k][j]) + 1 \right)$$


每一个新值的计算，都参考了比它行数少，列数少的值，这些值一定是之前已经计算出来的，这样的过程就叫做「状态转移」。

第 3 步：考虑初始化

见代码

第 4 步：考虑输出

输出就是表格的最后一个单元格的值 `dp[N][K]`。

第 5 步：举例递推



```java
import java.util.Arrays;

public class Solution {

    public int superEggDrop(int K, int N) {

        // dp[i][j]：一共有 i 层楼梯的情况下，使用 j 个鸡蛋的最少实验的次数
        // 注意：
        // 1、i 表示的是楼层的大小，不是第几层的意思，例如楼层区间 [8, 9, 10] 的大小为 3，这一点是在状态转移的过程中调整的定义
        // 2、j 表示可以使用的鸡蛋的个数，它是约束条件，我个人习惯放在后面的维度，表示消除后效性的意思
        //无后效性问题：怎么到达的子状态不影响子状态的返回值。

        // 0 个楼层和 0 个鸡蛋的情况都需要算上去，虽然没有实际的意义，但是作为递推的起点，被其它状态值所参考
        int[][] dp = new int[N + 1][K + 1];

        // 由于求的是最小值，因此初始化的时候赋值为一个较大的数，9999 或者 i 都可以
        for (int i = 0; i <= N; i++) {
            Arrays.fill(dp[i], i);
        }

        // 初始化：填写下标为 0、1 的行和下标为 0、1 的列
        // 第 0 行：楼层为 0 的时候，不管鸡蛋个数多少，F值都为0
        for (int j = 0; j <= K; j++) {
            dp[0][j] = 0;
        }

        // 第 1 行：楼层为 1 的时候，0 个鸡蛋的时候，扔 0 次，1 个以及 1 个鸡蛋以上只需要扔 1 次
        dp[1][0] = 0;
        for (int j = 1; j <= K; j++) {
            dp[1][j] = 1;
        }

        // 第 0 列：鸡蛋个数为 0 的时候，不管楼层为多少，也测试不出鸡蛋的 F 值，故全为 0
        // 第 1 列：鸡蛋个数为 1 的时候，这是一种极端情况，要试出 F 值，最少次数就等于楼层高度（想想复杂度的定义）
        for (int i = 0; i <= N; i++) {
            dp[i][0] = 0;
            dp[i][1] = i;
        }

        // 从第 2 行，第 2 列开始填表
        for (int i = 2; i <= N; i++) {
            for (int j = 2; j <= K; j++) {
                for (int k = 1; k <= i; k++) {
                    // 碎了，就需要往低层继续扔：层数少 1 ，鸡蛋也少 1
                    // 不碎，就需要往高层继续扔：层数是当前层到最高层的距离差，鸡蛋数量不少
                    // 两种情况都做了一次尝试，所以加 1
                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k - 1][j - 1], dp[i - k][j]) + 1);
                }
            }
        }
        return dp[N][K];
    }
}

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/super-egg-drop/solution/dong-tai-gui-hua-zhi-jie-shi-guan-fang-ti-jie-fang/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

* 使用二分法进行优化

  

```java
import java.util.Arrays;

public class Solution {

    public int superEggDrop(int K, int N) {
        // dp[i][j]：一共有 i 层楼梯的情况下，使用 j 个鸡蛋的最少仍的次数
        int[][] dp = new int[N + 1][K + 1];
        
        // 初始化
        for (int i = 0; i <= N; i++) {
            Arrays.fill(dp[i], i);
        }
        for (int j = 0; j <= K; j++) {
            dp[0][j] = 0;
        }

        dp[1][0] = 0;
        for (int j = 1; j <= K; j++) {
            dp[1][j] = 1;
        }
        for (int i = 0; i <= N; i++) {
            dp[i][0] = 0;
            dp[i][1] = i;
        }

        // 开始递推
        for (int i = 2; i <= N; i++) {
            for (int j = 2; j <= K; j++) {
                // 在区间 [1, i] 里确定一个最优值
                int left = 1;
                int right = i;
                while (left <= right) {
                    // 找 dp[k - 1][j - 1] <= dp[i - mid][j] 的最大值 k
                    int mid = left + (right - left) / 2;
                    
                    int breakCount = dp[mid - 1][j - 1];
                    int notBreakCount = dp[i - mid][j];
                    if (breakCount > notBreakCount) {
                        // 排除法（减治思想）写对二分见第 35 题，先想什么时候不是解
                        // 严格大于的时候一定不是解，此时 mid 一定不是解
                        // 下一轮搜索区间是 [left, mid - 1]
                        right = mid - 1;
                    } else {
                        // 这个区间一定是上一个区间的反面，即 [mid, right]
                        left = mid + 1;
                    }
                }
                // left 这个下标就是最优的 k 值，把它代入转移方程 Math.max(dp[k - 1][j - 1], dp[i - k][j]) + 1) 即可
                dp[i][j] = Math.max(dp[left - 1][j - 1], dp[i - left][j]) + 1;
            }
        }
        return dp[N][K];
    }
}

```

- 时间复杂度：O(NK log N)，其中一层循环变成二分查找，复杂度成为对数；
- 空间复杂度：O(NK)，表格的大小。









只看了第一个链接，还没看懂

https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/hard/887.super-egg-drop

https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-4/gao-lou-reng-ji-dan-wen-ti

https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-4/gao-lou-reng-ji-dan-jin-jie

假如有 2 个鸡蛋，6 层楼。 我们应该先从哪层楼开始扔呢？想了一会，没有什么好的办法。我们来考虑使用暴力的手段。



![007S8ZIlly1gfk793ken5j30zi0fidhu](https://i0.wp.com/tva4.sinaimg.cn/large/00496yplgy1gvo4ruaek7j60zi0fidgk02.jpg)

（图 1. 这种思路是不对的)

既然我不知道先从哪层楼开始扔是最优的，那我就依次模拟从第 1，第 2。。。第 6 层扔。每一层楼丢鸡蛋，都有两种可能，碎或者不碎。由于是最坏的情况，因此我们需要模拟两种情况，并取两种情况中的扔次数的较大值（较大值就是最坏情况）。 然后我们从六种扔法中选择最少次数的即可。

![007S8ZIlly1gfk7a7q9h5j32bo0jutfj](https://i0.wp.com/tvax2.sinaimg.cn/large/00496yplgy1gvo4s60d7lj62bo0jutbs02.jpg)

（图 2. 应该是这样的）

因为我们要求的是**最坏情况**下扔鸡蛋的次数，所以鸡蛋在第 `i` 层楼碎没碎，取决于那种情况的结果**更大**：

```jav
class Solution {
    public int superEggDrop(int k, int n) {

    }
}
```

#### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

![image-20210710162017718](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210710162017718.png)



假设这个区间是个开区间，最左边索引 `i`，最右边索引 `j`

DP思路是这样的，就先别管前面是怎么戳的，你只要管这个区间最后一个被戳破的是哪个气球
这最后一个被戳爆的气球就是 `k`

你在 (i,j) 开区间得到的金币可以由 dp[i][k] 和 dp[k][j] 进行转移
 
如果你此刻选择戳爆气球 k，那么你得到的金币数量就是：
 

```php
total
=
dp[i][k]
+
val[i] * val[k] * val[j]
+
dp[k][j]
```


注：val[i] 表示 i 位置气球的数字
然后 (i,k) 和 (k,j) 也都是开区间

作者：xiao-yan-gou
链接：https://leetcode-cn.com/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

https://leetcode-cn.com/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/

```java
public int maxCoins(int[] nums) {
        int length = nums.length;
        int newLength = length + 2;
        // 数组首尾加1，方便计算
        int[] newArry = new int[newLength];
        newArry[0] = 1;
        newArry[length + 1] = 1;
        // 放入新数组中
        for (int i = 0; i < length; i++) {
            newArry[i + 1] = nums[i];
        }
        // 定义dp数组，dp[i][j] 表示区间(i,j)范围内可以获得的最大金币
        // 假设最后一个被戳爆的是第k个气球，那么，dp[i][j] = dp[i][k] + newArray[i]*newArray[k]*newArray[k] + dp[k][j]
        // 也就是说和他两边区间被戳吧气球获得的最大金币有关
        int[][] dp = new int[newLength][newLength];

        // (i,j)区间的范围从3开始，慢慢递增一直到最大(就是newArray的大小)，范围是[3,newLength]，闭区间
        for (int range = 3; range <= newLength; range++) {
            // 区间从左往右移动，进行初始化，也就i移动的范围是[0,newLength - range]，这是闭区间
            for (int i = 0; i <= newLength - range; i++) {
                // 知道i和rang可以确定j
                int j = i + range - 1;
                // 找出(i,j)这个区间内的最大值，就是依次试着去戳破，然后记录最大值
                int maxValue = 0;
                // 在(i,j)区间内尝试依次去戳破气球，并记录每次获得的金币
                for (int k = i + 1; k < j; k++) {
                    // 区间(i,k)区间内戳气球能获得的最大金币
                    int leftRangeValu = dp[i][k];
                    // 区间(k,j)区间内戳气球能获得的最大金币
                    int rightRangeValue = dp[k][j];
                    maxValue = Math.max(maxValue, leftRangeValu + newArry[i] * newArry[k] * newArry[j] + rightRangeValue);
                }
                // 将最大值保存到dp数组中
                dp[i][j] = maxValue;
            }
        }
        return dp[0][length + 1];
    }
```





### 最长公共子序列LCS

#### [712. 两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

![image-20210708162053317](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210708162053317.png)



**解法一、LCS题目扩展**

LCS题目是查找最长公共子序列长度，其`dp[i][j]`定义为：**长度为[0, i - 1]的字符串text1**与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`

本题将`dp[i][j]`定义为查找`s1[0,i-1]`子串和`s2[0,j-1]`ASCII码累加值最大的最长公共子序列，最后需要删掉的元素自然就是ASCII值累加和最小的。

直接给出代码：

```java
class Solution {
public:
    int minimumDeleteSum(string text1, string text2)
    {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + text1[i - 1];
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        int sum1 = 0;
        int sum2 = 0;
        for (auto ch : text1) {
            sum1 += ch;
        }
        for (auto ch : text2) {
            sum2 += ch;
        }
        int common = dp[text1.size()][text2.size()];
        return sum1 + sum2 - 2 * common;
    }
};
```

**解法二、根据题意定义dp**

1.dp定义

将`dp[i][j]`定义为查找`s1[0,i-1]`子串和`s2[0,j-1]`子串相等需要删除的ASCII值的最小和。

2.确定递推公式

如果有 `s1[i] == s2[j]`，那么当前位置的两个字符相同，它们不需要被删除，`dp[i][j] = dp[i - 1][j  - 1]`

如果 `s1[i] != s2[j]`，那么我们至少要删除 s1[i] 和 s2[j] 两个字符中的一个，因此状态转移方程为

`dp[i][j] = min(dp[i  - 1][j] + s1[i-1], dp[i][j - 1] + s2[j-1])`

3.初始化

`dp[0][0]`表示s1空串和s2空串相等需要删除的ASCII值的最小和，`dp[0][0] = 0`

`dp[0][j]`表示s1空串和`s2[0,j-1]`子串相等需要删除的ASCII值的最小和，因此：

```c
for(int j=1;j<=s2.length();j++){
    dp[0][j] = dp[0][j-1] + s2.charAt(j-1);
}
```

同理，对`dp[i][0]`存在

```c
for(int i = 1;i<s2.length();i++){
    dp[i][0] = dp[i-1][0] + s1.charAt(i-1);
 }
```

4.确定遍历顺序

双for循环，从左到右，从上到下

5.验证

6.代码如下：

```java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        // 将`dp[i][j]`定义为查找`s1[0,i-1]`子串和`s2[0,j-1]`子串相等需要删除的ASCII值的最小和。
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        for (int j = 1; j < s2.length() + 1; j++) {
            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);
        }
        for (int i = 1; i < s1.length() + 1; i++) {
            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);
        }
        for (int i = 1; i < s1.length() + 1; i++) {
            for (int j = 1; j < s2.length() + 1; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));
                }
            }
        }
        return dp[s1.length()][s2.length()];
    }
}
```



#### [354.俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes)

![image-20210525113114190](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210525113114190.png)

* LCS变形题目：二维递增子序列

**先对宽度 `w` 进行升序排序，如果遇到 `w` 相同的情况，则按照高度 `h` 降序排序。因为两个宽度相同的信封不能相互包含的，逆序排序保证在 `w` 相同的数对中最多只选取一个。之后把所有的 `h` 作为一个数组，在这个数组上计算 LIS 的长度就是答案。**

```c
// envelopes = [[w, h], [w, h]...]
public int maxEnvelopes(int[][] envelopes) {
    int n = envelopes.length;
    // 按宽度升序排列，如果宽度一样，则按高度降序排列
    Arrays.sort(envelopes, new Comparator<int[]>() 
    {
        @Override
        public int compare(int[] a, int[] b) {
            return a[0] == b[0] ? 
                b[1] - a[1] : a[0] - b[0];
        }
    });
    // 对高度数组寻找 LIS
    int[] height = new int[n];
    for (int i = 0; i < n; i++)
        height[i] = envelopes[i][1];

    return lengthOfLIS(height);
}

    int lengthOfLIS(vector<int> &nums)
    {
        if (nums.size() <= 1)
            return nums.size();
        vector<int> dp(nums.size(), 1); //int[] dp = new int[nums.length];  Arrays.fill(dp, 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result)
                result = dp[i];  // 取长的子序列
        }
        return result;
    }
```







### 博弈问题

#### [486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)

![image-20210716154622629](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210716154622629.png)

方法一、递归

以 [1, 5, 233, 7] 为例，玩家 1 先手。
如果他选左端的 1，则玩家 2 在剩下的[5, 233, 7]的两端中选。
如果他选右端的 7，则玩家 2 在剩下的[1, 5, 233]的两端中选。
想到递归了吗？画个图看看，我用数组索引来描述一个子问题：



![image-20210712090846982](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210712090846982.png)

每个节点都是一个玩家在选择，下一个节点变成对手在选择，交替选。

开始时你选了 xx，得 xx 分，他没选，得 00 分，你赢了他 xx 分，接下来他选，你选，你们交替地选……请勿绕入递归的细节。

起初你有 xx 分，对手 00 分，在后面的游戏中，对手拢共赢你 yy 分，如果 x >= yx>=y，那你赢了。

屏蔽掉递归的细节，那是丢给子调用去做的。关注当前的 xx 分，子调用应该返回什么去和它比较，才能判断获胜。就不难想到：在剩余轮次中对手胜过自己的分数，它大于0，相当于对手在剩余轮次中获胜，比起整个游戏，是规模小一点的同一问题。

于是**递归函数定义：返回当前做选择的玩家，基于当前区间[i,j]，赢过对手的分数。**

怎么计算呢？

**当前选择的分数，减去，往后对手赢过自己的分数（对剩余数组递归）。**因为有两端可选择，所以差值有两个，取较大的判断是否大于等于0。

```js
const PredictTheWinner = (nums) => {
  // helper：基于从i到j的数组，当前选择的玩家所能赢对方的分数
  const helper = (i, j) => { // i，j是两端的索引
    if (i == j) {   // 此时只有一种选择，选的人赢对方nums[i]，且没有剩余可选，结束递归
      return nums[i];
    }
    const pickI = nums[i] - helper(i + 1, j); // 选择左端，获得nums[i]，之后输掉helper(i+1,j)分
    const pickJ = nums[j] - helper(i, j - 1); // 选择右端，获得nums[j]，之后输掉helper(i,j-1)分
    return Math.max(pickI, pickJ);            // 返回较大者，即在[i,j]数组游戏中胜过对方的分数
  };

  return helper(0, nums.length - 1) >= 0; // 基于整个数组玩这个游戏，玩家1先手，>=0就获胜
};
```

* 进阶：记忆化递归

```js
const PredictTheWinner = (nums) => {
  const len = nums.length;
  const memo = new Array(len);
  for (let i = 0; i < memo.length; i++) {
    memo[i] = new Array(len);
  }

  const helper = (i, j) => {
    if (i == j) {                   // base case
      return nums[i];
    }
    if (memo[i][j] !== undefined) { // 如果memo中有缓存值，就直接返回它
      return memo[i][j]; 
    }
    const pickI = nums[i] - helper(i + 1, j);
    const pickJ = nums[j] - helper(i, j - 1);
    memo[i][j] = Math.max(pickI, pickJ); // 计算结果存入memo
    return memo[i][j];
  };

  return helper(0, len - 1) >= 0;
};
```

方法二、动态规划

将递归改为动态规划即可。

比照递归函数的定义，`dp[i][j]`: 当前玩家在数组[i:j]中先手，所赢过对方的分数。

比照递归的终止条件，有 base case：当`i == j`时，`dp[i][j] = nums[i]`。

有状态转移方程：`dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])`

```js
const PredictTheWinner = (nums) => {
  const len = nums.length;
  const dp = new Array(len);  // initialize dp array
  for (let i = 0; i < len; i++) {
    dp[i] = new Array(len);
  }
  for (let i = 0; i < len; i++) {  // base case 
    dp[i][i] = nums[i];
  }
  // iteration
  for (let i = len - 2; i >= 0; i--) { 
    for (let j = i + 1; j < len; j++) {
      const pickI = nums[i] - dp[i + 1][j];
      const pickJ = nums[j] - dp[i][j - 1];
      dp[i][j] = Math.max(pickI, pickJ);
    }
  }
  return dp[0][len - 1] >= 0;
};

```

#### 

#### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

![image-20210716154954406](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210716154954406.png)



定义 dp 数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。

和[486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)相比，[877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)增加了两个限制条件：

- 数组的长度是偶数；
- 数组的元素之和是奇数，所以没有平局。

方法一、动态规划

和[486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)相比，因为本题没有平局，所以唯一的不同之处就是返回值不同，本题返回值为`dp[0][len - 1] > 0`,而不是`dp[0][len - 1] >= 0`

```js
const PredictTheWinner = (nums) => {
  const len = nums.length;
  const dp = new Array(len);  // initialize dp array
  for (let i = 0; i < len; i++) {
    dp[i] = new Array(len);
  }
  for (let i = 0; i < len; i++) {  // base case 
    dp[i][i] = nums[i];
  }
  // iteration
  for (let i = len - 2; i >= 0; i--) { 
    for (let j = i + 1; j < len; j++) {
      const pickI = nums[i] - dp[i + 1][j];
      const pickJ = nums[j] - dp[i][j - 1];
      dp[i][j] = Math.max(pickI, pickJ);
    }
  }
  return dp[0][len - 1] > 0;
}
```

方法二、数学方法

注意，石头的堆的数量为偶数，所以你们两人拿走的堆数一定是相同的。石头的总数为奇数，也就是你们最后不可能拥有相同多的石头，一定有胜负之分。

这道题又涉及到两人的博弈，也可以用动态规划算法暴力试，比较麻烦。但我们只要对规则深入思考，就会大惊失色：只要你足够聪明，你是必胜无疑的，因为你是先手。

```c
class Solution {
    public boolean stoneGame(int[] piles) {
        return true;
    }
}
```

这是为什么呢，因为题目有两个条件很重要：一是石头总共有偶数堆，石头的总数是奇数。这两个看似增加游戏公平性的条件，反而使该游戏成为了一个割韭菜游戏。我们以 `piles=[2, 1, 9, 5]` 讲解，假设这四堆石头从左到右的索引分别是 1，2，3，4。

如果我们把这四堆石头按索引的奇偶分为两组，即第 1、3 堆和第 2、4 堆，那么这两组石头的数量一定不同，也就是说一堆多一堆少。因为石头的总数是奇数，不能被平分。

而作为第一个拿石头的人，你可以控制自己拿到所有偶数堆，或者所有的奇数堆。

你最开始可以选择第 1 堆或第 4 堆。如果你想要偶数堆，你就拿第 4 堆，这样留给对手的选择只有第 1、3 堆，他不管怎么拿，第 2 堆又会暴露出来，你就可以拿。同理，如果你想拿奇数堆，你就拿第 1 堆，留给对手的只有第 2、4 堆，他不管怎么拿，第 3 堆又给你暴露出来了。

也就是说，你可以在第一步就观察好，奇数堆的石头总数多，还是偶数堆的石头总数多，然后步步为营，就一切尽在掌控之中了。知道了这个漏洞，可以整一整不知情的同学了。

#### [292.Nim游戏（简单）](https://leetcode-cn.com/problems/nim-game)

游戏规则是这样的：你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜。

假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个正整数 n，返回你是否能赢（true 或 false）。

比如现在有 4 颗石子，算法应该返回 false。因为无论你拿 1 颗 2 颗还是 3 颗，对方都能一次性拿完，拿走最后一颗石子，所以你一定会输。

---

方法一、数学方法

首先，这道题肯定可以使用动态规划，因为显然原问题存在子问题，且子问题存在重复。但是因为你们都很聪明，涉及到你和对手的博弈，动态规划会比较复杂。

**我们解决这种问题的思路一般都是反着思考**:

如果我能赢，那么最后轮到我取石子的时候必须要剩下 1~3 颗石子，这样我才能一把拿完。

如何营造这样的一个局面呢？显然，如果对手拿的时候只剩 4 颗石子，那么无论他怎么拿，总会剩下 1~3 颗石子，我就能赢。

如何逼迫对手面对 4 颗石子呢？要想办法，让我选择的时候还有 5~7 颗石子，这样的话我就有把握让对方不得不面对 4 颗石子。

如何营造 5~7 颗石子的局面呢？让对手面对 8 颗石子，无论他怎么拿，都会给我剩下 5~7 颗，我就能赢。

这样一直循环下去，我们发现只要踩到 4 的倍数，就落入了圈套，永远逃不出 4 的倍数，而且一定会输。所以这道题的解法非常简单：

```c
bool canWinNim(int n) {
    // 如果上来就踩到 4 的倍数，那就认输吧
    // 否则，可以把对方控制在 4 的倍数，必胜
    return n % 4 != 0;
}
```

方法二、动态规划

但现在有n个石头，如何判断先手是必胜还是必败？其实画个图很容易分析：

当前先手对应n个石头，后手就对应n-1、n-2、n-3三种集合的石头

每个集合一定都会对应必胜或者必败

因此可以得到这样一个递推关系：

只有当n-1、n-2、n-3三种集合都必胜时，n对应的集合才必败。因为不管n走哪条路，都一定对应着后手必胜，也就是对应着先手必败。

而但凡后手对应的n-1、n-2、n-3三种集合有一种对应的是必败，先手都一定是必胜。因为玩家是绝对聪明的，一定会走让后手必败的路线。

因此可以得到状态转移方程：

```c
f(n) = !(f(n-1) && f(n-2) && f(n-3))
```

写出下面代码

```c
class Solution {
public:
    bool canWinNim(int n) {
        vector<bool> dp(n, true);
        for(int i = 4; i <= n; ++i) {
            dp[i-1] = !(dp[i-2] && dp[i-3] && dp[i-4]);
        }
        return dp[n-1];
    }
};
```

遇到大n时间太长，还是过不了。
观察了以下dp数组里的值的变化规律，发现只要n不是4的倍数，就是true，反之false。原来就是一行代码的事：

```c
class Solution {
public:
    bool canWinNim(int n) {
        return n%4 != 0;
    }
};
```

腾讯⾯试题：⼀共 100 只⼸箭 你和你的对⼿共⽤。你们每次只能射出⼀⽀箭或者两⽀箭，射击交替进⾏，设计⼀个算法，保证⾃⼰射出最后一支箭。

**原则：将对手控制在3的倍数，必胜**

答案： 先⼿，剩下的是 3 的倍数就⾏（100-1=99），然后按照 3 的倍数射箭必赢。 ⽐如你先拿了 1，剩下 99 个。 对⼿拿了 1，你就拿 2。这样持续 33 次就赢了。如果对⼿拿了 2 个，你就拿 1 个，这样持续 33 次你也是赢的。

```c
dp[1] = true;
dp[2] = true;
dp[3] = !(dp[1] && dp[2]) =  false;
```

## 高频

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定⼀个整数数组nums ，找到⼀个具有最⼤和的连续⼦数组（⼦数组**最少包含⼀个元素**），返回其最⼤和。输⼊: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6



解法：动态规划

dp[i]表示以索引 i 结尾的情况下的最大子序列和

则`dp[i] = Math.max(dp[i-1]+ nums[i], nums[i]) ;`

初始化：`dp[i] = nums[0];`

代码：

```c
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int ret = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1]+ nums[i], nums[i]);
            ret = Math.max(ret, dp[i]);
        }
        return ret;
    }
}
```

- 时间复杂度：O(n)

可以看到`dp[i]`只依赖前一个值`dp[i-1]`，因此可以进行状态压缩，得到空间复杂度为O(1)的滚动数组解法。

```c
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int ret = nums[0];
        for (int i = 0; i < nums.length; i++) {
            pre = Math.max(pre+ nums[i], nums[i]);
            ret = Math.max(ret, pre);
        }
        return ret;
    }
}
```

