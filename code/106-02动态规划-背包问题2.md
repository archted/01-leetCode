

# 应用

## 能否装满背包 ->(or最多装多少/最大价值)(即01背包)

**dp[j]表示 背包总容量是j，总和最大为dp[i]**。

`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`

#### 474.一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4

解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。



* 01背包的二维背包

**本题中strs 数组里的元素就是物品，每个物品都是一个！而m 和 n相当于是一个背包，两个维度的背包**。

`dp[i][j]`：最多有i个0和j个1的strs的最大子集的大小为`dp[i][j]`。

递推公式：`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)`;

对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。

**这就是一个典型的01背包！** 只不过物品的重量有了两个维度而已。

```c++
  int findMaxForm(vector<string>& strs, int m, int n) {
      vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
      for (string str : strs) { // 遍历物品
          int oneNum = 0, zeroNum = 0;
          for (char c : str) {
              if (c == '0') zeroNum++;
              else oneNum++;
          }
          for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
              for (int j = n; j >= oneNum; j--) {
                  dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
              }
          }
      }
      return dp[m][n];
  }
```

  



#### 416. 分割等和子集

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意: 每个数组中的元素不会超过 100 ,数组的大小不会超过 200
示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].  

示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.

---



解法一、回溯法：组合问题：n个数中求和为target的集合，时间复杂度较高。

解法二、01背包。那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。

**dp[j]表示 背包总容量是j，子集总和最大为dp[i]**。

01背包相对于本题，主要要理解，题目中物品是nums[i]，重量是nums[i]i，价值也是nums[i]，背包体积是sum/2。

最后判断dp[target]==target，说明集合中的元素正好可以凑成总和target。

```c
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;

        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int> dp(10001, 0);
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        if (sum % 2 == 1) return false;
        int target = sum / 2;

        // 开始 01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        // 集合中的元素正好可以凑成总和target
        if (dp[target] == target) return true;
        return false;
    }
};
```

* 相似题目

  * 698.划分为k个相等的子集

    给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

    思路：

    ```java
    for(int i=1;i<=k;i++){
        if(dp[sum/k*i] != sum/k*i) return false;
    }
    ```

    

  * 473.火柴拼正方形

#### 1049. 最后一块石头的重量 II

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

---

本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了**。**dp[j]表示容量为j的背包，最多可以背dp[j]这么重的石头**。

最后dp[target]里是容量为target的背包所能背的最大重量。那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。**在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的**。

那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。

```c
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001, 0);
        int sum = 0;
        for (int i = 0; i < stones.size(); i++) sum += stones[i];
        int target = sum / 2;
        for (int i = 0; i < stones.size(); i++) { // 遍历物品
            for (int j = target; j >= stones[i]; j--) { // 遍历背包
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};


```



本题其实和416. 分割等和子集几乎是一样的，只是最后对dp[target]的处理方式不同。

416. 分割等和子集相当于是求背包是否正好装满，而本题是求背包最多能装多少。



## 背包组合/排列问题

**dp[j] 表示：填满容量为j的包，有dp[j]种方法.**

`dp[j] += dp[j - nums[i]]`

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。（可以保证物品5在物品1之后出现）

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。（结果会出现{1,5}和{5,1}）

### 背包组合问题

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)



给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
  示例：
  输入：nums: [1, 1, 1, 1, 1], S: 3 输出：5 解释：
  -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3
  一共有5种方法让最终目标和为3。

---

* 01背包组合问题

**既然为target，那么就一定有 left组合 - right组合 = target。**left + right等于sum, left = (target + sum)/2 。问题转换为在集合中找和为 (target + sum)/2的组合。

<font color=red>**回溯：组合问题：n个数中求和为target的集合。如果仅仅是求个数的话，就可以用dp，但[回溯算法：39. 组合总和](https://mp.weixin.qq.com/s/FLg8G6EjVcxBjwCbzpACPw)要求的是把所有组合列出来，还是要使用回溯法爆搜的。**<font>

**此时问题就转化为，装满容量为x背包，有几种方法**。

1. 确定dp数组以及下标的含义

**dp[j] 表示：填满容量为j的包，有dp[j]种方法.**

2. 确定递推公式

有哪些来源可以推出dp[j]呢？

不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。

那么凑成dp[j]（考虑nums[i]的组合总和）就有dp[j - nums[i]] （不考虑nums[i]的组合总和）种方法。

那么需要把 这些方法累加起来就可以了，dp[j] += dp[j - nums[i]]

`dp[j] += dp[j - nums[i]]`**这个公式在后面在讲解背包解决排列组合问题的时候还会用到！**

3. dp数组如何初始化

从递归公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。

4. 确定遍历顺序

对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。

5. 举例推导dp数组

```c++
  class Solution {
  public:
      int findTargetSumWays(vector<int>& nums, int S) {
          int sum = 0;
          for (int i = 0; i < nums.size(); i++) sum += nums[i];
          if (S > sum) return 0; // 此时没有方案
          if ((S + sum) % 2 == 1) return 0; // 此时没有方案
          int bagSize = (S + sum) / 2;
          vector<int> dp(bagSize + 1, 0);
          dp[0] = 1;
          for (int i = 0; i < nums.size(); i++) {
              for (int j = bagSize; j >= nums[i]; j--) {
                  dp[j] += dp[j - nums[i]];
              }
          }
          return dp[bagSize];
      }
  };
```

**方法二、回溯**

回溯算法可以解决这个问题，时间复杂度为 `O(2^N)`，`N` 为 `nums` 的大小。这个复杂度怎么算的？回忆前文 [学习数据结构和算法的框架思维]()，发现这个回溯算法就是个二叉树的遍历问题：

```c
void backtrack(int[] nums, int i, int rest) {
    if (i == nums.length) {
        return;
    }
    backtrack(nums, i + 1, rest - nums[i]);
    backtrack(nums, i + 1, rest + nums[i]);
}
```

**树的高度就是 `nums` 的长度嘛**，所以说时间复杂度就是这棵二叉树的节点数，为 `O(2^N)`，其实是非常低效的。

#### 518. 零钱兑换 II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

示例 1:

输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1

示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。

示例 3: 输入: amount = 10, coins = [10] 输出: 1  

---



- 完全背包的组合问题：先遍历物品再遍历背包

dp[j]：凑成总金额j的货币组合数为dp[j], dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。

所以递推公式：dp[j] += dp[j - coins[i]];

首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。**从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。**

```c
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况，因为nums遍历放在外层，5只能出现在1后面！

**所以这种遍历顺序中dp[j]里计算的是组合数！**

如果把两个for交换顺序，代码如下：

```c
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。

**此时dp[j]里算出来的就是排列数！**

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
