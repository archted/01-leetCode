### 背包排列问题

#### 377. 组合总和 Ⅳ



给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:

nums = [1, 2, 3] target = 4

所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。

---

- 完全背包的排列问题:先遍历背包再遍历物品
- **dp[i]: 凑成目标正整数为i的排列个数为dp[i]**

```c
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; i++) { // 遍历背包
            for (int j = 0; j < nums.size(); j++) { // 遍历物品
                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
```

C++测试用例有超过两个树相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。

#### 70. 爬楼梯进阶版

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶
2. 2 阶

**一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？**

- 完全背包的排列问题

```c
  class Solution {
  public:
      int climbStairs(int n) {
          vector<int> dp(n + 1, 0);
          dp[0] = 1;
          for (int i = 1; i <= n; i++) { // 遍历背包
              for (int j = 1; j <= m; j++) { // 遍历物品
                  if (i - j >= 0) dp[i] += dp[i - j];
              }
          }
          return dp[n];
      }
  };
```

m=2时就可以AC[ 70.爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

## 装满背包所需的最少物品个数

**dp[j]：凑足重量总和为j所需物品的最少个数为dp[j]**。

`dp[j] = min(dp[j - coins[i]] + 1, dp[j]);`

如果求最小数，那么两层for循环的先后顺序就无所谓了

### 322. 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1

示例 2： 输入：coins = [2], amount = 3 输出：-1

---

* 完全背包的最少物品个数问题

递归五部曲：

1.确定dp数组以及下标的含义

**dp[j]：凑足总额为j所需钱币的最少个数为dp[j]**。

2.确定递推公式

递推公式：`dp[j] = min(dp[j - coins[i]] + 1, dp[j]);`

3.dp数组如何初始化

首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;

dp[j]必须初始化为一个最大的数，即`vector<int> dp(amount + 1, INT_MAX);`

4.确定遍历顺序

本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！(当dp定义为所需钱币的最少个数时，硬币是组合数还是排列数都无所谓！for循环次序不影响dp值，只有dp[j]定义为总额为j的排列/组合个数时循环次序才影响dp值)**

5.举例推导dp数组

```c
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```

对于遍历方式遍历背包放在外循环，遍历物品放在内循环也是可以的，我就直接给出代码了

```c
// 版本二
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {  // 遍历背包
            for (int j = 0; j < coins.size(); j++) { // 遍历物品
                if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX ) {
                    dp[i] = min(dp[i - coins[j]] + 1, dp[i]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```



### 279.完全平方数

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4

---



* 完全背包的最少物品个数问题，和322.零钱兑换一模一样。

**dp[j]：凑足完全平方和为j的最少个数为dp[j]**。



- ```c
  class Solution {
  public:
      int numSquares(int n) {
          vector<int> dp(n + 1, INT_MAX);
          dp[0] = 0;
          for (int i = 1; i * i <= n; i++) { // 遍历物品
              for (int j = i*i; j <= n; j++) { // 遍历背包
                  if (dp[j - i * i] != INT_MAX) {
                      dp[j] = min(dp[j - i * i] + 1, dp[j]);
                  }
              }
          }
          return dp[n];
      }
  };
  ```

## dp值true/false

### 139.单词拆分

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。

你可以假设字典中没有重复的单词。

示例 1： 输入: s = "leetcode", wordDict = ["leet", "code"] 输出: true 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

示例 2： 输入: s = "applepenapple", wordDict = ["apple", "pen"] 输出: true 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。  注意你可以重复使用字典中的单词。

示例 3： 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] 输出: false

---

解法一、回溯问题中的分割问题。[回溯算法：分割回文串](https://mp.weixin.qq.com/s/Pb1epUTbU8fHIht-g_MS5Q)：是枚举分割后的所有子串，判断是否回文。本题是枚举分割所有字符串，判断是否在字典里出现过。

  时间复杂度：O(2^n)，因为每一个单词都有两个状态，切割和不切割

```c
class Solution {
private:
    bool backtracking (const string& s, const unordered_set<string>& wordSet, int startIndex) {
        if (startIndex >= s.size()) {
            return true;
        }
        for (int i = startIndex; i < s.size(); i++) {
            string word = s.substr(startIndex, i - startIndex + 1);
            if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, i + 1)) {
                return true;
            }
        }
        return false;
    }
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        return backtracking(s, wordSet, 0);
    }
};
```

使用memory数组保存每次计算的以startIndex起始的计算结果，如果memory[startIndex]里已经被赋值了，直接用memory[startIndex]的结果。

C++代码如下：

```c
class Solution {
private:
    bool backtracking (const string& s,const unordered_set<string>& wordSet,vector<int>& memory,int startIndex) {
        if (startIndex >= s.size()) {
            return true;
        }
        // 如果memory[startIndex]不是初始值了，直接使用memory[startIndex]的结果
        if (memory[startIndex] != -1) return memory[startIndex];
        for (int i = startIndex; i < s.size(); i++) {
            string word = s.substr(startIndex, i - startIndex + 1);
            if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, memory, i + 1)) {
                memory[startIndex] = 1; // 记录以startIndex开始的子串是可以被拆分的
                return true;
            }
        }
        memory[startIndex] = 0; // 记录以startIndex开始的子串是不可以被拆分的
        return false;
    }
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<int> memory(s.size(), -1); // -1 表示初始化状态
        return backtracking(s, wordSet, memory, 0);
    }
};
```

这个时间复杂度其实也是：O(2^n)。只不过对于上面那个超时测试用例优化效果特别明显。

解法二、完全背包排列问题

**单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。**

拆分时可以重复使用字典中的单词，说明就是一个完全背包！

1. 确定dp数组以及下标的含义

**dp[i] : 长度为i的s[0:i-1]子串能否拆分为一个或多个在字典中出现的单词，dp[i]为true，表示可以拆分**。

2. 确定递推公式

所以**递推公式是 if([j, i-1] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。**

3. dp数组如何初始化

dp[0]就是递归的根基，dp[0]一定要为true。下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

4. 确定遍历顺序

本题最终要求的是是否都出现过，所以先遍历物品还是先遍历背包都可以。

但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。

如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）

所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后。

5. 举例推导dp[i]

以输入: s = "leetcode", wordDict = ["leet", "code"]为例，dp状态如图：

![image-20210707100051992](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210707100051992.png)

![image-20210707100537445](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210707100537445.png)

![image-20210707101415852](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210707101415852.png)

$\color{red}{红色字}$ <u>下划线文本</u>

```c
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
-----i = 1-----
j = 0,word = l
-----i = 2-----
j = 0,word = le
j = 1,word = e
-----i = 3-----
j = 0,word = lee
j = 1,word = ee
j = 2,word = e
-----i = 4-----
j = 0,word = leet
j = 1,word = eet
j = 2,word = et
j = 3,word = t
-----i = 5-----
j = 0,word = leetc
j = 1,word = eetc
j = 2,word = etc
j = 3,word = tc
j = 4,word = c
-----i = 6-----
j = 0,word = leetco
j = 1,word = eetco
j = 2,word = etco
j = 3,word = tco
j = 4,word = co
j = 5,word = o
-----i = 7-----
j = 0,word = leetcod
j = 1,word = eetcod
j = 2,word = etcod
j = 3,word = tcod
j = 4,word = cod
j = 5,word = od
j = 6,word = d
-----i = 8-----
j = 0,word = leetcode
j = 1,word = eetcode
j = 2,word = etcode
j = 3,word = tcode
j = 4,word = code
j = 5,word = ode
j = 6,word = de
j = 7,word = e


```

## 【背包总结】

### 递推公式

1）能否装满背包 ->(or最多装多少/最大价值)(即01背包)

**dp[j]表示 背包总容量是j，总和最大为dp[i]**。

`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`

2）背包组合/排列问题

**dp[j] 表示：填满容量为j的包，有dp[j]种方法.**

`dp[j] += dp[j - nums[i]]`

3）装满背包所需的最少物品个数

**dp[j]：凑足重量总和为j所需物品的最少个数为dp[j]**。

`dp[j] = min(dp[j - coins[i]] + 1, dp[j]);`

### 遍历顺序

#### 01背包

二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

#### 完全背包

先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

如果求组合数就是外层for循环遍历物品，内层for遍历背包。

如果求排列数就是外层for遍历背包，内层for循环遍历物品。

相关题目如下：

求组合数：动态规划：518.零钱兑换II
求排列数：动态规划：377. 组合总和 Ⅳ、动态规划：70. 爬楼梯进阶版（完全背包）
如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：

求最小数：动态规划：322. 零钱兑换、动态规划：279.完全平方数

