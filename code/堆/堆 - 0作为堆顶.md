# 堆

### 二叉堆实现优先级队列以及堆排序

#### 一、二叉堆概览

二叉堆（Binary Heap）没什么神秘，性质比二叉搜索树 BST 还简单。其主要操作就两个，`sink`（下沉）和 `swim`（上浮），用以维护二叉堆的性质。其主要应用有两个，首先是一种排序方法「堆排序」，第二是一种很有用的数据结构「优先级队列」。

**二叉堆其实就是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针**:

```java
// 父节点的索引
int parent(int root) {
    return (root - 1) / 2;
}
// 左孩子的索引
int left(int root) {
    return root * 2 + 1;
}
// 右孩子的索引
int right(int root) {
    return root * 2 + 2;
}
```

画个图你立即就能理解了

![image-20210813093901579](https://i0.wp.com/tvax1.sinaimg.cn/large/00496yplgy1gvnwoldjpvj60ip0bojsx02.jpg)



对于一个最大堆，根据其性质，显然堆顶，也就是 arr[0] 一定是所有元素中最大的元素。本文以最大堆为例讲解。

#### 二、优先级队列概览

优先级队列这种数据结构有一个很有用的功能，你插入或者删除元素的时候，元素会自动排序，这底层的原理就是二叉堆的操作。

下面我们实现一个简化的优先级队列，先看下代码框架：

```java
public class MaxPQ
    <Key extends Comparable<Key>> {
    // 存储元素的数组
    private Key[] pq;
    // 当前 Priority Queue 中的元素个数
    private int N = 0;

    public MaxPQ(int cap) {
        // 分配空间
        pq = (Key[]) new Comparable[cap];
    }

    /* 返回当前队列中最大元素 */
    public Key max() {
        return pq[0];
    }

    /* 插入元素 e */
    public void insert(Key e) {...}

    /* 删除并返回当前队列中最大元素 */
    public Key delMax() {...}

    /* 上浮第 k 个元素，以维护最大堆性质 */
    private void swim(int k) {...}

    /* 下沉第 k 个元素，以维护最大堆性质 */
    private void sink(int k) {...}

    /* 交换数组的两个元素 */
    private void exch(int i, int j) {
        Key temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;
    }

    /* pq[i] 是否比 pq[j] 小？ */
    private boolean less(int i, int j) {
        return pq[i].compareTo(pq[j]) < 0;
    }

    /* 还有 left, right, parent 三个方法 */
}
```

#### 三、实现 swim 和 sink

为什么要有上浮 swim 和下沉 sink 的操作呢？为了维护堆结构.

细心的读者也许会问，这两个操作不是互逆吗，所以上浮的操作一定能用下沉来完成，为什么我还要费劲写两个方法？

是的，操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进行（等会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要下沉。

```java
private void swim(int k) {
    // 如果浮到堆顶，就不能再上浮了
    while (k > 0 && less(parent(k), k)) {
        // 如果第 k 个元素比上层大
        // 将 k 换上去
        exch(parent(k), k);
        k = parent(k);
    }
}
```

下沉比上浮略微复杂一点，因为上浮某个节点 A，只需要 A 和其父节点比较大小即可；但是下沉某个节点 A，需要 A 和其**两个子节点**比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。

```java
    /* 下沉第 k 个元素，以维护最大堆性质 */
    private void sink(int k) {
        // 如果沉到堆底，就沉不下去了
        while (left(k) < N) {
            // 先假设左边节点较大
            int older = left(k);
            // 如果右边节点存在，比一下大小
            if (right(k) < N && less(older, right(k)))
                older = right(k);
            // 结点 k 比俩孩子都大，就不必下沉了
            if (less(older, k))
                break;
            // 否则，不符合最大堆的结构，下沉 k 结点
            exch(k, older);
            k = older;
        }
    }
```

#### 四、实现 delMax 和 insert

这两个方法就是建立在 `swim` 和 `sink` 上的。

**`insert`** **方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置。**

```java
    public void insert(Key e) {
        // 先把新元素加到最后
        pq[N] = e;
        // 然后让它上浮到正确的位置
        swim(N);
        N++;
    }
```

**`delMax`** **方法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。**

```java
    public Key delMax() {
        // 最大堆的堆顶就是最大元素
        Key max = pq[0];
        // 把这个最大元素换到最后，删除之
        exch(0, N-1);
        pq[N-1] = null;
        N--;
        // 让 pq[0] 下沉到正确位置
        sink(0);
        return max;
    }
```



#### **五、代码实现**

##### 1)手撕版本(大根堆)：

###### 第一步：实现优先级队列

```java
class MaxPQ {
    // 存储元素的数组
    private int[] pq;
    // 当前 Priority Queue 中的元素个数
    private int N = 0;

    public MaxPQ(int cap) {
        pq = new int[cap];
    }

    /* 返回当前队列中最大元素 */
    public int max() {
        return pq[0];
    }

    /* 插入元素 e */
    public void insert(int e) {
        // 先把新元素加到最后
        pq[N] = e;
        // 然后让它上浮到正确的位置
        swim(N);
        N++;
    }

    /* 删除并返回当前队列中最大元素 */
    public int delMax() {
        // 最大堆的堆顶就是最大元素
        int max = pq[0];
        // 把这个最大元素换到最后，删除之
        exch(0, N - 1);
        N--;
        // 让 pq[0] 下沉到正确位置
        sink(0);
        return max;
    }

    /* 上浮第 k 个元素，以维护最大堆性质 */
    private void swim(int k) {
        // 如果浮到堆顶，就不能再上浮了
        while (k > 0 && less(parent(k), k)) {
            // 如果第 k 个元素比上层大
            // 将 k 换上去
            exch(parent(k), k);
            k = parent(k);
        }
    }

    /* 下沉第 k 个元素，以维护最大堆性质 */
    private void sink(int k) {
        // 如果沉到堆底，就沉不下去了
        while (left(k) < N) {
            // 先假设左边节点较大
            int older = left(k);
            // 如果右边节点存在，比一下大小
            if (right(k) < N && less(older, right(k)))
                older = right(k);
            // 结点 k 比俩孩子都大，就不必下沉了
            if (less(older, k))
                break;
            // 否则，不符合最大堆的结构，下沉 k 结点
            exch(k, older);
            k = older;
        }
    }

    /* 交换数组的两个元素 */
    private void exch(int i, int j) {
        int temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;
    }

    /* pq[i] 是否比 pq[j] 小？ */
    private boolean less(int i, int j) {
        return pq[i] < pq[j];
    }

    /* 还有 left, right, parent 三个方法 */
    // 父节点的索引
    int parent(int root) {
        return (root - 1) / 2;
    }

    // 左孩子的索引
    int left(int root) {
        return root * 2 + 1;
    }

    // 右孩子的索引
    int right(int root) {
        return root * 2 + 2;
    }

    /* 返回元素个数 */
    public int size() {
        return N;
    }
```

插入和删除元素的时间复杂度为 `O(logK)`，`K` 为当前二叉堆（优先级队列）中的元素总数。

###### 第二步：堆排序

```java
class HeapSort {
    public void heapSort(int[] arr) {
        MaxPQ pq = new MaxPQ(arr.length);
        for (int data : arr) {
            pq.insert(data);
        }
        int idx = 0;
        while (pq.size() > 0) {
            arr[idx++] = pq.delMax();
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[] { 1, 34, 234, 24, 342, 34, 234, 24, 24, 2, 34, 34 };
        new HeapSort().heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

对每个元素包含插入和删除操作，时间复杂度为`O(nlogn)`，n为数组长度。

###### 第三步：使用PriorityQueue实现堆排序

```java
class HeapSort {
    public static void heapSort(int[] arr) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(arr.length, 
                                   (o1, o2) -> o2.compareTo(o1));
        for (int data : arr) {
            pq.offer(data);
        }
        int idx = 0;
        while (pq.size() > 0) {
            arr[idx++] = pq.poll();
        }
    }
    public static void main(String[] args) {
        int[] arr = new int[] { 1, 34, 234, 24, 342, 34, 234, 24, 24, 2, 34, 34 };
        HeapSort.heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```



##### 2)泛化版本(大根堆)

第一步：实现优先级队列

```java
class MaxPQ<Key extends Comparable<Key>> {
    // 存储元素的数组
    private Key[] pq;
    // 当前 Priority Queue 中的元素个数
    private int N = 0;

    public MaxPQ(int cap) {
        pq = (Key[]) new Comparable[cap];
    }

    /* 返回当前队列中最大元素 */
    public Key max() {
        return pq[0];
    }

    /* 插入元素 e */
    public void insert(Key e) {
        // 先把新元素加到最后
        pq[N] = e;
        // 然后让它上浮到正确的位置
        swim(N);
        N++;
    }

    /* 删除并返回当前队列中最大元素 */
    public Key delMax() {
        // 最大堆的堆顶就是最大元素
        Key max = pq[0];
        // 把这个最大元素换到最后，删除之
        exch(0, N - 1);
        pq[N - 1] = null;
        N--;
        // 让 pq[0] 下沉到正确位置
        sink(0);
        return max;
    }

    /* 上浮第 k 个元素，以维护最大堆性质 */
    private void swim(int k) {
        // 如果浮到堆顶，就不能再上浮了
        while (k > 0 && less(parent(k), k)) {
            // 如果第 k 个元素比上层大
            // 将 k 换上去
            exch(parent(k), k);
            k = parent(k);
        }
    }

    /* 下沉第 k 个元素，以维护最大堆性质 */
    private void sink(int k) {
        // 如果沉到堆底，就沉不下去了
        while (left(k) < N) {
            // 先假设左边节点较大
            int older = left(k);
            // 如果右边节点存在，比一下大小
            if (right(k) < N && less(older, right(k)))
                older = right(k);
            // 结点 k 比俩孩子都大，就不必下沉了
            if (less(older, k))
                break;
            // 否则，不符合最大堆的结构，下沉 k 结点
            exch(k, older);
            k = older;
        }
    }

    /* 交换数组的两个元素 */
    private void exch(int i, int j) {
        Key temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;
    }

    /* pq[i] 是否比 pq[j] 小？ */
    private boolean less(int i, int j) {
        return pq[i].compareTo(pq[j]) < 0;
    }

    /* 还有 left, right, parent 三个方法 */
    // 父节点的索引
    int parent(int root) {
        return (root - 1) / 2;
    }

    // 左孩子的索引
    int left(int root) {
        return root * 2 + 1;
    }

    // 右孩子的索引
    int right(int root) {
        return root * 2 + 2;
    }

    /* 返回元素个数 */
    public int size() {
        return N;
    }
}
```

第二步：堆排序

```java
class HeapSort {
    public static void heapSort(int[] arr) {
        MaxPQ<Integer> pq = new MaxPQ<>(arr.length);
        for (int data : arr) {
            pq.insert(data);
        }
        int idx = 0;
        while (pq.size() > 0) {
            arr[idx++] = pq.delMax();
        }
    }
    public static void main(String[] args) {
        int[] arr = new int[] { 1, 34, 234, 24, 342, 34, 234, 24, 24, 2, 34, 34 };
        HeapSort.heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}


```



3）左程云版本堆排序(大根堆)：

```java
Code_03_HeapSort   
 public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }
        int size = arr.length;
        swap(arr, 0, --size);
        while (size > 0) {
            heapify(arr, 0, size);
            swap(arr, 0, --size);
        }
    }
//可做优先队列，或者删除最大值
//从下往上的插入int arr[]={……4 6 2}
// //heapInsert就是建立大根堆

    public static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }
//从上往下调整堆结构
// //heapify就是把堆顶和最后一个数交换位置，然后堆的大小size--

    public static void heapify(int[] arr, int index, int size) {
        int left = index * 2 + 1;
        while (left < size) {
            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            //大孩子位置largest
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

```



#### 七、最后总结

二叉堆就是一种完全二叉树，所以适合存储在数组中，而且二叉堆拥有一些特殊性质。

二叉堆的操作很简单，主要就是上浮和下沉，来维护堆的性质（堆有序），核心代码也就十行。

优先级队列是基于二叉堆实现的，主要操作是插入和删除。**插入是先插到最后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位置。**核心代码也就十行。

## 应用

### topk问题

题目描述：在未排序的数组中找到第 **k** 个最大的元素。

解法一、二叉堆$O(n \log n)$

解法二、快速选择算法$O(n)$，可解决：

topk切分

获得前k小的数

获取第k小的数

获得前k大的数

获得第k大的数

只排序前k个小的数

只排序后k个大的数

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

![image-20210721161248605](https://i0.wp.com/tvax1.sinaimg.cn/large/00496yplgy1gvnwoee5a1j60fj0dr76u02.jpg)

解法二、快速选择算法，即partition+二分查找`O(N)`

实现代码见后面部分。

解法一、二叉堆$O(n \log n)$

**二叉堆（优先队列）的解法比较简单**，先直接看代码吧：

1)使用PriorityQueue

```c
class Solution{
    public int findKthLargest(int[] nums, int k) {
        // 小顶堆，堆顶是最小元素
        PriorityQueue<Integer> 
            pq = new PriorityQueue<>();
        for (int e : nums) {
            // 每个元素都要过一遍二叉堆
            pq.offer(e);
            // 堆中元素多于 k 个时，删除堆顶元素
            if (pq.size() > k) {
                pq.poll();
            }
        }
        // pq 中剩下的是 nums 中 k 个最大元素，
        // 堆顶是最小的那个，即第 k 个最大元素
        return pq.peek();
    }
}
```

堆的大小不会超过 `k`，所以插入和删除元素的复杂度是 `O(logK)`，再套一层 for 循环，总的时间复杂度就是 `O(NlogK)`。

2）使用小根堆实现优先级队列，使用优先级队列进行堆排序

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        MinPQ pq = new MinPQ(k+1);
        for (int data : nums) {
            pq.insert(data);
            if (pq.size() > k) {
                pq.delMin();
            }
        }
        return pq.min();
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = { 3, 2, 1, 5, 6, 4 };
        int k = 2;
        int findKthLargest = solution.findKthLargest(nums, k);
        System.out.println(findKthLargest);
    }
}
```

```java
class MinPQ {
    // 存储元素的数组
    private int[] pq;
    // 当前 Priority Queue 中的元素个数
    private int N = 0;

    public MinPQ(int cap) {
        pq = new int[cap];
    }

    /* 返回当前队列中最小元素 */
    public int min() {
        return pq[0];
    }

    /* 插入元素 e */
    public void insert(int e) {
        // 先把新元素加到最后
        pq[N] = e;
        // 然后让它上浮到正确的位置
        swim(N);
        N++;
    }

    /* 删除并返回当前队列中最小元素 */
    public int delMin() {
        // 最小堆的堆顶就是最小元素
        int max = pq[0];
        // 把这个最小元素换到最后，删除之
        exch(0, N - 1);
        N--;
        // 让 pq[0] 下沉到正确位置
        sink(0);
        return max;
    }

    /* 上浮第 k 个元素，以维护最小堆性质 */
    private void swim(int k) {
        // 如果浮到堆顶，就不能再上浮了
        while (k > 0 && large(parent(k), k)) {
            // 如果第 k 个元素比上层小
            // 将 k 换上去
            exch(parent(k), k);
            k = parent(k);
        }
    }

    /* 下沉第 k 个元素，以维护最小堆性质 */
    private void sink(int k) {
        // 如果沉到堆底，就沉不下去了
        while (left(k) < N) {
            // 先假设左边节点较小
            int older = left(k);
            // 如果右边节点存在，比一下大小
            if (right(k) < N && large(older, right(k)))
                older = right(k);
            // 结点 k 比俩孩子都小，就不必下沉了
            if (large(older, k))
                break;
            // 否则，不符合最小堆的结构，下沉 k 结点
            exch(k, older);
            k = older;
        }
    }

    /* 交换数组的两个元素 */
    private void exch(int i, int j) {
        int temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;
    }

    /* pq[i] 是否比 pq[j] 大？ */
    private boolean large(int i, int j) {
        return pq[i] > pq[j];
    }

    /* 还有 left, right, parent 三个方法 */
    // 父节点的索引
    int parent(int root) {
        return (root - 1) / 2;
    }

    // 左孩子的索引
    int left(int root) {
        return root * 2 + 1;
    }

    // 右孩子的索引
    int right(int root) {
        return root * 2 + 2;
    }

    /* 返回元素个数 */
    public int size() {
        return N;
    }
}
```



解法二、快速选择算法，即partition+二分查找，$O(n)$

解法代码：

```c
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return topk_large(nums,k);
    }
    
    /* 获得第k大的数,思路：parttion是按从小到大划分的，如果让index左边为前n-k个小的数，则index右边为前k个大的数(包括index) */
    public int topk_large(int[] nums, int k) {
        int target = nums.length - k;
        topk_split(nums, target);
        return nums[target];
    }
    
    /* 寻找下标k，满足左边k个元素<nums[k],右边(包含下标k)`nums.length-k`个元素≥nums[k]。 */
    public void topk_split(int[] nums, int k) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) { // [left,right]
            int[] points = partition(nums, left, right);
            // index含义：左边有index个比nums[index]小的数,即左边界的定义
            int index = points[0];
            if (index < k) {
                left = index + 1;
            } else if (index > k) {
                right = index - 1;
            } else {
                return;
            }
        }
    }
    // partion 把选定的pivot挪到正确位置上
    public int[] partition(int[] arr, int l, int r) {
        // 如果是对近乎有序的数组进行快速排序，每次 partition 分区后子数组大小极不平衡，容易退化成O(n^2)的时间复杂度算法。Math.random()= 0 ~ 0.99
        swap(arr, l + (int) (Math.random() * (r - l + 1)), l);
        int less = l - 1;// 小于区域的边界
        int more = r + 1;// 大于区域的边界
        int cur = l;
        int pivot = arr[l]; // 选择区间起点为pivot
        while (cur < more) {
            if (arr[cur] < pivot) {
                swap(arr, ++less, cur++);
            } else if (arr[cur] > pivot) {
                swap(arr, --more, cur);
            } else {
                cur++;
            }
        }
        return {less + 1,right-1};
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }

    public static void main(String[] args) {
        int[] nums = { 3, 2, 1, 5, 6, 4 };
        int findKthLargest = new Solution().findKthLargest(nums, 2);
        System.out.println(findKthLargest);
    }
}
```



### 中位数问题

#### [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)

![image-20210621203326557](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210621203326557.png)

容易想到的暴力方法是数据流新进来一个数，都把它与已有的数进行一次排序，这样中位数就可以很容易得到，但时间复杂度为 $O(N\log N)$。事实上，**我们对除了中位数以外的其它位置的元素并不关心**。

在我们熟悉的数据结构里，堆（优先队列）就有类似的性质，每次都从堆里得到一个「最值」而其它元素无须比较。可以以 $O(\log N)$的复杂度每次都从堆中取出最值。

如果数据流中每读出 1个数后都排一次序，「中位数」就位于这些数的「中间」。「中位数」把它们分为两个部分，一部分是「前有序数组」，另一部分是「后有序数组」。我们发现如下事实：

当从数据流中读出的数的个数为奇数的时候，中位数是「前有序数组」中的最大值，如下左图所示；
当从数据流中读出的数的个数为偶数的时候，左中位数是「前有序数组」中的最大值，右中位数是「后有序数组」中的最小值，如下右图所示。

![image.png](https://pic.leetcode-cn.com/1612277950-DNJcTI-image.png)

由于我们只关心这两个 有序数组 中的最值，有一个数据结构可以帮助我们快速找到这个最值，这就是 优先队列 。具体来说：

前有序数组由于只关注最大值，可以 **动态地** 放置在一个最大堆中；

后有序数组由于只关注最小值，可以 **动态地** 放置在一个最小堆中。

**动态性体现在：想要往 `minHeap` 里添加元素，不能直接添加，而是要先往 `maxHeap` 里添加，然后再把 `maxHeap` 的堆顶元素加到 `minHeap` 中；向 `maxHeap` 中添加元素同理**。

为了得到所求的中位数，在任何时刻，两个堆应该始终保持的性质如下：

* 最大堆的堆顶元素，小于或者等于最小堆的堆顶元素；
* 最大堆的元素个数或者与最小堆的元素个数相等，或者多 1 。



```java
class MedianFinder {

    private PriorityQueue<Integer> minHeap;
    private PriorityQueue<Integer> maxHeap;

    public MedianFinder() {
        // 小顶堆
        minHeap = new PriorityQueue<>();
        // 大顶堆
        maxHeap = new PriorityQueue<>((a, b) -> {
            return b - a;
        });
    }

    public double findMedian() {
        // 如果元素不一样多，大根堆堆顶元素就是中位数
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.peek();
        } else {
            // 如果元素一样多，两个堆堆顶元素的平均数是中位数
            return (minHeap.peek() + maxHeap.peek()) / 2.0;
        }

    }

    public void addNum(int num) {
        if (maxHeap.size() > minHeap.size()) {
            maxHeap.offer(num);
            minHeap.offer(maxHeap.poll());
        } else {
            // maxHeap.size() == minHeap.size()
            minHeap.offer(num);
            maxHeap.offer(minHeap.poll());
        }
    }
}
```

优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的，综上，`addNum` 方法时间复杂度 O(logN)，`findMedian` 方法时间复杂度 O(1)。



**中位数的变形：TP 99 问题**

> TP 99 问题：指在一个时间段内（如5分钟），统计某个方法（或接口）每次调用所消耗的时间，并将这些时间按从小到大的顺序进行排序，取第 99% 的那个值作为 TP99 值；
>
> 例如某个接口在 5 分钟内被调用了100次，每次耗时从 1ms 到 100ms之间不等数据，将请求耗时从小到大排列，TP99 就是取第 100*0.99 = 99 次请求耗时 ，类似地 TP50、TP90，TP99越小，说明这个接口的性能越好

所以，针对 TP99 问题，我们同样也可以维护两个堆，一个大顶堆，一个小顶堆。大顶堆中保存前 `99%` 个数据，小顶堆中保存后 `1%` 个数据。大顶堆堆顶的数据就是我们要找的 99% 响应时间。

方法二、这样的话，TP99是不是也可以视为TOPk问题，使用快速选择法选取，平均时间复杂度是O(N)
