## 入门题目

### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
  F(0) = 0，F(1) = 1
  F(n) = F(n - 1) + F(n - 2)，其中 n > 1
  给你n ，请计算 F(n) 。

---

方法一、递归

```c
class Solution {
public:
    int fib(int N) {
        if (N < 2) return N;
        return fib(N - 1) + fib(N - 2);
    }
};
```

方法二、动态规划

递推公式`dp[i] = dp[i - 1] + dp[i - 2]`

```c
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```

当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。

代码如下：

```c
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int dp[2];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```



### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？示例 1：
输入：2
输出：2
解释：有两种方法可以爬到楼顶。1 阶 + 1 阶  2 阶

---

和509. 斐波那契数一模一样

dp[i]：爬到第i层楼梯，有dp[i]种方法
递推公式`dp[i] = dp[i - 1] + dp[i - 2]`

### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

![image-20210707141229050](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210707141229050.png)

---



可以认为cost=[10,15,20,0] 最后一步可以理解为 不用花费。
dp[i]的定义：爬上第i个台阶所花费的最少体力为dp[i]。

```c++
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length + 1];
        for (int i = 2; i < cost.length + 1; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.length];
    }
}
```

- 优化：使用dp0和dp1记录前两位数值

### [62.不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

1. 深度优先搜索(超时)：注意题目中说机器人每次只能向下或者向右移动一步，那么其实机器人走过的路径可以抽象为一颗二叉树，而叶子节点就是终点！

```c++
  class Solution {
  private:
  	//含义：从(i,j)出发有多少条到(m,n)的路径
      int dfs(int i, int j, int m, int n) {
          if (i > m || j > n) return 0; // 越界了
          if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
          return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
      }
  public:
      int uniquePaths(int m, int n) {
          return dfs(1, 1, m, n);
      }
  };
```

方法二、动态规划：

`dp[i][j]` ：表示从`(0,0)`出发，到`(i, j)` 有`dp[i][j]`条不同的路径。 

`dp[i][j] = dp[i - 1][j] + dp[i][j - 1];`

```c
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};

```

- 一维滚动数组

### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。

![image-20210707145031512](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210707145031512.png)

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

### 64. 最小路径和

![image-20210709142140706](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210709142140706.png)

思路简单，和62.不同路径 基本一样，dp值加上数组数值即可,没有什么新东西需要学习。

dp数组定义：`dp[i][j]`表示从[0,0]走到[i,j]的最小路径和。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        // dp[i][j]表示从[0,0]走到[i,j]的最小路径和
        int row = grid.length;
        int col = grid[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < row; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < col; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
                System.out.println("i="+i+",j="+j+",dp="+dp[i][j]);
            }
        }
        return dp[row - 1][col - 1];
    }
}
```



### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

给定⼀个正整数 n，将其拆分为⾄少两个正整数的和，并使这些整数的乘积最⼤化。 返回你可以获得的最⼤乘积。
示例 1:
输⼊: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:
输⼊: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

 说明: 你可以假设n 不⼩于 2 且不⼤于 58。

---

dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

假设对正整数 i 拆分出的第一个正整数是 j，则有以下两种方案：
将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是j×(i−j)；
将 i 拆分成 j 和 i−j 的和，，且 i−j  继续拆分成多个正整数，此时的乘积是j×dp[i−j]。

- `dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));`那有同学问了，j怎么就不拆分呢？j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。**或者也可以理解j是拆分i的第一个整数**。

C++代码如下：

```c
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```

- 我觉得应该分为四种情况：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j), (i - j) * dp[j], dp[i - j] * dp[j]);`，整理一下可得到`dp[i] = max(dp[i], (max(j, dp[j])) * (max(i - j, dp[i - j])));`(from 数据结构和算法3.1)

### [96.不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

![image-20210616140135297](https://cdn.jsdelivr.net/gh/archted/markdown-img@main/img/image-20210616140135297.png)



dp[i]含义：表示由i个节点组成的BST个数为dp[i]

```c++
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
};
```

## 
