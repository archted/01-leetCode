[TOC]

# 动态规划

## 目录导航

<img src="assets/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732fe58aa8e68081e8a784e588922de680bbe7bb93e5a4a7e7bab2312e6a7067" alt="img" style="zoom: 50%;" />

## 基础知识

### 核心问题

**求解动态规划的核心问题是穷举。**

**而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。**

**因此，解决动态规划问题就是找「状态」和「选择」，仅此而已**。

动态规划框架：

```php
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

### 动归三要素

首先，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**，才能正确地穷举。

以上提到的重叠子问题、最优子结构、状态转移方程就是**动态规划三要素。**

下面以斐波那契数列为例说明动态规划过程。

一、斐波那契数列

**1、暴力递归**

斐波那契数列的数学形式就是递归的，写成代码就是这样：

```c
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

假设 n = 20，请画出递归树：

这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。**

首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。

然后计算解决一个子问题的时间，在本算法中，没有循环，只有 `f(n - 1) + f(n - 2)` 一个加法操作，时间为 O(1)。

所以，这个算法的时间复杂度为二者相乘，即 $O(2^n)$，指数级别，爆炸。

观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。
这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。

**2、带备忘录的递归解法**

```c
int fib(int N) {
    if (N < 1) return 0;
    // 备忘录全初始化为 0
    vector<int> memo(N + 1, 0);
    // 进行带备忘录的递归
    return helper(memo, N);
}

int helper(vector<int>& memo, int n) {
    // base case
    if (n == 1 || n == 2) return 1;
    // 已经计算过
    if (memo[n] != 0) return memo[n];
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}
```

实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

所以，本算法的时间复杂度是$ O(n)$。比起暴力算法，是降维打击。

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过**带备忘录的递归解法叫做「自顶向下」，动态规划叫做「自底向上」。**

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 `f(20)`，向下逐渐分解规模，直到 `f(1)` 和 `f(2)` 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 `f(1)` 和 `f(2)` 开始往上推，直到推到我们想要的答案 `f(20)`，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

**3、dp 数组的迭代解法**

有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！

```c
int fib(int N) {
    if (N < 1) return 0;
    if (N == 1 || N == 2) return 1;
    vector<int> dp(N + 1, 0);
    // base case
    dp[1] = dp[2] = 1;
    for (int i = 3; i <= N; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[N];
}
```

画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。

### 状态压缩

常听说的「状态压缩」技巧，就能够把很多动态规划解法的空间复杂度进一步降低，由 O(N^2) 降低到 O(N)。

比如前文 [最长回文子序列]() 中，最终的代码如下：

```java
int longestPalindromeSubseq(string s) {
    int n = s.size();
    // dp 数组全部初始化为 0
    vector<vector<int>> dp(n, vector<int>(n, 0));
    // base case
    for (int i = 0; i < n; i++)
        dp[i][i] = 1;
    // 反着遍历保证正确的状态转移
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            // 状态转移方程
            if (s[i] == s[j])
                dp[i][j] = dp[i + 1][j - 1] + 2;
            else
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
    }
    // 整个 s 的最长回文子串长度
    return dp[0][n - 1];
}
```

你看我们对 `dp[i][j]` 的更新，其实只依赖于 `dp[i+1][j-1], dp[i][j-1], dp[i+1][j]` 这三个状态.

**状态压缩的核心思路就是，将二维数组「投影」到一维数组**.想把二维 `dp` 数组压缩成一维，一般来说是把第一个维度，也就是 `i` 这个维度去掉，只剩下 `j` 这个维度。

<img src="assets/image-20210712111759597.png" alt="image-20210712111759597" style="zoom: 67%;" />

图中 `dp[i][j-1]` 和 `dp[i+1][j-1]` 这两个状态处在同一列，而一维数组中只能容下一个，那么当我计算 `dp[i][j]` 时，他俩必然有一个会被另一个覆盖掉，怎么办？

我们先将上述代码进行改造，直接无脑去掉 i 这个维度，把 dp 数组变成一维：

```java
for (int i = n - 2; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) {
        // 在这里，一维 dp 数组中的数是什么？
        if (s[i] == s[j])
            dp[j] = dp[j - 1] + 2;
        else
            dp[j] = max(dp[j], dp[j - 1]);
    }
```

在代码中注释的位置，将要进行状态转移，更新 `dp[j]`，那么我们要来思考两个问题：

1、在对 `dp[j]` 赋新值之前，`dp[j]` 对应着二维 `dp` 数组中的什么位置？

2、`dp[j-1]` 对应着二维 `dp` 数组中的什么位置？

**对于问题 1，在对** **`dp[j]`** **赋新值之前，****`dp[j]`** **的值就是外层 for 循环上一次迭代算出来的值，也就是对应二维** **`dp`** **数组中** **`dp[i+1][j]`** **的位置**。

**对于问题 2，****`dp[j-1]`** **的值就是内层 for 循环上一次迭代算出来的值，也就是对应二维** **`dp`** **数组中** **`dp[i][j-1]`** **的位置**。

那么问题已经解决了一大半了，只剩下二维 `dp` 数组中的 `dp[i+1][j-1]` 这个状态我们不能直接从一维 `dp` 数组中得到：



```c
for (int i = n - 2; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) {
        if (s[i] == s[j])
            // dp[i][j] = dp[i+1][j-1] + 2;
            dp[j] = ?? + 2;
        else
            // dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
            dp[j] = max(dp[j], dp[j - 1]);
    }
}
```

**那么如果我们想得到** **`dp[i+1][j-1]`****，就必须在它被覆盖之前用一个临时变量** **`temp`** **把它存起来，并把这个变量的值保留到计算** **`dp[i][j]`** **的时候**。为了达到这个目的，结合上图，我们可以这样写代码：



```c
for (int i = n - 2; i >= 0; i--) {
    // 存储 dp[i+1][j-1] 的变量
    int pre = 0;
    for (int j = i + 1; j < n; j++) {
        int temp = dp[j];
        if (s[i] == s[j])
            // dp[i][j] = dp[i+1][j-1] + 2;
            dp[j] = pre + 2;
        else
            dp[j] = max(dp[j], dp[j - 1]);
        // 到下一轮循环，pre 就是 dp[i+1][j-1] 了
        pre = temp;
    }
}
```

别小看这段代码，这是一维 `dp` 最精妙的地方，会者不难，难者不会。

那么现在我们成功对状态转移方程进行了降维打击，算是最硬的的骨头啃掉了，但注意到我们还有 base case 要处理呀：



```c
// dp 数组全部初始化为 0
vector<vector<int>> dp(n, vector<int>(n, 0));
// base case
for (int i = 0; i < n; i++)
    dp[i][i] = 1;
```

如何把 base case 也打成一维呢？很简单，记住状态压缩就是投影，我们把 base case 投影到一维看看：

<img src="assets/image-20210712112052515.png" alt="image-20210712112052515" style="zoom:67%;" />

二维 `dp` 数组中的 base case 全都落入了一维 `dp` 数组，不存在冲突和覆盖，所以说我们直接这样写代码就行了：

```c
// 一维 dp 数组全部初始化为 1
vector<int> dp(n, 1);
```

至此，我们把 base case 和状态转移方程都进行了降维，实际上已经写出完整代码了：

```c
int longestPalindromeSubseq(string s) {
    int n = s.size();
    // base case：一维 dp 数组全部初始化为 0
    vector<int> dp(n, 1);

    for (int i = n - 2; i >= 0; i--) {
        int pre = 0;
        for (int j = i + 1; j < n; j++) {
            int temp = dp[j];
            // 状态转移方程
            if (s[i] == s[j])
                dp[j] = pre + 2;
            else
                dp[j] = max(dp[j], dp[j - 1]);
            pre = temp;
        }
    }
    return dp[n - 1];
}
```

本文就结束了，不过状态压缩技巧再牛逼，也是基于常规动态规划思路之上的。

## 动规五部曲

```c
1 确定dp数组（dp table）以及下标的含义
2 确定递推公式
3 dp数组如何初始化
4 确定遍历顺序
5 举例推导dp数组
```

## 入门题目

### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
  F(0) = 0，F(1) = 1
  F(n) = F(n - 1) + F(n - 2)，其中 n > 1
  给你n ，请计算 F(n) 。

---

方法一、递归

```c
class Solution {
public:
    int fib(int N) {
        if (N < 2) return N;
        return fib(N - 1) + fib(N - 2);
    }
};
```

方法二、动态规划

递推公式`dp[i] = dp[i - 1] + dp[i - 2]`

```c
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```

当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。

代码如下：

```c
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int dp[2];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```



### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？示例 1：
输入：2
输出：2
解释：有两种方法可以爬到楼顶。1 阶 + 1 阶  2 阶

---

和509. 斐波那契数一模一样

dp[i]：爬到第i层楼梯，有dp[i]种方法
递推公式`dp[i] = dp[i - 1] + dp[i - 2]`

### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

![image-20210707141229050](assets/image-20210707141229050.png)

---



可以认为cost=[10,15,20,0] 最后一步可以理解为 不用花费。
dp[i]的定义：爬上第i个台阶所花费的最少体力为dp[i]。

```c++
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length + 1];
        for (int i = 2; i < cost.length + 1; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.length];
    }
}
```

- 优化：使用dp0和dp1记录前两位数值

### [62.不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

1. 深度优先搜索(超时)：注意题目中说机器人每次只能向下或者向右移动一步，那么其实机器人走过的路径可以抽象为一颗二叉树，而叶子节点就是终点！

```c++
  class Solution {
  private:
  	//含义：从(i,j)出发有多少条到(m,n)的路径
      int dfs(int i, int j, int m, int n) {
          if (i > m || j > n) return 0; // 越界了
          if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
          return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
      }
  public:
      int uniquePaths(int m, int n) {
          return dfs(1, 1, m, n);
      }
  };
```

方法二、动态规划：

`dp[i][j]` ：表示从`(0,0)`出发，到`(i, j)` 有`dp[i][j]`条不同的路径。 

`dp[i][j] = dp[i - 1][j] + dp[i][j - 1];`

```c
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};

```

- 一维滚动数组

### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。

![image-20210707145031512](assets/image-20210707145031512.png)

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

给定⼀个正整数 n，将其拆分为⾄少两个正整数的和，并使这些整数的乘积最⼤化。 返回你可以获得的最⼤乘积。
示例 1:
输⼊: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:
输⼊: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

 说明: 你可以假设n 不⼩于 2 且不⼤于 58。

---

dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

假设对正整数 i 拆分出的第一个正整数是 j，则有以下两种方案：
将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是j×(i−j)；
将 i 拆分成 j 和 i−j 的和，，且 i−j  继续拆分成多个正整数，此时的乘积是j×dp[i−j]。

- `dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));`那有同学问了，j怎么就不拆分呢？j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。**或者也可以理解j是拆分i的第一个整数**。

C++代码如下：

```c
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```

- 我觉得应该分为四种情况：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j), (i - j) * dp[j], dp[i - j] * dp[j]);`，整理一下可得到`dp[i] = max(dp[i], (max(j, dp[j])) * (max(i - j, dp[i - j])));`(from 数据结构和算法3.1)

### [96.不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

![image-20210616140135297](assets/image-20210616140135297.png)



dp[i]含义：表示由i个节点组成的BST个数为dp[i]

```c++
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
};
```

## 打家劫舍系列

**劫舍系列简单来说就是 数组上连续元素二选一，成环之后连续元素二选一，在树上连续元素二选一，所能得到的最大价值**。

### [198.打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。

---



- 动规五部曲分析如下：

**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

偷下标为i的元素：dp[i - 2] + nums[i]；不偷下标为i的元素：dp[i-1]

dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

```c
class Solution {
public:
    int rob(TreeNode* root) {
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```

### [213.打家劫舍II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

示例 1：

输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。



对于一个数组，成环的话主要有如下三种情况：

- 情况一：考虑不包含首尾元素

- 情况二：考虑包含首元素，不包含尾元素

- 情况三：考虑包含尾元素，不包含首元素

**而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了**。

```c
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
```

### [337.打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)



在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

<img src="assets/image-20210513110531134.png" alt="image-20210513110531134" style="zoom: 50%;" />

- 类型：树形dp

1、带备忘录的后序遍历

先对二叉树后序遍历，遍历过程中使用备忘录保存偷窃的结果。

对于单个节点来说，只有两种状态：选择或者不选。

```c
//函数意义：以root为根节点的二叉树，小偷偷取的最高金额
class Solution {
public:
    unordered_map<TreeNode *, int> umap;  // 记录计算过的结果
    int rob(TreeNode *root)
    {
        if (root == NULL)
            return 0;
        if (root->left == NULL && root->right == NULL)
            return root->val;
        if (umap[root])
            return umap[root];  // 如果umap里已经有记录则直接返回
        // 偷父节点
        int val1 = root->val;
        if (root->left)
            val1 += rob(root->left->left) + rob(root->left->right);  // 跳过root->left
        if (root->right)
            val1 += rob(root->right->left) + rob(root->right->right);  // 跳过root->right
        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right);  // 考虑root的左右孩子
        umap[root] = max(val1, val2);                   // umap记录一下结果
        return max(val1, val2);
    }
};
```

2、记录当前节点的状态

**可以使用一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。**

- 递归三部曲+动归五部曲

dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。

推导：

<img src="assets/image-20210513115054253.png" alt="image-20210513115054253" style="zoom: 50%;" />

```c
class Solution {
public:
    int rob(TreeNode *root)
    {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }  // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode *cur)
    {
        if (cur == NULL)
            return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);   
        // 偷cur
        int val1 = cur->val + left[0] + right[0]; 
        // 不偷cur
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```

- 时间复杂度：O(n) 每个节点只遍历了一次

- 空间复杂度：O(logn) 算上递推系统栈的空间

## 股票系列

### 目录导航

<img src="assets/image-20210514105123595.png" alt="image-20210514105123595" style="zoom:67%;" />

### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)



给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

---

要点：**只买卖一次**

方法一、贪心

遍历到下标i时，买入值取i之前的最低值，取到买入值后计算最高的卖出值

```c
class Solution {
public:
    int maxProfit(vector<int> &prices)
    {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);              // 取最左最小价格
            result = max(result, prices[i] - low);  // 直接取最大区间利润
        }
        return result;
    }
};
```

方法二、动态规划

1.确定dp数组以及下标的含义

  `dp[i][0] `表示第i天持有股票所得最多现金 ,其实一开始现金是0，那么假如第i天买入股票现金就是 -prices[i];

`dp[i][1]` 表示第i天不持有股票所得最多现金

2. 确定递推公式

  如果第i天持有股票即`dp[i][0]`， 那么可以由两个状态推出来：

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
- 第i天买入股票，所得现金就是买入今天的股票后所得现金即：`-prices[i]`,因为股票全程只能买卖一次

  那么`dp[i][0]`应该选所得现金最大的，所以`dp[i][0] = max(dp[i - 1][0], -prices[i])`;

  如果第i天不持有股票即`dp[i][1]`， 也可以由两个状态推出来：

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
- 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

  同样`dp[i][1]`取最大的，`dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])`;

3. dp数组如何初始化

  `dp[0][0]`表示第0天持有股票,`dp[0][0] -= prices[0]`;

`dp[0][1]`表示第0天不持有股票，所以`dp[0][1] = 0`;

4. 确定遍历顺序

5. 举例推导dp数组

  以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：

<img src="assets/image-20210513143234864.png" alt="image-20210513143234864" style="zoom:50%;" />

**`dp[5][1]`就是最终结果,因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！**

```c
// 版本一
class Solution {
public:
    int maxProfit(vector<int> &prices)
    {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```

从递推公式可以看出，`dp[i]`只是依赖于`dp[i - 1]`的状态。那么我们只需要记录 当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间，代码如下：

```c
// 版本二
class Solution {
public:
    int maxProfit(vector<int> &prices)
    {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2));  // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```

### [122.买卖股票的最佳时机II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

题目链接：

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

---

**要点：可以买卖多次**

方法一、贪心算法

收集每天的正利润便可，代码如下：

```c
class Solution {
public:
    int maxProfit(vector<int> &prices)
    {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```

方法二、动态规划

  `dp[i][0] `表示第i天持有股票所得最多现金 ;`dp[i][1]` 表示第i天不持有股票所得最多现金

本题和[121. 买卖股票的最佳时机](https://mp.weixin.qq.com/s/keWo5qYJY4zmHn3amfXdfQ)的唯一区别本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）

```c
class Solution {
public:
    int maxProfit(vector<int> &prices)
    {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方，所持有的现金可能有之前买卖过的利润。
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

### [123.买卖股票的最佳时机III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。

---

**要点：至多买卖两次**

关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。

*动规五部曲，分析如下：*

1. 确定dp数组以及下标的含义

一天一共就有五个状态，

0. 没有操作

1. 第一次买入
2. 第一次卖出
3. 第二次买入
4. 第二次卖出

`dp[i][j]`中 i表示第i天，j为 [0 - 4] 五个状态，`dp[i][j]`表示第i天状态j所剩最大现金。

2. 确定递推公式

`dp[i][1]`，**表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区**。

达到`dp[i][1]`状态，有两个具体操作：

- 操作一：第i天买入股票了，那么`dp[i][1] = dp[i-1][0] - prices[i]`
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：`dp[i][1] = dp[i - 1][1]`

一定是选最大的，所以 `dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);`

同理`dp[i][2]`也有两个操作：

- 操作一：第i天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：`dp[i][2] = dp[i - 1][2]`

所以`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`

同理可推出剩下状态部分：

```c
dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
```

3. dp数组如何初始化

第0天没有操作，这个最容易想到，就是0，即：`dp[0][0] = 0;`

第0天做第一次买入的操作，`dp[0][1] = -prices[0];`

从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。所以`dp[0][2] = 0;`

第0天第二次买入操作，现在手头上没有现金，只要买入，现金就做相应的减少。初始化为：`dp[0][3] = -prices[0];`

同理第二次卖出初始化`dp[0][4] = 0;`

4. 确定遍历顺序:从前到后

5. 举例推导dp数组

而两次卖出的状态现金最大一定是最后一次卖出。

```c
// 版本一
class Solution {
public:
    int maxProfit(vector<int> &prices)
    {
        if (prices.size() == 0)
            return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```

### [188.买卖股票的最佳时机IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。

示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。  

---

**要点：最多买卖K次**

相对于上一道[动态规划：123.买卖股票的最佳时机III](https://mp.weixin.qq.com/s/Sbs157mlVDtAR0gbLpdKzg)，本题需要通过前两次的交易，来类比前k次的交易

*动规五部曲，分析如下：*

* 确定dp数组以及下标的含义

使用二维数组 `dp[i][j]` ：第i天的状态为j，所剩下的最大现金是`dp[i][j]`

j的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

**大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入**。

```c
class Solution {
public:
    int maxProfit(int k, vector<int> &prices)
    {
        if (prices.size() == 0)
            return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1; i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

* 有的解法是定义一个三维数组`dp[i][j][k]`，第i天，第j次买卖，k表示买还是卖的状态，从定义上来讲是比较直观。

### [309.最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

题目链接：

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

---

**要点：买卖多次，卖出有一天冷冻期**



相对于[动态规划：122.买卖股票的最佳时机II](https://mp.weixin.qq.com/s/d4TRWFuhaY83HPa6t5ZL-w)，本题加上了一个冷冻期

1. 确定dp数组以及下标的含义

`dp[i][j]`，第i天状态为j，所剩的最多现金为`dp[i][j]`。

具体可以区分出如下四个状态：

- 状态0：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
- 卖出股票状态，这里就有两种卖出股票状态
  - 状态1：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
  - 状态2：今天卖出了股票
- 状态3：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

j的状态为：

- 0：状态0
- 1：状态1
- 2：状态2
- 3：状态3

**注意这里的每一个状态，例如状态0，是买入股票状态并不是说今天已经就买入股票，而是说保存买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态**。

最后结果去是 状态1，状态2，和状态3的最大值

```c
class Solution {
public:
    int maxProfit(vector<int> &prices)
    {
        int n = prices.size();
        if (n == 0)
            return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0];
        // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```

### [714.买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)



题目链接：

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8

解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

---

* 要点：买卖多次，每次有手续费

相对于[动态规划：122.买卖股票的最佳时机II](https://mp.weixin.qq.com/s/d4TRWFuhaY83HPa6t5ZL-w)，本题只需要在计算买出操作的时候减去手续费就可以了，代码几乎是一样的。

  `dp[i][0] `表示第i天持有股票所得最多现金 ;`dp[i][1]` 表示第i天不持有股票所得最多现金

```c
class Solution {
public:
    int maxProfit(vector<int> &prices, int fee)
    {
        //  `dp[i][0] `表示第i天持有股票所得最多现金 ;`dp[i][1]` 表示第i天不持有股票所得最多现金
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = -prices[0] - fee;  // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i] - fee);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[n - 1][1];
    }
};
```

## 子序列系列

### 目录导航

<img src="assets/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732fe58aa8e68081e8a784e588922de5ad90e5ba8fe58897e997aee9a298e680bbe7bb932e6a7067" alt="img" style="zoom:50%;" />

### 总结

**对于两个字符串求子序列的问题，都是用两个指针`i`和`j`分别在两个字符串上移动，大概率是动态规划思路**。

由于要考虑空字符串，当题目涉及两个数组时，`dp[i][j]`一般定义为s1的[0,i-1]和s2的[0,j-1]子序列进行比较，目的是为了方便dp数组的初始化。

### 子序列(不连续)

注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。

#### 300.最长递增子序列LIS

题目链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/

最长递增子序列（Longest Increasing Subsequence，简写 LIS）

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4

示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1  提示：

- 1 <= nums.length <= 2500
- -10^4 <= nums[i] <= 104

---

**dp[i]表示[0,i]坐标的最长上升子序列**。

位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

所以：`if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);`

```c
class Solution {
public:
    int lengthOfLIS(vector<int> &nums)
    {
        if (nums.size() <= 1)
            return nums.size();
        vector<int> dp(nums.size(), 1); //int[] dp = new int[nums.length];  Arrays.fill(dp, 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result)
                result = dp[i];  // 取长的子序列
        }
        return result;
    }
};
```

方法二、二分查找法

省略，没有要掌握吧。

#### 1143.最长公共子序列LCS

最长公共子序列（Longest Common Subsequence，简称 LCS）

给定两个字符串 text1 和 text2，返回这两个字符串的**最长公共子序列的长度。**

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:

输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。

示例 2:
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。

示例 3:
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。

提示:

- 1 <= text1.length <= 1000
- 1 <= text2.length <= 1000 输入的字符串只含有小写英文字符。

---

本题和[动态规划：718. 最长重复子数组](https://mp.weixin.qq.com/s/U5WaWqBwdoxzQDotOdWqZg)区别在于这里不要求是连续的了，但要有相对顺序

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：**长度为[0, i - 1]的字符串text1**与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`

2. 确定递推公式

主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同

如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1;`

如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。

即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);`

3. dp数组初始化

dp初始化为0即可。

```c
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2)
    {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```



#### 1035.不相交的线

我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。

现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。

以这种方法绘制线条，并返回我们可以绘制的最大连线数。

<img src="assets/image-20210514143926663.png" alt="image-20210514143926663" style="zoom:50%;" />

---

直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 本题**其实就是求两个字符串的最长公共子序列的长度！**那么本题就和我们刚刚讲过的这道题目[动态规划：1143.最长公共子序列](https://mp.weixin.qq.com/s/Qq0q4HaE4TyasCTj2WGFOg)就是一样一样的了。

### 子序列（连续）

**滑动窗口算法就是专门处理子串/子数组问题的，但是分析题意的话不好用滑动窗口算法去解决，取而代之的是贪心算法更好去解决。**

**概括来说：不连续递增子序列的跟前0-i 个状态有关，连续递增的子序列只跟前一个状态有关**

#### 674. 最长连续递增序列

题目链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。

示例 2： 输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。  提示：

- 0 <= nums.length <= 10^4

- -10^9 <= nums[i] <= 10^9

---



方法一、动态规划

dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。

如果 nums[i + 1] > nums[i]，dp[i + 1] = dp[i] + 1;

本题相对于昨天的[动态规划：300.最长递增子序列](https://mp.weixin.qq.com/s/f8nLO3JGfgriXep_gJQpqQ)最大的区别在于“连续”。

```c
class Solution {
public:
    int findLengthOfLCIS(vector<int> &nums)
    {
        if (nums.size() == 0)
            return 0;
        int result = 1;
        vector<int> dp(nums.size(), 1);
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) {  // 连续记录
                dp[i + 1] = dp[i] + 1;
            }
            if (dp[i + 1] > result)
                result = dp[i + 1];
        }
        return result;
    }
};
```

方法二、贪心

这道题目也可以用贪心来做，也就是遇到nums[i + 1] > nums[i]的情况，count就++，否则count为1，记录count的最大值就可以了。

代码如下：

```c
class Solution {
public:
    int findLengthOfLCIS(vector<int> &nums)
    {
        if (nums.size() == 0)
            return 0;
        int result = 1;  // 连续子序列最少也是1
        int count = 1;
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) {  // 连续记录
                count++;
            } else {
                // 不连续，count从头开始
                count = 1;
            }
            if (count > result)
                result = count;
        }
        return result;
    }
};
```

#### 53. 最大子序和

题目地址：https://leetcode-cn.com/problems/maximum-subarray/

给定一个整数数组 nums ，找到一个具有最大和的连续子数组**（子数组最少包含一个元素）**，返回其最大和。

示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

---

方法一、动态规划

dp[i]：**以下标i结尾的数组的最大连续子数组和为dp[i]。**

`dp[i] = max(dp[i - 1] + nums[i], nums[i]);`   

`dp[i - 1] + nums[i]`表示选择前面的最大连续累积和，`nums[i]`表示不选择前面的最大连续累积和，从当前数开始累加

`dp[0] = nums[0]。`

```c

class Solution {
public:
    int maxSubArray(vector<int> &nums)
    {
        if (nums.size() == 0)
            return 0;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int result = dp[0];
            /*  如果没有子数组最少包含一个元素的限制
                max(dp[i-1],0)表示是否选择前面的最大连续累积和
                max(0,nums[i])表示是否选择当前元素
	            dp[i] = max(max(dp[i-1],0) + max(0,nums[i]))
            */
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(max(dp[i - 1],0) + nums[i]);  // 由dp数组的定义可知，一定是选择nums[i]的
            if (dp[i] > result)
                result = dp[i];  // result 保存dp[i]的最大值
        }
        return result;
    }
};
```

方法二、贪心

  - 局部最优：当连续和为负时立刻放弃，从下一个数开始累加连续和；全局最优：选取最大的连续和

  ```c++
  class Solution {
  public:
      int maxSubArray(vector<int> &nums)
      {
          int result = INT32_MIN;
          int count = 0;
          for (int i = 0; i < nums.size(); i++) {
              count  = count+ nums[i];
              if (count > result) {  // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                  result = count;
              }
              if (count <= 0)
                  count = 0;  // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
          }
          return result;
      }
  };
  ```



#### 718. 最长重复子数组

题目链接：https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。  提示：

- 1 <= len(A), len(B) <= 1000
- 0 <= A[i], B[i] < 100

---

**注意题目中说的子数组，其实就是连续子序列。**这种问题动规最拿手

`dp[i][j] `：**以下标i - 1为结尾的A**，和以下标j - 1为结尾的B，最长重复子数组长度为`dp[i][j]。`

双层循环找出所有的 i, j 组合，时间复杂度 $O(m * n)$，其中 m 和 n分别为 A 和 B 的 ⻓度。

当A[i - 1] 和B[j - 1]相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1`;

否则，`dp[i][j] = 0`

循环过程记录最⼤值即可。

<img src="assets/image-20210514142111646.png" alt="image-20210514142111646" style="zoom:50%;" />

```c
class Solution {
public:
    int findLength(vector<int> &A, vector<int> &B)
    {
        vector<vector<int>> dp(A.size() + 1, vector<int>(B.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= A.size(); i++) {
            for (int j = 1; j <= B.size(); j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result)
                    result = dp[i][j];
            }
        }
        return result;
    }
};
```



### 编辑距离

#### [392.判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

题目链接：

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

示例 1： 输入：s = "abc", t = "ahbgdc" 输出：true

示例 2： 输入：s = "axc", t = "ahbgdc" 输出：false

---

**解法一**、1143.最长公共子序列的变形题，dp定义：最长公共子序列为`dp[i][j]`

```c
1.先求得最长公共子序列
2.判断dp[text1.size()][text2.size()] == s.length()即可
```

**解法二**、编辑距离，dp定义：相同子序列的长度为`dp[i][j]`

这道题应该算是编辑距离的入门题目，因为只需要计算删除的情况，不用考虑增加和替换的情况。

动态规划五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j] `表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t可以随便删除元素，相同子序列的长度为`dp[i][j]`**。

2. 确定递推公式

`if (s[i - 1] == t[j - 1])`，那么`dp[i][j] = dp[i - 1][j - 1] + 1;`，因为找到了一个相同的字符，相同子序列长度自然要在`dp[i-1][j-1]`的基础上加1

 `if (s[i - 1] != t[j - 1])`，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么`dp[i][j] `的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：`dp[i][j] = dp[i][j - 1];`

3. dp数组如何初始化

`从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，所以dp[0][0]和dp[i][0]是一定要初始化的。`

这里大家已经可以发现，在定义`dp[i][j]`含义的时候为什么要**表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为`dp[i][j]`**,因为这样的定义在dp二维矩阵中可以留出初始化的区间

<img src="assets/image-20210514175230810.png" alt="image-20210514175230810" style="zoom:50%;" />


4. 确定遍历顺序

从递推公式可以看出`dp[i][j]`都是依赖于`dp[i - 1][j - 1] 和 dp[i][j - 1]`，那么遍历顺序也应该是从上到下，从左到右

<img src="assets/image-20210514175323058.png" alt="image-20210514175323058" style="zoom: 33%;" />

5. 举例推导dp数组

如果`dp[s.size()][t.size()]` 与 字符串s的长度相同说明：s与t的相同子序列就是s，那么s 就是 t 的子序列。

```c
class Solution {
public:
    bool isSubsequence(string s, string t)
    {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = dp[i][j - 1];
            }
        }
        if (dp[s.size()][t.size()] == s.size())
            return true;
        return false;
    }
};
```

#### [115.不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

![image-20210708113639047](assets/image-20210708113639047.png)

这道题目如果不是子序列，而是要求连续序列的，那就可以考虑用KMP。

但相对于刚讲过的[动态规划：392.判断子序列](https://mp.weixin.qq.com/s/2pjT4B4fjfOx5iB6N6xyng)就有难度了，这道题目双指针法可就做不了了，来看看动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：**以i-1为结尾的s可以随便删除元素，出现以j-1为结尾的t的个数为`dp[i][j]`。**

2. 确定递推公式

这一类问题，基本是要分析两种情况

- s[i - 1] 与 t[j - 1]相等
- s[i - 1] 与 t[j - 1] 不相等

当s[i - 1] 与 t[j - 1]相等时，`dp[i][j]`可以有两部分组成。

一部分是用s[i - 1]来匹配，那么个数为`dp[i - 1][j - 1]`。

一部分是不用s[i - 1]来匹配，个数为`dp[i - 1][j]`。

这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。

例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。

当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。

所以当s[i - 1] 与 t[j - 1]相等时，`dp[i][j]` = `dp[i - 1][j - 1]` + `dp[i - 1][j]`;

当s[i - 1] 与 t[j - 1]不相等时，`dp[i][j]`只有一部分组成，不用s[i - 1]来匹配，即：`dp[i - 1][j]`

所以递推公式为：`dp[i][j]` = `dp[i - 1][j]`;

3. dp数组如何初始化

`dp[i][0]` 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。

那么`dp[i][0]`一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。

`dp[0][j]`：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。

那么`dp[0][j]`一定都是0，s如论如何也变成不了t。

最后就要看一个特殊位置了，即：`dp[0][0]` 应该是多少。

`dp[0][0]`应该是1，空字符串s，可以删除0个元素，变成空字符串t。

初始化分析完毕，代码如下：

```c
vector<vector<long long>> dp(s.size() + 1, vector<long long>(t.size() + 1));
for (int i = 0; i <= s.size(); i++)
    dp[i][0] = 1;
for (int j = 1; j <= t.size(); j++)
    dp[0][j] = 0;
```

4. 确定遍历顺序

遍历的时候一定是从上到下，从左到右

5. 举例推导dp数组

以s："baegg"，t："bag"为例，推导dp数组状态如下：

<img src="assets/image-20210517140805222.png" alt="image-20210517140805222" style="zoom:50%;" />

```c
class Solution {
public:
    int numDistinct(string s, string t)
    {
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));
        for (int i = 0; i < s.size(); i++)
            dp[i][0] = 1;
        for (int j = 1; j < t.size(); j++)
            dp[0][j] = 0;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

#### 583. 两个字符串的删除操作

题目链接：https://leetcode-cn.com/problems/delete-operation-for-two-strings/

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

示例：

输入: "sea", "eat"
输出: 2 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"

---

**方法一、LCS题目的变形**

题目让我们计算将两个字符串变得相同的最少删除次数，那我们可以思考一下，最后这两个字符串会被删成什么样子？

删除的结果不就是它俩的最长公共子序列嘛！

那么，要计算删除的次数，就可以通过最长公共子序列的长度推导出来：

```c
int minDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    // 复用前文计算 lcs 长度的函数
    int lcs = longestCommonSubsequence(s1, s2);
    return m - lcs + n - lcs;
}
```



---

**方法二、根据题意定义dp**

本题和[动态规划：115.不同的子序列](https://mp.weixin.qq.com/s/1SULY2XVSROtk_hsoVLu8A)相比，其实就是两个字符串可以都可以删除了，情况虽说复杂一些，但整体思路是不变的。

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。

2. 确定递推公式

- 当word1[i - 1] 与 word2[j - 1]相同的时候
- 当word1[i - 1] 与 word2[j - 1]不相同的时候

当word1[i - 1] 与 word2[j - 1]相同的时候，`dp[i][j]` = `dp[i - 1][j - 1]`;

> 这里我的理解是这样，当word1[i - 1]  ==  word2[j - 1]时，可以选择匹配，也可以选择删掉这两个单词其中一个进行匹配，即
>
> `dp[i][j] = min({dp[i-1][j-1], dp[i - 1][j] + 1, dp[i][j - 1] + 1})`
>
> 但是题目是需要求操作的最小步数，所以肯定是直接匹配得到的步数最小，即`dp[i][j]` = `dp[i - 1][j - 1]`;
>
> leetcode提交结果也验证了我这一点

当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：

情况一：删word1[i - 1]，最少操作次数为`dp[i - 1][j]` + 1

情况二：删word2[j - 1]，最少操作次数为`dp[i][j - 1]` + 1

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：

` dp[i][j] = min({dp[i - 1][j] + 1, dp[i][j - 1] + 1});`

3. dp数组如何初始化

`dp[i][0]`：word2为空字符串，以i-1为结尾的字符串word2要删除多少个元素，才能和word1相同呢，很明显`dp[i][0] `= i。

`dp[0][j]`的话同理，所以代码如下：

```c
vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
for (int i = 0; i <= word1.size(); i++)
    dp[i][0] = i;
for (int j = 0; j <= word2.size(); j++)
    dp[0][j] = j;
```

4. 确定遍历顺序

从上到下，从左到右

5. 举例推导dp数组

```c
class Solution {
public:
    int minDistance(string word1, string word2)
    {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i <= word1.size(); i++)
            dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++)
            dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

![image-20210708142224234](assets/image-20210708142224234.png)

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j]` 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为`dp[i][j]`**。

2. 确定递推公式

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```c
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```

也就是如上四种情况。

`if (word1[i - 1] == word2[j - 1]) `那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j]` = `dp[i - 1][j - 1]`;

解释：回顾上面讲过的`dp[i][j]`的定义，word1[i - 1] 与 word2[j - 1]相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串word2的最近编辑距离`dp[i - 1][j - 1]` 就是 `dp[i][j]`了。

`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

![image-20210708151221316](assets/image-20210708151221316.png)

操作一：word2删掉一个单词，此时编辑距离 `dp[i][j] = dp[i][j - 1] + 1`；

操作二：word1删掉一个单词，此时编辑距离 `dp[i][j] = dp[i - 1][j] + 1`；

操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。

即即 `dp[i][j]` = `dp[i - 1][j - 1]` + 1;

综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：`dp[i][j]` = min({`dp[i - 1][j - 1]`, `dp[i - 1][j]`, `dp[i][j - 1]`}) + 1;

3. dp数组如何初始化

`dp[i][0]` ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为`dp[i][0]`。

那么`dp[i][0]`就应该是i，对word1里的元素全部做删除操作，即：`dp[i][0]` = i;

同理`dp[0][j]` = j;

4. 确定遍历顺序

从左到右从上到下

5. 举例推导dp数组

```c
class Solution {
public:
    int minDistance(string word1, string word2)
    {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++)
            dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++)
            dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### 

## 练习题目

### 最小路径和

#### 64. 最小路径和

![image-20210709142140706](assets/image-20210709142140706.png)

思路简单，和62.不同路径 基本一样，dp值加上数组数值即可,没有什么新东西需要学习。

dp数组定义：`dp[i][j]`表示从[0,0]走到[i,j]的最小路径和。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        // dp[i][j]表示从[0,0]走到[i,j]的最小路径和
        int row = grid.length;
        int col = grid[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < row; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < col; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
                System.out.println("i="+i+",j="+j+",dp="+dp[i][j]);
            }
        }
        return dp[row - 1][col - 1];
    }
}
```

#### [931. 下降路径最小和](https://leetcode-cn.com/problems/minimum-falling-path-sum/)

![image-20210712102339018](assets/image-20210712102339018.png)

简单，`dp[i][j]=min(dp[i−1][j−1],dp[i−1][j],dp[i−1][j+1])+A[i][j]`,主要要学习的是对边界条件的处理。

对于这种需要考虑边界的情况，我习惯在原数组的基础上套一层"**壳**"，这样状态转移的时候就不用特判边界了。
![image.png](assets/b789f420bb3b768532045632118b3bbcfc483fee7e1aa3642ef8f6f727e33778-image.png)

直接给出代码：

```java
class Solution {
    public int minFallingPathSum(int[][] A) {
        // 设dp[i][j]为到i, j位置的最小路径和
        int len = A.length;
        int[][] dp = new int[len + 1][len + 2];

        // 套壳处理
        for (int i = 0; i < len + 1; i++) {
            dp[i][0] = Integer.MAX_VALUE;
            dp[i][len + 1] = Integer.MAX_VALUE;
        }
        for (int j = 0; j < len + 2; j++) {
            dp[0][j] = 0;
        }

        int ans = Integer.MAX_VALUE;
        for (int i = 1; i < len + 1; i++) {
            for (int j = 1; j < len + 1; j++) {
                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i - 1][j + 1]) + A[i - 1][j - 1];
            }
        }
        for (int i = 1; i < len + 1; i++) {
            ans = Math.min(ans, dp[len][i]);
        }
        return ans;
    }
}
```



#### 174. 地下城游戏

![image-20210709171945802](assets/image-20210709171945802.png)

62.不同路径题目的变形，中规中矩吧

`p[i][j]`表示从进入到`[i][j]`之前所需的最少健康点数.

```java
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        // dp[i][j]表示从进入到[i][j]之前所需的最少健康点数
        int row = dungeon.length;
        int col = dungeon[0].length;
        int[][] dp = new int[row + 1][col + 1];
        // 初始化
        dp[row][col - 1] = 1;
        dp[row - 1][col] = 1;
        for (int i = row - 1; i >= 0; i--) {
            dp[i][col - 1] = Math.max(dp[i + 1][col - 1] - dungeon[i][col - 1], 1);
        }
        for (int j = col - 1; j >= 0; j--) {
            dp[row - 1][j] = Math.max(dp[row - 1][j + 1] - dungeon[row - 1][j], 1);
        }
        // 状态转移
        for (int i = row - 2; i >= 0; i--) {
            for (int j = col - 2; j >= 0; j--) {
                dp[i][j] = Math.max(Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1);
                System.out.println(String.format("i=%d,j=%d,dp=%d", i, j, dp[i][j]));
            }
        }
        return dp[0][0];
    }
}
```

### 未归类

#### [514. 自由之路](https://leetcode-cn.com/problems/freedom-trail/)

![image-20210709172541716](assets/image-20210709172541716.png)

定义 `dp[i][j]` 表示拼写出key 的第 i 个字符,ring 的第 j个字符与12:00 方向对齐的最少步数（下标均从 0开始）。

显然，只有当字符串ring 的第 j 个字符需要和key 的第 i 个字符相同时才能拼写出 key 的第 i字符，因此对于key 的第 i 个字符，需要考虑计算的 ring 的第 j 个字符只有key[i] 在ring 中出现的下标集合。我们对每个字符维护一个位置数组 pos[i]，表示字符 i在 ring 中出现的位置集合，用来加速计算转移的过程。
对于状态 `dp[i][j]`，需要枚举上一次与 12:00 方向对齐的位置 k，因此可以列出如下的转移方程：

![image-20210709175736415](assets/image-20210709175736415.png)



最后答案即为$min_{j=0}^{n-1}\{\textit{dp}[m-1][j]\}$.

```java
class Solution {
    public int findRotateSteps(String ring, String key) {
        int n = ring.length(), m = key.length();
        List<Integer>[] pos = new List[26];
        for (int i = 0; i < 26; ++i) {
            pos[i] = new ArrayList<Integer>();
        }
        for (int i = 0; i < n; ++i) {
            pos[ring.charAt(i) - 'a'].add(i);
        }
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; ++i) {
            Arrays.fill(dp[i], 0x3f3f3f);
        }
        for (int i : pos[key.charAt(0) - 'a']) {
            dp[0][i] = Math.min(i, n - i) + 1;
        }
        for (int i = 1; i < m; ++i) {
            for (int j : pos[key.charAt(i) - 'a']) {
                for (int k : pos[key.charAt(i - 1) - 'a']) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + Math.min(Math.abs(j - k), n - Math.abs(j - k)) + 1);
                }
            }
        }
        return Arrays.stream(dp[m - 1]).min().getAsInt();
    }
}
0x3f3f3f3f性质：
1、0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），可以作为无穷大使用而不致出现数据大于无穷大的情形。
2、0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。
3、memset(a,0x3f,sizeof(a))
```

#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)



![image-20210710142923055](assets/image-20210710142923055.png)

![image-20210710142941484](assets/image-20210710142941484.png)

**选择从右往左扫描**

- 星号的前面肯定有一个字符，星号也只影响这一个字符，它就像一个拷贝器。

- s、p 串是否匹配，取决于：最右端是否匹配、剩余的子串是否匹配。
- 只是最右端可能是特殊符号，需要分情况讨论而已。

**情况1：s[i-1]和 p[j-1] 是匹配的**

- 最右端的字符是匹配的，那么，大问题的答案 = 剩余子串是否匹配。
<img src="assets/f817caaa40b0c39fc3ddabfa1383a8218ab364b8e49b30e5ce85cb30a3cdc503-image.png" alt="image.png" style="zoom: 33%;" />

**情况2：s[i-1] 和 p[j-1]是不匹配的**

* 右端不匹配，还不能判死刑——可能是 p[j-1]为星号造成的不匹配，星号不是真实字符，它不匹配不算数。
* 如果 p[j-1]p[j−1] 不是星号，那就真的不匹配了。

<img src="assets/fe763378879a0a52e9f17171e3bc1db18cfc83bf59f14efcd31ec9edb37adfac-image.png" alt="image.png" style="zoom:33%;" />

**情况2.1：`p[j-1] != "*",那么dp[i][j]=false;`**

**情况2.2：p[j−1]=="∗"，且 s[i-1]和 p[j-2]匹配**

p[j−1] 是星号，并且 s[i-1] 和 p[j-2] 匹配，要考虑三种情况：
p[j-1] 星号可以让 p[j−2] 在 p 串中消失、出现 1 次、出现 >=2 次。
只要其中一种使得剩余子串能匹配，那就能匹配，见下图 a1、a2、a3。

<img src="assets/a1cc0caf806f7d7f5419d820e0e7be7a364c96656a98ca4d7f351661d6a62aa6-image.png" alt="image.png" style="zoom:40%;" />

* a3 情况：假设 s 的右端是一个 a，p 的右端是 a * ，* 让 a 重复 >= 2 次
  * 星号不是真实字符，s、p是否匹配，要看 s 去掉末尾的 a，p 去掉末尾一个 a，剩下的是否匹配。
  * 星号拷贝了 >=2 个 a，拿掉一个，剩下 >=1 个a，p 末端依旧是 a* 没变。
  * s 末尾的 a 被抵消了，继续考察 s(0,i-2) 和 p(0,i-1) 是否匹配。

**情况2.3：p[j−1]=="∗"，但 s[i-1] 和 p[j-2] 不匹配**

s[i−1] 和 p[j−2]不匹配，还有救，p[j−1] 星号可以干掉p[j−2]，继续考察 s(0,i−1) 和 p(0,j-3)。

<img src="assets/dabf2195c460052e2719340de8f2d22f791694d4443424478201be3b5d601fe1-image.png" alt="image.png" style="zoom:33%;" />

**base case**

* p为空串，s不为空串，肯定不匹配。
* s为空串，但p不为空串，要想匹配，只可能是右端是星号，它干掉一个字符后，把 p 变为空串。
* s、p都为空串，肯定匹配。



```java
class Solution {
    public boolean isMatch(String s, String p) {
        char[] cs = s.toCharArray();
        char[] cp = p.toCharArray();

        // dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
        boolean[][] dp = new boolean[cs.length + 1][cp.length + 1];

        // 初期值
        // s为空，p为空，能匹配上
        dp[0][0] = true;
        // p为空，s不为空，必为false(boolean数组默认值为false，无需处理)

        // s为空，p不为空，由于*可以匹配0个字符，所以有可能为true
        for (int j = 1; j <= cp.length; j++) {
            if (cp[j - 1] == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }

        // 填格子
        for (int i = 1; i <= cs.length; i++) {
            for (int j = 1; j <= cp.length; j++) {
                // 文本串和模式串末位字符能匹配上
                if (cs[i - 1] == cp[j - 1] || cp[j - 1] == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (cp[j - 1] == '*') { // 模式串末位是*
                    // 模式串*的前一个字符能够跟文本串的末位匹配上
                    if (cs[i - 1] == cp[j - 2] || cp[j - 2] == '.') {
                        dp[i][j] = dp[i][j - 2] // *匹配0次的情况
                                || dp[i - 1][j - 2] // *匹配1次的情况
                                || dp[i - 1][j]; // *匹配多次的情况
                    } else { // 模式串*的前一个字符不能够跟文本串的末位匹配
                        dp[i][j] = dp[i][j - 2]; // *只能匹配0次
                    }
                }
            }
        }
        return dp[cs.length][cp.length];
    }
}

```

#### [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

![image-20210710145011068](assets/image-20210710145011068.png)

只看了第一个链接，还没看懂

https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/hard/887.super-egg-drop

https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-4/gao-lou-reng-ji-dan-wen-ti

https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-4/gao-lou-reng-ji-dan-jin-jie

假如有 2 个鸡蛋，6 层楼。 我们应该先从哪层楼开始扔呢？想了一会，没有什么好的办法。我们来考虑使用暴力的手段。

<img src="assets/007S8ZIlly1gfk793ken5j30zi0fidhu.jpg" alt="img" style="zoom:33%;" /> （图 1. 这种思路是不对的)

既然我不知道先从哪层楼开始扔是最优的，那我就依次模拟从第 1，第 2。。。第 6 层扔。每一层楼丢鸡蛋，都有两种可能，碎或者不碎。由于是最坏的情况，因此我们需要模拟两种情况，并取两种情况中的扔次数的较大值（较大值就是最坏情况）。 然后我们从六种扔法中选择最少次数的即可。

<img src="assets/007S8ZIlly1gfk7a7q9h5j32bo0jutfj.jpg" alt="img" style="zoom: 33%;" />

（图 2. 应该是这样的）

因为我们要求的是**最坏情况**下扔鸡蛋的次数，所以鸡蛋在第 `i` 层楼碎没碎，取决于那种情况的结果**更大**：

```jav
class Solution {
    public int superEggDrop(int k, int n) {

    }
}
```

#### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

![image-20210710162017718](assets/image-20210710162017718.png)



假设这个区间是个开区间，最左边索引 `i`，最右边索引 `j`

DP思路是这样的，就先别管前面是怎么戳的，你只要管这个区间最后一个被戳破的是哪个气球
这最后一个被戳爆的气球就是 `k`

你在 (i,j) 开区间得到的金币可以由 dp[i][k] 和 dp[k][j] 进行转移
 
如果你此刻选择戳爆气球 k，那么你得到的金币数量就是：
 

```php
total
=
dp[i][k]
+
val[i] * val[k] * val[j]
+
dp[k][j]
```


注：val[i] 表示 i 位置气球的数字
然后 (i,k) 和 (k,j) 也都是开区间

作者：xiao-yan-gou
链接：https://leetcode-cn.com/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

https://leetcode-cn.com/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/

```java
public int maxCoins(int[] nums) {
        int length = nums.length;
        int newLength = length + 2;
        // 数组首尾加1，方便计算
        int[] newArry = new int[newLength];
        newArry[0] = 1;
        newArry[length + 1] = 1;
        // 放入新数组中
        for (int i = 0; i < length; i++) {
            newArry[i + 1] = nums[i];
        }
        // 定义dp数组，dp[i][j] 表示区间(i,j)范围内可以获得的最大金币
        // 假设最后一个被戳爆的是第k个气球，那么，dp[i][j] = dp[i][k] + newArray[i]*newArray[k]*newArray[k] + dp[k][j]
        // 也就是说和他两边区间被戳吧气球获得的最大金币有关
        int[][] dp = new int[newLength][newLength];

        // (i,j)区间的范围从3开始，慢慢递增一直到最大(就是newArray的大小)，范围是[3,newLength]，闭区间
        for (int range = 3; range <= newLength; range++) {
            // 区间从左往右移动，进行初始化，也就i移动的范围是[0,newLength - range]，这是闭区间
            for (int i = 0; i <= newLength - range; i++) {
                // 知道i和rang可以确定j
                int j = i + range - 1;
                // 找出(i,j)这个区间内的最大值，就是依次试着去戳破，然后记录最大值
                int maxValue = 0;
                // 在(i,j)区间内尝试依次去戳破气球，并记录每次获得的金币
                for (int k = i + 1; k < j; k++) {
                    // 区间(i,k)区间内戳气球能获得的最大金币
                    int leftRangeValu = dp[i][k];
                    // 区间(k,j)区间内戳气球能获得的最大金币
                    int rightRangeValue = dp[k][j];
                    maxValue = Math.max(maxValue, leftRangeValu + newArry[i] * newArry[k] * newArry[j] + rightRangeValue);
                }
                // 将最大值保存到dp数组中
                dp[i][j] = maxValue;
            }
        }
        return dp[0][length + 1];
    }
```

#### [651.四键键盘](https://leetcode-cn.com/problems/4-keys-keyboard)

![img](assets/6413dee2c83f74205c7f2d5eb0784232429512de.png)

==**如何在 N 次敲击按钮后得到最多的 A？我们穷举呗，每次有对于每次按键，我们可以穷举四种可能，很明显就是一个动态规划问题。**==

**具体到这个问题，对于每次敲击按键，有哪些「选择」是很明显的：4 种**，就是题目中提到的四个按键，分别是 `A`、`C-A`、`C-C`、`C-V`（`Ctrl` 简写为 `C`）。

接下来，思考一下对于这个问题有哪些「状态」？**或者换句话说，我们需要知道什么信息，才能将原问题分解为规模更小的子问题**？

你看我这样定义三个状态行不行：第一个状态是剩余的按键次数，用 `n` 表示；第二个状态是当前屏幕上字符 A 的数量，用 `a_num` 表示；第三个状态是剪切板中字符 A 的数量，用 `copy` 表示。

如此定义「状态」，就可以知道 base case：当剩余次数 `n` 为 0 时，`a_num` 就是我们想要的答案。

结合刚才说的 4 种「选择」，我们可以把这几种选择通过状态转移表示出来：

```php
dp(n - 1, a_num + 1, copy),    # A
解释：按下 A 键，屏幕上加一个字符
同时消耗 1 个操作数

dp(n - 1, a_num + copy, copy), # C-V
解释：按下 C-V 粘贴，剪切板中的字符加入屏幕
同时消耗 1 个操作数

dp(n - 2, a_num, a_num)        # C-A C-C
解释：全选和复制必然是联合使用的，
剪切板中 A 的数量变为屏幕上 A 的数量
同时消耗 2 个操作数
```

这样可以看到问题的规模 `n` 在不断减小，肯定可以到达 `n = 0` 的 base case，所以这个思路是正确的：

```python
def maxA(N: int) -> int:
    # 备忘录
    memo = dict()
    # 对于 (n, a_num, copy) 这个状态，
    # 屏幕上能最终最多能有 dp(n, a_num, copy) 个 A
    def dp(n, a_num, copy):
         # base case
        if n <= 0: return a_num;
        # 避免计算重叠子问题
        if (n, a_num, copy) in memo:
            return memo[(n, a_num, copy)]
		# 几种选择全试一遍，选择最大的结果
        memo[(n, a_num, copy)] = max(
                dp(n - 1, a_num + 1, copy),    # A
                dp(n - 1, a_num + copy, copy), # C-V
                dp(n - 2, a_num, a_num)        # C-A C-C
            )
        return memo[(n, a_num, copy)]
# 可以按 N 次按键，屏幕和剪切板里都还没有 A
    return dp(N, 0, 0)
```

这样优化代码之后，子问题虽然没有重复了，但数目仍然很多，在 LeetCode 提交会超时的。

**我们尝试分析一下这个算法的时间复杂度，就会发现不容易分析。我们可以把这个 dp 函数写成 dp 数组**：

```php
dp[n][a_num][copy]
# 状态的总数（时空复杂度）就是这个三维数组的体积
```

我们知道变量 `n` 最多为 `N`，但是 `a_num` 和 `copy` 最多为多少我们很难计算，复杂度起码也有 O(N^3) 把。所以这个算法并不好，复杂度太高，且已经无法优化了。

这也就说明，我们这样定义「状态」是不太优秀的，下面我们换一种定义 dp 的思路。

* **第二种思路**

**「选择」还是那 4 个，但是这次我们只定义一个「状态」，也就是剩余的敲击次数 `n`。**

**dp表示经过n次按键后得到的最多的A。**

这个算法基于这样一个事实，**最优按键序列一定只有两种情况**：

要么一直按 `A`：A,A,...A（当 N 比较小时）。

要么是这么一个形式：A,A,...C-A,C-C,C-V,C-V,...C-V（当 N 比较大时）。

因为字符数量少（N 比较小）时，`C-A C-C C-V` 这一套操作的代价相对比较高，可能不如一个个按 `A`；而当 N 比较大时，后期 `C-V` 的收获肯定很大。这种情况下整个操作序列大致是：**开头连按几个** **`A`****，然后** **`C-A C-C`** **组合再接若干** **`C-V`****，然后再** **`C-A C-C`** **接着若干** **`C-V`****，循环下去**。

换句话说，最后一次按键要么是 `A` 要么是 `C-V`。明确了这一点，可以通过这两种情况来设计算法：

```js
int[] dp = new int[N + 1];
// 定义：dp[i] 表示 i 次操作后最多能显示多少个 A
for (int i = 0; i <= N; i++) 
    dp[i] = max(
            这次按 A 键，
            这次按 C-V
        )
```

1. 对于「按 `A` 键」这种情况，就是状态 `i - 1` 的屏幕上新增了一个 A 而已，很容易得到结果：

```java
// 按 A 键，就比上次多一个 A 而已
dp[i] = dp[i - 1] + 1;
```

2. 但是，如果要按 `C-V`，还要考虑之前是在哪里 `C-A C-C` 的。

**刚才说了，最优的操作序列一定是** **`C-A C-C`** **接着若干** **`C-V`****，所以我们用一个变量** **`j`** **作为若干** **`C-V`** **的起点**。那么 `j` 之前的 2 个操作就应该是 `C-A C-C` 了：

其中 `j` 变量减 2 是给 `C-A C-C` 留下操作数，看个图就明白了：

![image-20210712091158839](assets/image-20210712091158839.png)

java代码：

```java
public int maxA(int N) {
    int[] dp = new int[N + 1];
    dp[0] = 0;
    for (int i = 1; i <= N; i++) {
        // 按 A 键
        dp[i] = dp[i - 1] + 1;
        for (int j = 2; j < i; j++) {
            //  dp[j-2]之后 全选 & 复制，连续粘贴 i - j 次
            // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A
            dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));
        }
    }
    // N 次按键之后最多有几个 A
    return dp[N];
}
```

* 两种思路比较

动态规划难就难在寻找状态转移，不同的定义可以产生不同的状态转移逻辑，虽然最后都能得到正确的结果，但是效率可能有巨大的差异。

回顾第一种解法，重叠子问题已经消除了，但是效率还是低，到底低在哪里呢？抽象出递归框架：



```java
def dp(n, a_num, copy):
    dp(n - 1, a_num + 1, copy),    # A
    dp(n - 1, a_num + copy, copy), # C-V
    dp(n - 2, a_num, a_num)        # C-A C-C
```

看这个穷举逻辑，是有可能出现这样的操作序列 `C-A C-C，C-A C-C...` 或者 `C-V,C-V,...`。然这种操作序列的结果不是最优的，但是我们并没有想办法规避这些情况的发生，从而增加了很多没必要的子问题计算。

回顾第二种解法，我们稍加思考就能想到，最优的序列应该是这种形式：`A,A..C-A,C-C,C-V,C-V..C-A,C-C,C-V..`。

根据这个事实，我们重新定义了状态，重新寻找了状态转移，从逻辑上减少了无效的子问题个数，从而提高了算法的效率。



### 最长公共子序列LCS

#### [712. 两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

![image-20210708162053317](assets/image-20210708162053317.png)



**解法一、LCS题目扩展**

LCS题目是查找最长公共子序列长度，其`dp[i][j]`定义为：**长度为[0, i - 1]的字符串text1**与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`

本题将`dp[i][j]`定义为查找`s1[0,i-1]`子串和`s2[0,j-1]`ASCII码累加值最大的最长公共子序列，最后需要删掉的元素自然就是ASCII值累加和最小的。

直接给出代码：

```java
class Solution {
public:
    int minimumDeleteSum(string text1, string text2)
    {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + text1[i - 1];
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        int sum1 = 0;
        int sum2 = 0;
        for (auto ch : text1) {
            sum1 += ch;
        }
        for (auto ch : text2) {
            sum2 += ch;
        }
        int common = dp[text1.size()][text2.size()];
        return sum1 + sum2 - 2 * common;
    }
};
```

**解法二、根据题意定义dp**

1.dp定义

将`dp[i][j]`定义为查找`s1[0,i-1]`子串和`s2[0,j-1]`子串相等需要删除的ASCII值的最小和。

2.确定递推公式

如果有 `s1[i] == s2[j]`，那么当前位置的两个字符相同，它们不需要被删除，`dp[i][j] = dp[i - 1][j  - 1]`

如果 `s1[i] != s2[j]`，那么我们至少要删除 s1[i] 和 s2[j] 两个字符中的一个，因此状态转移方程为

`dp[i][j] = min(dp[i  - 1][j] + s1[i-1], dp[i][j - 1] + s2[j-1])`

3.初始化

`dp[0][0]`表示s1空串和s2空串相等需要删除的ASCII值的最小和，`dp[0][0] = 0`

`dp[0][j]`表示s1空串和`s2[0,j-1]`子串相等需要删除的ASCII值的最小和，因此：

```c
for(int j=1;j<=s2.length();j++){
    dp[0][j] = dp[0][j-1] + s2.charAt(j-1);
}
```

同理，对`dp[i][0]`存在

```c
for(int i = 1;i<s2.length();i++){
    dp[i][0] = dp[i-1][0] + s1.charAt(i-1);
 }
```

4.确定遍历顺序

双for循环，从左到右，从上到下

5.验证

6.代码如下：

```java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        // 将`dp[i][j]`定义为查找`s1[0,i-1]`子串和`s2[0,j-1]`子串相等需要删除的ASCII值的最小和。
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        for (int j = 1; j < s2.length() + 1; j++) {
            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);
        }
        for (int i = 1; i < s1.length() + 1; i++) {
            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);
        }
        for (int i = 1; i < s1.length() + 1; i++) {
            for (int j = 1; j < s2.length() + 1; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));
                }
            }
        }
        return dp[s1.length()][s2.length()];
    }
}
```



#### [354.俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes)

![image-20210525113114190](assets/image-20210525113114190.png)

* LCS变形题目：二维递增子序列

**先对宽度 `w` 进行升序排序，如果遇到 `w` 相同的情况，则按照高度 `h` 降序排序。因为两个宽度相同的信封不能相互包含的，逆序排序保证在 `w` 相同的数对中最多只选取一个。之后把所有的 `h` 作为一个数组，在这个数组上计算 LIS 的长度就是答案。**

```c
// envelopes = [[w, h], [w, h]...]
public int maxEnvelopes(int[][] envelopes) {
    int n = envelopes.length;
    // 按宽度升序排列，如果宽度一样，则按高度降序排列
    Arrays.sort(envelopes, new Comparator<int[]>() 
    {
        @Override
        public int compare(int[] a, int[] b) {
            return a[0] == b[0] ? 
                b[1] - a[1] : a[0] - b[0];
        }
    });
    // 对高度数组寻找 LIS
    int[] height = new int[n];
    for (int i = 0; i < n; i++)
        height[i] = envelopes[i][1];

    return lengthOfLIS(height);
}

    int lengthOfLIS(vector<int> &nums)
    {
        if (nums.size() <= 1)
            return nums.size();
        vector<int> dp(nums.size(), 1); //int[] dp = new int[nums.length];  Arrays.fill(dp, 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result)
                result = dp[i];  // 取长的子序列
        }
        return result;
    }
```





### 加权最短路径

#### [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

![image-20210710101134221](assets/image-20210710101134221.png)

![image-20210710101158479](assets/image-20210710101158479.png)

方法一、动态规划

* 加权最短路径，思路和Dijkstra 算法比较类似

还是按照动归五部曲来分析。

1.dp数组定义

**` dp[i][k]`表示src  k步 之内到达i的最小成本。**

2.确定递推公式

`dp[i][k]`由两部分组成，

第一个坐标轴：经过k-1个中转站到达其他站点v，再由其他站点v直接转i的最小成本`dp[v][k-1]+flight[2]`。

第二个坐标轴：`dp[i][k-1]`表示经过k-1步已经可以到达i的最小成本

dp取它们的最小值即可。

3.dp初始化

遍历flights数组中以src开头的航班，可以得到`dp[i][0]`

4.遍历顺序

采用Dijkstra 算法类似的思想，每次到达k步时，更新所有的站点信息，因此先遍历k再遍历数组。

5.举例

画个图就知道了。

<img src="assets/image-20210710131738029.png" alt="image-20210710131738029" style="zoom:67%;" />

```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        // dp[i][k]是最多经过k个中转站后到达站 i 的最小费用
        int[][] dp = new int[n][K + 1];

        // 循环初始化整个二维数组。
        for(int i = 0; i < n; ++i) Arrays.fill(dp[i], Integer.MAX_VALUE);

        // 利用flights中的信息初始化src可直达的班次
        for(int[] flight : flights) {
            if(flight[0] == src){
                dp[flight[1]][0] = flight[2];
            }
        }

        // 循环初始化数组中dst == src的行
        for(int i = 0; i <= K; i++){
            dp[src][i] = 0;
        }

        //动态规划状态转移方程，开始填表
        //直达的已经初始化了（即k = 0的情况），现在从k = 1 的开始，即只有一个中转站开始
        for(int k = 1; k <= K; k++){
            for(int[] flight : flights){
                // 这里起到visited数组的作用，只有在第k-1迭代中有数值的点才能在此基础上继续更新
                if(dp[flight[0]][k - 1] != Integer.MAX_VALUE){
                    dp[flight[1]][k] = Math.min(dp[flight[1]][k], dp[flight[1]][k-1], dp[flight[0]][k - 1] + flight[2]);
                }
            }
        }
        return dp[dst][K] == Integer.MAX_VALUE? -1: dp[dst][K];
    }
}
```

下面是我自己写的代码，包含了太多无用信息，也没有剪枝,导致提交超时

```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        // i到j中转k次最小用多少钱
        int row = flights.length;
        int[][][] dp = new int[n][n][k + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                Arrays.fill(dp[i][j], 0x3f3f3f3f);
            }
        }
        for (int i = 0; i < row; i++) {
            dp[flights[i][0]][flights[i][1]][0] = flights[i][2];
        }
        for (int kk = 1; kk < k + 1; kk++) {
            for (int ii = 0; ii < n; ii++) {
                for (int jj = 0; jj < n; jj++) {
                    for (int tt = 0; tt < n; tt++) {
                        for (int mm = 0; mm < kk; mm++) {
                            dp[ii][jj][kk] = Math.min(dp[ii][jj][kk], dp[ii][tt][mm] + dp[tt][jj][kk - 1 - mm]);
                        }
                    }
                }
            }
        }
        int ret = Arrays.stream(dp[src][dst]).min().getAsInt();
        return  ret == 0x3f3f3f3f ? -1:ret;
    }

    public static void main(String[] aStrings) {
    }
}
```

方法二、BFS

我们前文 [BFS 算法框架详解]() 中说到，求最短路径，肯定可以用 BFS 算法来解决。

因为 BFS 算法相当于从起始点开始，一步一步向外扩散，那当然是离起点越近的节点越先被遍历到，如果 BFS 遍历的过程中遇到终点，那么走的肯定是最短路径。

不过呢，我们在 [BFS 算法框架详解]() 用的是普通的队列 `Queue` 来遍历多叉树，而对于加权图的最短路径来说，普通的队列不管用了，得用优先级队列 `PriorityQueue`。

为什么呢？也好理解，在多叉树（或者扩展到无权图）的遍历中，与其说边没有权重，不如说每条边的权重都是 1，起点与终点之间的路径权重就是它们之间「边」的条数。

这样，先进入 `Queue` 的节点就是离起点近的，路径权重小的节点。

而使用`PriorityQueue`对加入的[start,cur]的权重进行自动排序，每次队列先弹出的就是权重最小的顶点啦。

### 博弈问题

#### [486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)

![image-20210716154622629](assets/image-20210716154622629.png)

方法一、递归

以 [1, 5, 233, 7] 为例，玩家 1 先手。
如果他选左端的 1，则玩家 2 在剩下的[5, 233, 7]的两端中选。
如果他选右端的 7，则玩家 2 在剩下的[1, 5, 233]的两端中选。
想到递归了吗？画个图看看，我用数组索引来描述一个子问题：

![image.png](assets/1598905756-NBIqZL-image.png)

![image-20210712090846982](assets/image-20210712090846982.png)

每个节点都是一个玩家在选择，下一个节点变成对手在选择，交替选。

开始时你选了 xx，得 xx 分，他没选，得 00 分，你赢了他 xx 分，接下来他选，你选，你们交替地选……请勿绕入递归的细节。

起初你有 xx 分，对手 00 分，在后面的游戏中，对手拢共赢你 yy 分，如果 x >= yx>=y，那你赢了。

屏蔽掉递归的细节，那是丢给子调用去做的。关注当前的 xx 分，子调用应该返回什么去和它比较，才能判断获胜。就不难想到：在剩余轮次中对手胜过自己的分数，它大于0，相当于对手在剩余轮次中获胜，比起整个游戏，是规模小一点的同一问题。

于是**递归函数定义：返回当前做选择的玩家，基于当前区间[i,j]，赢过对手的分数。**

怎么计算呢？

**当前选择的分数，减去，往后对手赢过自己的分数（对剩余数组递归）。**因为有两端可选择，所以差值有两个，取较大的判断是否大于等于0。

```js
const PredictTheWinner = (nums) => {
  // helper：基于从i到j的数组，当前选择的玩家所能赢对方的分数
  const helper = (i, j) => { // i，j是两端的索引
    if (i == j) {   // 此时只有一种选择，选的人赢对方nums[i]，且没有剩余可选，结束递归
      return nums[i];
    }
    const pickI = nums[i] - helper(i + 1, j); // 选择左端，获得nums[i]，之后输掉helper(i+1,j)分
    const pickJ = nums[j] - helper(i, j - 1); // 选择右端，获得nums[j]，之后输掉helper(i,j-1)分
    return Math.max(pickI, pickJ);            // 返回较大者，即在[i,j]数组游戏中胜过对方的分数
  };

  return helper(0, nums.length - 1) >= 0; // 基于整个数组玩这个游戏，玩家1先手，>=0就获胜
};
```

* 进阶：记忆化递归

```js
const PredictTheWinner = (nums) => {
  const len = nums.length;
  const memo = new Array(len);
  for (let i = 0; i < memo.length; i++) {
    memo[i] = new Array(len);
  }

  const helper = (i, j) => {
    if (i == j) {                   // base case
      return nums[i];
    }
    if (memo[i][j] !== undefined) { // 如果memo中有缓存值，就直接返回它
      return memo[i][j]; 
    }
    const pickI = nums[i] - helper(i + 1, j);
    const pickJ = nums[j] - helper(i, j - 1);
    memo[i][j] = Math.max(pickI, pickJ); // 计算结果存入memo
    return memo[i][j];
  };

  return helper(0, len - 1) >= 0;
};
```

方法二、动态规划

将递归改为动态规划即可。

比照递归函数的定义，`dp[i][j]`: 当前玩家在数组[i:j]中先手，所赢过对方的分数。

比照递归的终止条件，有 base case：当`i == j`时，`dp[i][j] = nums[i]`。

有状态转移方程：`dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])`

```js
const PredictTheWinner = (nums) => {
  const len = nums.length;
  const dp = new Array(len);  // initialize dp array
  for (let i = 0; i < len; i++) {
    dp[i] = new Array(len);
  }
  for (let i = 0; i < len; i++) {  // base case 
    dp[i][i] = nums[i];
  }
  // iteration
  for (let i = len - 2; i >= 0; i--) { 
    for (let j = i + 1; j < len; j++) {
      const pickI = nums[i] - dp[i + 1][j];
      const pickJ = nums[j] - dp[i][j - 1];
      dp[i][j] = Math.max(pickI, pickJ);
    }
  }
  return dp[0][len - 1] >= 0;
};

```

#### 

#### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

![image-20210716154954406](assets/image-20210716154954406.png)



定义 dp 数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。

和[486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)相比，[877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)增加了两个限制条件：

- 数组的长度是偶数；
- 数组的元素之和是奇数，所以没有平局。

方法一、动态规划

和[486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)相比，因为本题没有平局，所以唯一的不同之处就是返回值不同，本题返回值为`dp[0][len - 1] > 0`,而不是`dp[0][len - 1] >= 0`

```js
const PredictTheWinner = (nums) => {
  const len = nums.length;
  const dp = new Array(len);  // initialize dp array
  for (let i = 0; i < len; i++) {
    dp[i] = new Array(len);
  }
  for (let i = 0; i < len; i++) {  // base case 
    dp[i][i] = nums[i];
  }
  // iteration
  for (let i = len - 2; i >= 0; i--) { 
    for (let j = i + 1; j < len; j++) {
      const pickI = nums[i] - dp[i + 1][j];
      const pickJ = nums[j] - dp[i][j - 1];
      dp[i][j] = Math.max(pickI, pickJ);
    }
  }
  return dp[0][len - 1] > 0;
}
```

方法二、数学方法

注意，石头的堆的数量为偶数，所以你们两人拿走的堆数一定是相同的。石头的总数为奇数，也就是你们最后不可能拥有相同多的石头，一定有胜负之分。

这道题又涉及到两人的博弈，也可以用动态规划算法暴力试，比较麻烦。但我们只要对规则深入思考，就会大惊失色：只要你足够聪明，你是必胜无疑的，因为你是先手。

```c
class Solution {
    public boolean stoneGame(int[] piles) {
        return true;
    }
}
```

这是为什么呢，因为题目有两个条件很重要：一是石头总共有偶数堆，石头的总数是奇数。这两个看似增加游戏公平性的条件，反而使该游戏成为了一个割韭菜游戏。我们以 `piles=[2, 1, 9, 5]` 讲解，假设这四堆石头从左到右的索引分别是 1，2，3，4。

如果我们把这四堆石头按索引的奇偶分为两组，即第 1、3 堆和第 2、4 堆，那么这两组石头的数量一定不同，也就是说一堆多一堆少。因为石头的总数是奇数，不能被平分。

而作为第一个拿石头的人，你可以控制自己拿到所有偶数堆，或者所有的奇数堆。

你最开始可以选择第 1 堆或第 4 堆。如果你想要偶数堆，你就拿第 4 堆，这样留给对手的选择只有第 1、3 堆，他不管怎么拿，第 2 堆又会暴露出来，你就可以拿。同理，如果你想拿奇数堆，你就拿第 1 堆，留给对手的只有第 2、4 堆，他不管怎么拿，第 3 堆又给你暴露出来了。

也就是说，你可以在第一步就观察好，奇数堆的石头总数多，还是偶数堆的石头总数多，然后步步为营，就一切尽在掌控之中了。知道了这个漏洞，可以整一整不知情的同学了。

#### [292.Nim游戏（简单）](https://leetcode-cn.com/problems/nim-game)

游戏规则是这样的：你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜。

假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个正整数 n，返回你是否能赢（true 或 false）。

比如现在有 4 颗石子，算法应该返回 false。因为无论你拿 1 颗 2 颗还是 3 颗，对方都能一次性拿完，拿走最后一颗石子，所以你一定会输。

---

方法一、数学方法

首先，这道题肯定可以使用动态规划，因为显然原问题存在子问题，且子问题存在重复。但是因为你们都很聪明，涉及到你和对手的博弈，动态规划会比较复杂。

**我们解决这种问题的思路一般都是反着思考**:

如果我能赢，那么最后轮到我取石子的时候必须要剩下 1~3 颗石子，这样我才能一把拿完。

如何营造这样的一个局面呢？显然，如果对手拿的时候只剩 4 颗石子，那么无论他怎么拿，总会剩下 1~3 颗石子，我就能赢。

如何逼迫对手面对 4 颗石子呢？要想办法，让我选择的时候还有 5~7 颗石子，这样的话我就有把握让对方不得不面对 4 颗石子。

如何营造 5~7 颗石子的局面呢？让对手面对 8 颗石子，无论他怎么拿，都会给我剩下 5~7 颗，我就能赢。

这样一直循环下去，我们发现只要踩到 4 的倍数，就落入了圈套，永远逃不出 4 的倍数，而且一定会输。所以这道题的解法非常简单：

```c
bool canWinNim(int n) {
    // 如果上来就踩到 4 的倍数，那就认输吧
    // 否则，可以把对方控制在 4 的倍数，必胜
    return n % 4 != 0;
}
```

方法二、动态规划

但现在有n个石头，如何判断先手是必胜还是必败？其实画个图很容易分析：

当前先手对应n个石头，后手就对应n-1、n-2、n-3三种集合的石头

每个集合一定都会对应必胜或者必败

因此可以得到这样一个递推关系：

只有当n-1、n-2、n-3三种集合都必胜时，n对应的集合才必败。因为不管n走哪条路，都一定对应着后手必胜，也就是对应着先手必败。

而但凡后手对应的n-1、n-2、n-3三种集合有一种对应的是必败，先手都一定是必胜。因为玩家是绝对聪明的，一定会走让后手必败的路线。

因此可以得到状态转移方程：

```c
f(n) = !(f(n-1) && f(n-2) && f(n-3))
```

写出下面代码

```c
class Solution {
public:
    bool canWinNim(int n) {
        vector<bool> dp(n, true);
        for(int i = 4; i <= n; ++i) {
            dp[i-1] = !(dp[i-2] && dp[i-3] && dp[i-4]);
        }
        return dp[n-1];
    }
};
```

遇到大n时间太长，还是过不了。
观察了以下dp数组里的值的变化规律，发现只要n不是4的倍数，就是true，反之false。原来就是一行代码的事：

```c
class Solution {
public:
    bool canWinNim(int n) {
        return n%4 != 0;
    }
};
```

腾讯⾯试题：⼀共 100 只⼸箭 你和你的对⼿共⽤。你们每次只能射出⼀⽀箭或者两⽀箭，射击交替进⾏，设计⼀个算法，保证⾃⼰射出最后一支箭。

**原则：将对手控制在3的倍数，必胜**

答案： 先⼿，剩下的是 3 的倍数就⾏（100-1=99），然后按照 3 的倍数射箭必赢。 ⽐如你先拿了 1，剩下 99 个。 对⼿拿了 1，你就拿 2。这样持续 33 次就赢了。如果对⼿拿了 2 个，你就拿 1 个，这样持续 33 次你也是赢的。

```c
dp[1] = true;
dp[2] = true;
dp[3] = !(dp[1] && dp[2]) =  false;
```

