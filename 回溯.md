# 回溯算法

## 目录导航

<img src="https://camo.githubusercontent.com/3bcac8ab20d3edb4151fb58a0b7c09bcf33b70bfd4a422bd74215429dd697fd6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231393139323035303636362e706e67" alt="回溯算法大纲" style="zoom:50%;" />

## 基本知识

### 回溯法本质

**回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**。

**回溯法，一般可以解决多层for循环嵌套的问题：**

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

其中，组合无序，排列有序。

**所有回溯法的问题都可以抽象为树形结构。回溯解决的都是在子集中递归查找子集，集合的大小构成了树的宽度，递归的深度构成了树的深度。for循环用来横向遍历树层，递归用来纵向遍历树枝**

递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。

其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？

某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。

### 回溯法模板

和递归三部曲类似，回溯法一般也是分为三部曲。

- 回溯函数模板返回值以及参数

回溯算法中函数返回值一般为void。

```c
void backtracking(参数)
```

- 回溯函数终止条件

既然是树形结构，那么我们在讲解[二叉树的递归](https://mp.weixin.qq.com/s/PwVIfxDlT3kRgMASWAMGhA)的时候，就知道遍历树形结构一定要有终止条件。

回溯函数终止条件伪代码如下：

```c
if (终止条件) {
    存放结果;
    return;
}
```

- 回溯搜索的遍历过程

**所有回溯法的问题都可以抽象为树形结构。回溯解决的都是在子集中递归查找子集，集合的大小构成了树的宽度，递归的深度构成了树的深度。for循环用来横向遍历树层，递归用来纵向遍历树枝**

如图：

![回溯算法理论基础](assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303137333633313137342e706e67)

注意图中，我特意举例集合大小和孩子的数量是相等的！

回溯函数遍历过程伪代码如下：

```c
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：

```c
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**这份模板很重要，后面做回溯法的题目都靠它了！**

### [总结]组合、子集和排列问题的去重

https://my.oschina.net/archted/blog/5031308

本文主要讲解这几种问题在去重问题上的不同做法，其实就一个核心点，**<font  color=red>对组合、切割、子集、排列 先排序再去重，去重方式包括传递used引用去重和每层定义set去重， 递增子序列和排列问题中，每层定义set去重可以不排序</font>**。    

## 组合

组合问题：N个数里面按一定规则找出k个数的集合

组合⽆序，排列有序

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

![image-20210712145406341](assets/image-20210712145406341.png)

一、单个元素是否被选取

![image-20210712152907103](assets/image-20210712152907103.png)

**单看每个元素，都有两种选择：选入子集，或不选入子集。**考察当前枚举的数，基于选它而继续，是一个递归分支；基于不选它而继续，又是一个分支。
找到一个子集，结束递归，要撤销当前的选择，回到选择前的状态，做另一个选择——不选当前的数，基于不选，往下递归，继续生成子集。

从图中可以看到有太多重复子状态；

另外从代码中这种冗余从代码中也可以体现出来：每个节点下进行了两次`backtracking()`递归操作。

```c
class Solution {
private:
    vector<vector<int>> result;  // 存放符合条件结果的集合
    vector<int> path;            // 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex)
    {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        if(startIndex > n){
            return;
        }
        //选取当前节点
        path.push_back(startIndex);          // 处理节点
        backtracking(n, k, startIndex + 1);  // 基于该选择，继续往下递归，考察下一个数
        path.pop_back();                     // 回溯，撤销处理的节点
        // 不选这个数，继续往下递归，考察下一个数
        backtracking(n, k, startIndex + 1);
    }

public:
    vector<vector<int>> combine(int n, int k)
    {
        result.clear();  // 可以不写
        path.clear();    // 可以不写
        backtracking(n, k, 1);
        return result;
    }
};
```

二、回溯模板

直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。

代码如下：

```c
int n = 4;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        cout << i << " " << j << endl;
    }
}
```

但是当k较大时，就不能通过穷举for循环来解题了。这时候就需要用到回溯法了，**每次递归中嵌套一个for循环，那么递归就可以用来解决多层嵌套for循环的问题了**。

那么我把组合问题抽象为如下树形结构： 

[<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132333139353232333934302e706e67.jpg" alt="77.组合" style="zoom:50%;" />](https://camo.githubusercontent.com/339ef1f1660cad426b63173d3a4f52c66ce9237fbee51ba245994eb34375400b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132333139353232333934302e706e67)

**可以看出这个棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不在重复取。**

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围**。

**图中可以发现n相当于树的宽度，k相当于树的深度**。

那么如何在这个树上遍历，然后收集到我们要的结果集呢？

**图中每次搜索到了叶子节点，我们就找到了一个结果**。

**回溯法三部曲**

- 递归函数的返回值以及参数

在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。

代码如下：

```c
vector<vector<int>> result; // 存放符合条件结果的集合
vector<int> path; // 用来存放符合条件结果
void backtracking(int n, int k, int startIndex) 
```

其实不定义这两个全局遍历也是可以的，把这两个变量放进递归函数的参数里，但函数里参数太多影响可读性，所以我定义全局变量了。

函数里一定有两个参数，既然是集合n里面取k的数，那么n和k是两个int型的参数。

然后还需要一个参数，为int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。

为什么要有这个startIndex呢？

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex**。

- 回溯函数终止条件

什么时候到达所谓的叶子节点了呢？

path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。

所以终止条件代码如下：

```c
if (path.size() == k) {
    result.push_back(path);
    return;
}
```

* 单层搜索的过程

回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。

如此我们才遍历完图中的这棵树。

代码如下：

```c
for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历
    path.push_back(i); // 处理节点 
    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
    path.pop_back(); // 回溯，撤销处理的节点
}
```

三、进阶:剪枝

<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303139343333353230372e706e67" alt="77.组合4" style="zoom: 50%;" />

**可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**。

**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

看一下优化过程如下：

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历

所以优化之后的for循环是：

```c
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
```

完整代码如下：

```c
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1);
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:

    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};

```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

- 所有数字都是正整数。
- 解集不能包含重复的组合。 

示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]

示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]

---

相对于[77. 组合](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)，加了个元素总和的限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,...,9]。

本题k相当于了树的深度，9（因为整个集合就是9个数）就是树的宽度。

1、回溯三部曲很容易写出代码。

2、剪枝

2.1）已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。

2.2）for循环的范围也可以剪枝，i <= 9 - (k - path.size()) + 1就可以了。

<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303131323331393538303437362e706e67" alt="216.组合总和III1" style="zoom:50%;" />

最后C++代码如下：

```c
class Solution {
private:
    vector<vector<int>> result; // 存放结果集
    vector<int> path; // 符合条件的结果
    void backtracking(int targetSum, int k, int sum, int startIndex) {
        if (path.size() == k) {
            if (sum == targetSum) result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= 9 - (k - path.size()) + 1 && sum + i <= targetSum; i++) { // 剪枝
            sum += i; // 处理
            path.push_back(i); // 处理
            backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex
            sum -= i; // 回溯
            path.pop_back(); // 回溯
        }
    }

public:
    vector<vector<int>> combinationSum3(int k, int n) {
        result.clear(); // 可以不加
        path.clear();   // 可以不加
        backtracking(n, k, 0, 1);
        return result;
    }
};
```

需要注意的是**因为集合有序，当sum+i>n时，i之后的数sum+idx必然也大于n，因此加sum+i<=n在for循环判断条件处**

假如集合无序，需额外使用if判断来进行剪枝，表示i坐标后面的元素仍有可能满足`sum + index <= targetSum`

```c
        for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) { // 剪枝
            if(sum + i > targetSum) continue;
            sum += i; // 处理
            path.push_back(i); // 处理
            backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex
            sum -= i; // 回溯
            path.pop_back(); // 回溯
        }
```



#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![image-20210712193551660](assets/image-20210712193551660.png)

* 求不同集合之间的组合

**因为本题是在多个集合求组合，各集合之间不存在交集，所以每次递归函数中的for循环从不同集合的第一个元素开始迭代。**

不难写出如下C++代码：

```c
// 版本一
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';        // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index + 1);    // 递归，注意index+1，一下层要处理下一个数字了
            s.pop_back();                       // 回溯
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```

java版本：

```java
class Solution {

    // 数字到号码的映射
    private String[] map = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};

    // 路径
    private StringBuilder sb = new StringBuilder();

    // 结果集
    private List<String> res = new ArrayList<>();

    public List<String> letterCombinations(String digits) {
        if(digits == null || digits.length() == 0) return res;
        backtrack(digits,0);
        return res;
    }

    // 回溯函数
    private void backtrack(String digits,int index) {
        if(index == digits.length()) {
            res.add(sb.toString());
            return;
        }
        String val = map[digits.charAt(index)-'0'];
        for(char ch:val.toCharArray()) {
            sb.append(ch);
            backtrack(digits,index+1);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

![image-20210712200647502](assets/image-20210712200647502.png)

**注意本题和[回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)、[回溯算法：求组合总和！](https://mp.weixin.qq.com/s/HX7WW6ixbFZJASkRnCTC3w)的一个区别是：本题元素为可重复选取的**。因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！

1、如何重复选取数字

```c
    backtracking(candidates, target, sum, i);
    // 不⽤i+1了，表示可以重复读取当前的数
```

2、对总和的剪枝

剪枝有两种做法：

a)不排序加for循环判断跳过:8ms

```c
for (int i = startIndex; i < candidates.size() ; i++) {
    if(sum + candidates[i]> target) continue; //跳过该节点
}
```

b)排序加for循环终止：4ms

```c
sort(candidates.begin(), candidates.end()); // 需要排序
// 如果 sum + candidates[i] > target 就终⽌遍历
for (int i = startIndex; i < candidates.size() && sum + candidates[i]<= target; i++) {}
```

**在求和问题中，排序之后加剪枝是常见的套路！**

**对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历**。

如图：

[<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313232333137303830393138322e706e67" alt="39.组合总和1" style="zoom:50%;" />](https://camo.githubusercontent.com/1671c386e32647289cf3d957fc1143eacc031bd5f2fdda1af36e9d7d9c6c8784/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313232333137303830393138322e706e67)

整体代码如下：（注意注释的部分）

```c
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
            return;
        }

        // 如果 sum + candidates[i] > target 就终止遍历   or    if (sum + candidates[i] > target) break;
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);// 不⽤i+1了，表示可以重复读取当前的数
            sum -= candidates[i];
            path.pop_back();

        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        sort(candidates.begin(), candidates.end()); // 需要排序
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 

示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]

示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]

---

1、去重：传递used引用去重 or 每层定义set去重。

1.1）传递used引用去重

```c
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
                if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                    continue;
                }
                used[i] = true;
                backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
                used[i] = false;
            }
```

1.2）每层定义set去重

使用set去重的版本如下：

```c
        unordered_set<int> uset; // 控制某一节点下的同一层元素不能重复
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            if (uset.find(candidates[i]) != uset.end()) {
                continue;
            }
            uset.insert(candidates[i]); // 记录元素
            backtracking(candidates, target, sum, i + 1);
		}
```

1.1）传递used引用去重

**本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合**。

都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。

回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。

**强调一下，树层去重的话，需要对数组排序！**

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。此时for循环里就应该做continue的操作。

- used[i - 1] == true，说明同一树支candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）

选择过程树形结构如图所示：

<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132333230323733363338342e706e67" alt="40.组合总和II" style="zoom:50%;" />

假如不去重的情况，树结构如下：

<img src="assets/image-20210713105621061.png" alt="image-20210713105621061" style="zoom:67%;" />

2、剪枝:求和问题中，排序之后加剪枝是常见的套路

回溯三部曲分析完了，整体C++代码如下：

3、代码

```c
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        path.clear();
        result.clear();
        // 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};
```



## 切割

切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式

#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]

---

**其实切割问题类似组合问题**。

例如对于字符串abcdef：

- 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个.....。
- 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段.....。

**也就是说只有a在满足`isValid(a)`时才会在此基础上继续切割（即backtracking（index+1）），否则跳过该次选择，尝试选择`ab`进行切割。**

回溯三部曲

- 递归函数参数

`void backtracking (const string& s, int startIndex) `

本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。

- 递归函数终止条件

切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。

- 单层搜索的逻辑

在`for (int i = startIndex; i < s.size(); i++)`循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。

首先判断这个子串是不是回文，如果是回文，就加入在`vector<string> path`中，path用来记录切割过的回文子串。

**注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1**。

<img src="assets/image-20210713095122556.png" alt="image-20210713095122556" style="zoom: 67%;" />

```c
class Solution {
    List<List<String>> lists = new ArrayList<>();
    Deque<String> deque = new LinkedList<>();

    public List<List<String>> partition(String s) {
        backTracking(s, 0);
        return lists;
    }

    private void backTracking(String s, int startIndex) {
        //如果起始位置大于s的大小，说明找到了一组分割方案
        if (startIndex >= s.length()) {
            lists.add(new ArrayList(deque));
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            //如果是回文子串，则记录
            if (isPalindrome(s, startIndex, i)) {
                String str = s.substring(startIndex, i + 1);
                deque.addLast(str);
            } else {
                continue;
            }
            //起始位置后移，保证不重复
            backTracking(s, i + 1);
            deque.removeLast();
        }
    }
    //判断是否是回文串
    private boolean isPalindrome(String s, int startIndex, int end) {
        for (int i = startIndex, j = end; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}

```

#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

示例 1： 输入：s = "25525511135" 输出：["255.255.11.135","255.255.111.35"]

示例 2： 输入：s = "0000" 输出：["0.0.0.0"]

示例 3： 输入：s = "1111" 输出：["1.1.1.1"]

示例 4： 输入：s = "010010" 输出：["0.10.0.10","0.100.1.0"]

示例 5： 输入：s = "101023" 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

提示： 0 <= s.length <= 3000 s 仅由数字组成

---

切割问题可以抽象为树型结构，如图：

[<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132333230333733353933332e706e67" alt="93.复原IP地址" style="zoom:50%;" />](https://camo.githubusercontent.com/3a33d3becdfd47803cb939aa3067f71f51d3a25d4392f0c98c3c36071db50339/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132333230333733353933332e706e67)

回溯三部曲

- 递归参数

```c
    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量
    void backtracking(string& s, int startIndex, int pointNum) {
```

- 递归终止条件

pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。

- 单层搜索的逻辑

在`for (int i = startIndex; i < s.size(); i++)`循环中 [startIndex, i]这个区间就是截取的子串，需要判断这个子串是否合法。

如果合法就在字符串后面加上符号`.`表示已经分割。如果不合法就结束本层循环.

递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符`.`）

```java
class Solution {
private:
    vector<string> result;// 记录结果
    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量
    void backtracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) { // 逗点数量为3时，分隔结束
            // 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法
                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点
                pointNum++;
                backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2
                pointNum--;                         // 回溯
                s.erase(s.begin() + i + 1);         // 回溯删掉逗点
            } else break; // 不合法，直接结束本层循环
        }
    }
    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
    bool isValid(const string& s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s[start] == '0' && start != end) { // 0开头的数字不合法
                return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if (num > 255) { // 如果大于255了不合法
                return false;
            }
        }
        return true;
    }
public:
    vector<string> restoreIpAddresses(string s) {
        result.clear();
        if (s.size() > 12) return result; // 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    }
};
```

## 子集

求子集问题和[回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)和[回溯算法：分割问题！](https://mp.weixin.qq.com/s/Pb1epUTbU8fHIht-g_MS5Q)又不一样了。

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**那么组合问题和分割问题都是收集树的叶子节点，子集是收集树形结构中树的所有节点的结果**。

其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。

**那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！**

子集还包括{}
求取⼦集问题，不需要任何剪枝！因为⼦集就是要遍历整棵树。

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]

---

以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下：

[<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f3230323031313233323034313334382e706e67" alt="78.子集" style="zoom:50%;" />](https://camo.githubusercontent.com/3f67c171ede9807a17fdeaf91ac87e7813516ad272a3c4ac55ee292514ff2acf/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f3230323031313233323034313334382e706e67)

从图中红线部分，可以看出**遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合**。

回溯三部曲

- 递归函数参数

递归函数参数在上面讲到了，需要startIndex。

- 递归终止条件

剩余集合为空，即startIndex已经大于数组的长度的时候，就是叶子节点。

代码如下:

```c
if (startIndex >= nums.size()) {
    return;
}
```

**其实可以不需要加终止条件，因为startIndex >= nums.size()，本层for循环本来也结束了**。

- 单层搜索逻辑

**求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树**。

可以写出如下回溯算法C++代码：

```c
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己,该表达式第一层递归就收集了{}空集合
        if (startIndex >= nums.size()) { // 终止条件可以不加
            return;
        }
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
};
```

在注释中，可以发现可以不写终止条件，因为本来我们就要遍历整颗树。

有的同学可能担心不写终止条件会不会无限递归？

并不会，因为每次递归的下一层就是从i+1开始的。

#### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]

---

这道题目和78. 子集区别就是集合里有重复元素了，而且求取的子集要去重。

去重一定要排序，一定要排序，为什么呢？

我用没有排序的集合{2,1,2,2}来举例子画一个图，如图：

[<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303131313331363434303437392e706e67" alt="90.子集II2" style="zoom: 50%;" />](https://camo.githubusercontent.com/ed66db92bf14a34da89e08cdad8dff185449e5fd9a0d3aedb309f75367314f8b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303131313331363434303437392e706e67)

图中，大家就很明显的看到，子集重复了。

去重问题，**在[40.组合总和II](https://mp.weixin.qq.com/s/_1zPYk70NvHsdY8UWVGXmQ)中已经详细讲解过了，和本题是一个套路**。

1、先对数组排序；
2、传递used引用去重 or 每层定义set去重。

2.1）使用引用传递 used去重：**used对以startIdx下标为头结点的整棵树有影响；**

当遍历到下标i时，如果candidates[i] == candidates[i-1] && used[i-1]==false,说明i-1是i节点在该树层的前节点，

如果candidates[i] == candidates[i-1] && used[i-1] == true,说明i-1是i节点的父节点 

```c
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        for (int i = startIndex; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树支candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 而我们要对同一树层使用过的元素进行跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            used[i] = false;
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
};

```

2.2) 每个递归层都创建一个set去重：**set只对startIdx下标开始的当前树层的遍历有影响。**

如果set[nums[i]]=true,说明该节点之前已经存在数值为nums[i]的节点

```c
使用set去重的版本。

class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        unordered_set<int> uset;
        for (int i = startIndex; i < nums.size(); i++) {
            if (uset.find(nums[i]) != uset.end()) {
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1, used);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
};

```

#### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

示例:

输入: [4, 6, 7, 7] 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

说明:

- 给定数组的长度不会超过15。
- 数组中的整数范围是 [-100,100]。
- 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

---

递增⼦序列等价于从有序数组中选所有子集。本题与90.⼦集II比较像，但是本题不能排序！！！排序后结果就已经是有序的了

1、回溯三部曲

- 递归函数参数

本题求子序列，很明显一个元素不能重复使用，所以需要startIndex，调整下一层递归的起始位置。

- 终止条件

本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和78. 子集一样，可以不加终止条件，startIndex每次都会加1，并不会无限递归。

- 单层搜索逻辑

**同一父节点下的同层上使用过的元素就不能在使用了**

2、set去重

**有序数组才能做树层去重。本题不能对数组进行排序，但是题目要求求的是有序子序列，等价于从有序数组中选元素个数大于2的所有子集。因此，有序数组的前提已经实现，下一步可使用set对数组元素进行树层去重**

**`unordered_set<int> uset;` 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！**

最后整体C++代码如下：

```c
// 版本一
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        if (path.size() > 1) {
            result.push_back(path);
            // 注意这里不要加return，要取树上的节点
        }
        unordered_set<int> uset; // 使用set对本层元素进行去重
        for (int i = startIndex; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back())|| uset.find(nums[i]) != uset.end()) {
                    continue;
            }
            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
};
```

* 进阶：数值范围有限，使用数组去重，节省哈希的时间

int used[201] = {0};  // 这⾥使⽤数组来进⾏去重操作，题⽬说数值范围[-100, 100]，数组，set，map都可以做哈希表，数值范围小的话能用数组尽量用数组：

```c
    if ((!path.empty() && nums[i] < path.back()) || used[nums[i] + 100] == 1) {
        continue;
    }
```

* **总结：组合问题中，有序数组才能做树层去重。**

#### [698. 划分为k个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/)

![image-20210713172401050](assets/image-20210713172401050.png)

一、思路分析：

把装有 `n` 个数字的数组 `nums` 分成 `k` 个和相同的集合，你可以想象将 `n` 个数字分配到 `k` 个「桶」里，最后这 `k` 个「桶」里的数字之和要相同。

那么回想我们这个问题，将 `n` 个数字分配到 `k` 个桶里，我们可以有两种视角：

**视角一，如果我们切换到这** **`n`** **个数字的视角，每个数字都要选择进入到** **`k`** **个桶中的某一个**。

**视角二，如果我们切换到这** **`k`** **个桶的视角，对于每个桶，都要遍历** **`nums`** **中的** **`n`** **个数字，然后选择是否将当前遍历到的数字装进自己这个桶里**。

二、以数字的视角

用 for 循环迭代遍历 `nums` 数组大家肯定都会：



```c
for (int index = 0; index < nums.length; index++) {
    System.out.println(nums[index]);
}
```

递归遍历数组你会不会？其实也很简单：



```c
void traverse(int[] nums, int index) {
    if (index == nums.length) {
        return;
    }
    System.out.println(nums[index]);
    traverse(nums, index + 1);
}
```

只要调用 `traverse(nums, 0)`，和 for 循环的效果是完全一样的。

那么回到这道题，以数字的视角，选择 `k` 个桶，用 for 循环写出来是下面这样：



```c
// k 个桶（集合），记录每个桶装的数字之和
int[] bucket = new int[k];

// 穷举 nums 中的每个数字
for (int index = 0; index < nums.length; index++) {
    // 穷举每个桶
    for (int i = 0; i < k; i++) {
        // nums[index] 选择是否要进入第 i 个桶
        // ...
    }
}
```

如果改成递归的形式，就是下面这段代码逻辑：



```c
// k 个桶（集合），记录每个桶装的数字之和
int[] bucket = new int[k];

// 穷举 nums 中的每个数字
void backtrack(int[] nums, int index) {
    // base case
    if (index == nums.length) {
        return;
    }
    // 穷举每个桶
    for (int i = 0; i < bucket.length; i++) {
        // 选择装进第 i 个桶
        bucket[i] += nums[index];
        // 递归穷举下一个数字的选择
        backtrack(nums, index + 1);
        // 撤销选择
        bucket[i] -= nums[index];
    }
}
```

* 剪枝

如果我们提前对 `nums` 数组排序，把大的数字排在前面，那么大的数字会先被分配到 `bucket` 中，对于之后的数字，`bucket[i] + nums[index]` 会更大，更容易触发剪枝的 if 条件。

代码为：

```java
// 主函数
public boolean canPartitionKSubsets(int[] nums, int k) {
    // 排除一些基本情况
    if (k > nums.length) return false;
    int sum = 0;
    for (int v : nums) sum += v;
    if (sum % k != 0) return false;

    // k 个桶（集合），记录每个桶装的数字之和
    int[] bucket = new int[k];
    // 理论上每个桶（集合）中数字的和
    int target = sum / k;
    
    /* 降序排序 nums 数组 */
    Arrays.sort(nums);
    int i = 0, j = nums.length - 1;
    for (; i < j; i++, j--) {
        // 交换 nums[i] 和 nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    // 穷举，看看 nums 是否能划分成 k 个和为 target 的子集
    return backtrack(nums, 0, bucket, target);
}

// 递归穷举 nums 中的每个数字
boolean backtrack(
    int[] nums, int index, int[] bucket, int target) {

    if (index == nums.length) {
        // 检查所有桶的数字之和是否都是 target
        for (int i = 0; i < bucket.length; i++) {
            if (bucket[i] != target) {
                return false;
            }
        }
        // nums 成功平分成 k 个子集
        return true;
    }

    // 穷举 nums[index] 可能装入的桶
    for (int i = 0; i < bucket.length; i++) {
        // 剪枝，桶装装满了
        if (bucket[i] + nums[index] > target) {
            continue;
        }
        // 将 nums[index] 装入 bucket[i]
        bucket[i] += nums[index];
        // 递归穷举下一个数字的选择
        if (backtrack(nums, index + 1, bucket, target)) {
            return true;
        }
        // 撤销选择
        bucket[i] -= nums[index];
    }

    // nums[index] 装入哪个桶都不行
    return false;
}
```

三、以桶的视角

文章开头说了，**以桶的视角进行穷举，**

**1. 每个桶需要遍历** **`nums`** **中的所有数字，决定是否把当前数字装进桶中；**

**2.当装满一个桶之后，还要装下一个桶，直到所有桶都装满为止**。

这个思路可以用下面这段代码表示出来：



```c
// 装满所有桶为止
while (k > 0) {
    // 记录当前桶中的数字之和
    int bucket = 0;
    for (int i = 0; i < nums.length; i++) {
        // 决定是否将 nums[i] 放入当前桶中
        bucket += nums[i] or 0;
        if (bucket == target) {
            // 装满了一个桶，装下一个桶
            k--;
            break;
        }
    }
}
```

那么我们也可以把这个 while 循环改写成递归函数，不过比刚才略微复杂一些，首先写一个 `backtrack` 递归函数出来：

```c
boolean backtrack(int k, int bucket, int[] nums, int start, boolean[] used, int target);
```

这个 `backtrack` 函数的参数可以这样解释：

现在 `k` 号桶正在思考是否应该把 `nums[start]` 这个元素装进来；目前 `k` 号桶里面已经装的数字之和为 `bucket`；`used` 标志某一个元素是否已经被装到桶中；`target` 是每个桶需要达成的目标和。

```java
class Solution{
    public boolean canPartitionKSubsets(int[] nums, int k) {
        // 排除一些基本情况
        int totalSum = 0;
        int maxNum = 0;
        for (int num : nums) {
            totalSum += num;
            maxNum = Math.max(maxNum, num);
        }
        if (maxNum > totalSum / k || totalSum % k != 0) {
            return false;
        }

        boolean[] used = new boolean[nums.length];
        int target = totalSum / k;
        // k 号桶初始什么都没装，从 nums[0] 开始做选择
        return backtrack(k, 0, nums, 0, used, target);
    }
    
    boolean backtrack(int k, int bucket, int[] nums, int start, boolean[] used, int target) {
        // base case
        if (k == 0) {
            // 所有桶都被装满了，而且 nums 一定全部用完了
            // 因为 target == sum / k
            return true;
        }
        if (bucket == target) {
            // 装满了当前桶，递归穷举下一个桶的选择
            // 让下一个桶从 nums[0] 开始选数字
            return backtrack(k - 1, 0 ,nums, 0, used, target);
        }

        // 从 start 开始向后探查有效的 nums[i] 装入当前桶
        for (int i = start; i < nums.length; i++) {
            // 剪枝
            if (used[i]) {
                // nums[i] 已经被装入别的桶中
                continue;
            }
            if (nums[i] + bucket > target) {
                // 当前桶装不下 nums[i]
                continue;
            }
            // 做选择，将 nums[i] 装入当前桶中
            used[i] = true;
            bucket += nums[i];
            // 递归穷举下一个数字是否装入当前桶
            if (backtrack(k, bucket, nums, i + 1, used, target)) {
                return true;
            }
            // 撤销选择
            used[i] = false;
            bucket -= nums[i];
        }
        // 穷举了所有数字，都无法装满当前桶
        return false;
    }
}
```

四、最后总结

本文写的这两种思路都可以通过所有测试用例，不过第一种解法即便经过了排序优化，也明显比第二种解法慢很多，这是为什么呢？

我们来分析一下这两个算法的时间复杂度，假设 `nums` 中的元素个数为 `n`。

先说第一个解法，也就是从数字的角度进行穷举，`n` 个数字，每个数字有 `k` 个桶可供选择，所以组合出的结果个数为 `k^n`，时间复杂度也就是 `O(k^n)`。

第二个解法，每个桶要遍历 `n` 个数字，选择「装入」或「不装入」，组合的结果有 `2^n` 种；而我们有 `k` 个桶，所以总的时间复杂度为 `O(k*2^n)`。

通俗来说，我们应该尽量「少量多次」，就是说**宁可多做几次选择，也不要给太大的选择空间**；宁可「二选一」选 `k` 次，也不要 「`k` 选一」选一次。

**方法二、动态规划**  **动态规划做法不对**

举例：

nums = [2,2,2,2,3,4,5]
k = 4

dp = [0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 18, 20]

idx =                      5                    10                           15                           20

容易得知：

[5]刚好凑满容量为5的背包

[5,2,3]刚好凑满容量为10的背包

[2,2,2,4,5]刚好凑满容量为15的背包

即不能保证凑满容量为15的背包时，是在塞满容量为10背包的元素基础上额外选取几个元素凑够剩余5容量，因此使用01背包的做法是不合理的。

1.dp定义

`dp[j]`表示容量为j的背包背的最大重量为`dp[j]`

2.状态转移

`dp[j] = max(dp[j],dp[j-nums[i]]+nums[i])`

3.初始化

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

4.循环顺序

**一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。**

5.举例推导dp数组

6.完整代码如下：

```java
class Solution {
    boolean[] used;
    LinkedList<Integer> path = new LinkedList<>();

    public boolean canPartitionKSubsets(int[] nums, int k) {// 本质上是个切割问题
        int totalSum = 0;
        int maxNum = 0;
        for (int num : nums) {
            totalSum += num;
            maxNum = Math.max(maxNum, num);
        }
        if (maxNum > totalSum / k || totalSum % k != 0) {
            return false;
        }
        int avgSum = totalSum / k;
        int[] dp = new int[totalSum + 1];
        for (int i = 0; i < nums.length; i++) {
            for (int j = totalSum; j >= nums[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        System.out.println(Arrays.toString(dp));
        for (int i = 1; i <= k; i++) {
            if (dp[i * avgSum] != i * avgSum) {
                return false;
            }
        }
        return true;
    }
}
```



## 排列

* 去重问题

**排列问题中，每层定义set去重不用排序；传递used引用去重需先排序**

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

![image-20210713101554554](assets/image-20210713101554554.png)



我以[1,2,3]为例，抽象成树形结构如下：

[<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313230393137343232353134352e706e67" alt="46.全排列" style="zoom:50%;" />](https://camo.githubusercontent.com/e98da84da1c29c70e57d0a0f5f2aac727c0f2662c49f7ea78ff295dabdd70aa5/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313230393137343232353134352e706e67)

* 总结

大家此时可以感受出排列问题的不同：

1. 每层都是从0开始搜索而不是startIndex

2. 需要used数组记录path里都放了哪些元素了：**传递used引用影响整棵树；**

递归三部曲：

- 递归函数参数

**首先排列是有序的，也就是说[1,2] 和[2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方**。

可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。

但排列问题需要一个used数组，标记已经选择的元素

- 递归终止条件

当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

- 单层搜索的逻辑

**而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次**。

整体C++代码如下：

```c
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        // 此时说明找到了一组
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] == true) continue; // path里已经收录的元素，直接跳过
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

* 

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

![image-20210713101911675](assets/image-20210713101911675.png)

**还要强调的是去重一定要对元素经行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**。

1、先对数组排序；
2、去重，有两种方式：

2.1）**排列问题去重，可以不用对数组排序，每层定义set去重(回溯问题中只有这一种情况特殊不用排序)**

```c
int repeatArr[21] = {0};// 控制某一节点下的同一层元素不能重复
for (int i = 0; i < nums.size(); i++) {
    if (repeatArr[nums[i] + 10] == 1 || used[i]) {  // 在当前节点之前出现过该数值的节点
        continue;
    }
    repeatArr[nums[i] + 10] = 1;
}
```

2.2）**排列问题去重，和组合问题一样，先排序，再传递used引用 or每层定义set去重**

```c
void backtracking(vector<int> &nums, vector<bool> &used)
{
    for (int i = 0; i < nums.size(); i++) {
        // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
        if ((i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) || used[i]) {
            continue;
        }
        if (used[i] == false) {
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false; //等到遍历到i+1位置时，used[i]=false;
        }
    }
}
```

2.3)扩展(树枝去重)

对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更⾼！

树枝去重即：

```c
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true || used[i]) {
    continue;
}
```

3、代码

```c
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        // 此时说明找到了一组
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树支nums[i - 1]使用过
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过
            // 如果同一树层nums[i - 1]使用过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            if (used[i] == false) {
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 排序
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

## 棋盘问题

#### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

![image-20210713113959067](assets/image-20210713113959067.png)

下面我用一个3 * 3 的棋牌，将搜索过程抽象为一颗树，如图：

[<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303138323533323330332e6a7067" alt="51.N皇后" style="zoom: 50%;" />](https://camo.githubusercontent.com/b662efc3d23bb487d910e79df9c8dcd5a4bc8d3c73e4a96bda8717cce5038856/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303138323533323330332e6a7067)

从图中，可以看出，**二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树形结构中每一个节点的宽度。**

那么我们用皇后们的约束条件，来回溯搜索这颗树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**。

回溯三部曲：

- 递归函数参数

`void backtracking(int n, int row, vector<string>& chessboard)`参数n是棋牌的大小，然后用row来记录当前遍历到棋盘的第几层了。

- 递归终止条件

当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。

- 单层搜索的逻辑

递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。

每次都是要从新的一行的起始位置开始搜，所以都是从0开始。

- 验证棋牌是否合法

按照如下标准去重：

1. 不能同行
2. 不能同列
3. 不能同斜线 （45度和135度角）

```java
class Solution {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        backTrack(n, 0, chessboard);
        return res;
    }


    public void backTrack(int n, int row, char[][] chessboard) {
        if (row == n) {
            res.add(Array2List(chessboard));
            return;
        }

        for (int col = 0;col < n; ++col) {
            if (isValid (row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backTrack(n, row+1, chessboard);
                chessboard[row][col] = '.';
            }
        }

    }


    public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }


    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // 检查列
        for (int i=0; i<n; ++i) {
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }

        // 检查45度对角线
        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        // 检查135度对角线
        for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
}

```



#### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

![image-20210713113919605](assets/image-20210713113919605.png)

![image-20210713113935325](assets/image-20210713113935325.png)

[N皇后问题](https://mp.weixin.qq.com/s/lU_QwCMj6g60nh8m98GAWg)是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来来遍历列，然后一行一列确定皇后的唯一位置。

本题就不一样了，**本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深**。

因为这个树形结构太大了，我抽取一部分，如图所示：

[<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303131313732303435313739302e706e67" alt="37.解数独" style="zoom:50%;" />](https://camo.githubusercontent.com/ee23f09efc4a13a845174a1b6404b0d038bdd1e5524e662c5488a2a4cd2ac030/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303131313732303435313739302e706e67)

使用回溯三部曲解题：

- 递归函数以及参数

**递归函数的返回值需要是bool类型，为什么呢？**

因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值

- 递归终止条件

本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。

- 递归单层搜索逻辑

在树形图中可以看出我们需要的是一个二维的递归（也就是两个for循环嵌套着递归）

**一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！**

判断棋盘是否合法有如下三个维度：

- 同行是否重复
- 同列是否重复
- 9宫格里是否重复

代码

```c
class Solution {
private:
bool backtracking(vector<vector<char>>& board) {
    for (int i = 0; i < board.size(); i++) {        // 遍历行
        for (int j = 0; j < board[0].size(); j++) { // 遍历列
            if (board[i][j] != '.') continue;
            for (char k = '1'; k <= '9'; k++) {     // (i, j) 这个位置放k是否合适
                if (isValid(i, j, k, board)) {
                    board[i][j] = k;                // 放置k
                    if (backtracking(board)) return true; // 如果找到合适一组立刻返回
                    board[i][j] = '.';              // 回溯，撤销k
                }
            }
            return false;                           // 9个数都试完了，都不行，那么就返回false
        }
    }
    return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
}
bool isValid(int row, int col, char val, vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) { // 判断行里是否重复
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // 判断列里是否重复
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};
```

思路二、将坐标值作为回溯函数参数

好像更符合一般思考逻辑？

```c
boolean backtrack(char[][] board, int i, int j) {
    int m = 9, n = 9;
    if (i == m) {
        // 找到一个可行解，触发 base case
        return true;
    }
    if (j == n) {
        // 穷举到最后一列的话就换到下一行重新开始。
        return backtrack(board, i + 1, 0);
    }

    if (board[i][j] != '.') {
        // 如果有预设数字，不用我们穷举
        return backtrack(board, i, j + 1);
    } 

    for (char ch = '1'; ch <= '9'; ch++) {
        // 如果遇到不合法的数字，就跳过
        if (!isValid(board, i, j, ch))
            continue;

        board[i][j] = ch;
        // 如果找到一个可行解，立即结束
        if (backtrack(board, i, j + 1)) {
            return true;
        }
        board[i][j] = '.';
    }
    // 穷举完 1~9，依然没有找到可行解，此路不通
    return false;
}

boolean isValid(char[][] board, int r, int c, char n) {
    // 见上文
}

```

时间复杂度都是$O(9^M)$，其中 `M` 是棋盘中空着的格子数量。

## 图论额外拓展

#### [332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

![image-20210713113027020](assets/image-20210713113027020.png)



分析题目：二维数组元素可能存在重复，可能形成环



**这道题目有几个难点：**

1. 一个行程中，如果航班处理不好容易变成一个圈，成为死循环
2. 有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？
3. 使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？
4. 搜索的过程中，如何遍历一个机场所对应的所有机场。

**如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上**。

一个机场映射多个机场，机场之间要靠字母序排列，一个机场映射多个机场，可以使用std::unordered_map，如果让多个机场之间再有顺序的话，就是用std::map 或者std::multimap 或者 std::multiset。

这样存放映射关系可以定义为

含义如下：

```c
unordered_map<string, multiset<string>> targets;
unordered_map<出发机场, 到达机场的集合> targets;

unordered_map<string, map<string, int>> targets;
unordered_map<出发机场, map<到达机场, 航班次数>> targets;
```

这两个结构，我选择了后者，因为如果使用`unordered_map<string, multiset<string>> targets` 遍历multiset的时候，不能删除元素，一旦删除元素，迭代器就失效了。

在遍历 `unordered_map<出发机场, map<到达机场, 航班次数>> targets`的过程中，**可以使用"航班次数"这个字段的数字做相应的增减，来标记到达机场是否使用过了。**

**相当于说我不删，我就做一个标记！**

```java
class Solution {
    private Deque<String> res;
    private Map<String, Map<String, Integer>> map;

    private boolean backTracking(int ticketNum) {
        if (res.size() == ticketNum + 1) {
            return true;
        }
        String last = res.getLast();
        for (Map.Entry<String, Integer> target : map.get(last).entrySet()) {
            int count = target.getValue();
            if (count > 0) {
                res.add(target.getKey());
                target.setValue(count - 1);
                if (backTracking(ticketNum))
                    return true;
                res.removeLast();
                target.setValue(count);
            }
        }
        return false;
    }

    public List<String> findItinerary(List<List<String>> tickets) {
        map = new HashMap<String, Map<String, Integer>>();
        res = new LinkedList<>();
        for (List<String> t : tickets) {
            Map<String, Integer> temp;
            if (map.containsKey(t.get(0))) {
                temp = map.get(t.get(0));
                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);
            } else {
                temp = new TreeMap<>();// 升序Map
                temp.put(t.get(1), 1);
            }
            map.put(t.get(0), temp);

        }
        res.add("JFK");
        backTracking(tickets.size());
        return new ArrayList<>(res);
    }
}
```

## 其他

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

![image-20210714110243461](assets/image-20210714110243461.png)

有关括号问题，你只要记住以下性质，思路就很容易想出来：
**1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解。**
**2、对于一个「合法」的括号字符串组合 p，必然对于任何 0 <= i < len(p) 都有：子串 p[0..i] 中左括号的数量都大于或等于右括号的数量。**

算法输入一个整数 `n`，让你计算 **`n`** **对儿括号**能组成几种合法的括号组合，可以改写成如下问题：

**现在有 `2n` 个位置，每个位置可以放置字符 `(` 或者 `)`，组成的所有括号组合中，有多少个是合法的？**

这个命题和题目的意思完全是一样的对吧，那么我们先想想如何得到全部 `2^(2n)` 种组合，然后再根据我们刚才总结出的合法括号组合的性质筛选出合法的组合，不就完事儿了？

对于 `2n` 个位置，必然有 `n` 个左括号，`n` 个右括号，所以我们不是简单的记录穷举位置 `i`，而是**用** **`left`** **记录还可以使用多少个左括号，用** **`right`** **记录还可以使用多少个右括号**，这样就可以通过刚才总结的合法括号规律进行筛选了：



<img src="assets/7ec04f84e936e95782aba26c4663c5fe7aaf94a2a80986a97d81574467b0c513-LeetCode.png" alt="7ec04f84e936e95782aba26c4663c5fe7aaf94a2a80986a97d81574467b0c513-LeetCode" style="zoom:50%;" />

```c
vector<string> generateParenthesis(int n) {
    if (n == 0) return {};
    // 记录所有合法的括号组合
    vector<string> res;
    // 回溯过程中的路径
    string track;
    // 可用的左括号和右括号数量初始化为 n
    backtrack(n, n, track, res);
    return res;
}

// 可用的左括号数量为 left 个，可用的右括号数量为 rgiht 个
void backtrack(int left, int right, string& track, vector<string>& res) {
    // 若左括号剩下的多，说明不合法
    if (right < left) return;
    // 数量小于 0 肯定是不合法的
    if (left < 0 || right < 0) return;
    // 当所有括号都恰好用完时，得到一个合法的括号组合
    if (left == 0 && right == 0) {
        res.push_back(track);
        return;
    }

    // 尝试放一个左括号
    track.push_back('('); // 选择
    backtrack(left - 1, right, track, res);
    track.pop_back(); // 撤消选择

    // 尝试放一个右括号
    track.push_back(')'); // 选择
    backtrack(left, right - 1, track, res);
    track.pop_back(); ；// 撤消选择
}
```

或者递归前进行剪枝

```c
vector<string> generateParenthesis(int n) {
    if (n == 0) return {};
    // 记录所有合法的括号组合
    vector<string> res;
    // 回溯过程中的路径
    string track;
    // 可用的左括号和右括号数量初始化为 n
    backtrack(n, n, track, res);
    return res;
}

// 可用的左括号数量为 left 个，可用的右括号数量为 rgiht 个
void backtrack(int left, int right, string& track, vector<string>& res) {
    // 若左括号剩下的多，说明不合法
    if (right < left) return;
    // 当所有括号都恰好用完时，得到一个合法的括号组合
    if (left == 0 && right == 0) {
        res.push_back(track);
        return;
    }

	if(left > 0){
        // 尝试放一个左括号
        track.push_back('('); // 选择
        backtrack(left - 1, right, track, res);
        track.pop_back(); // 撤消选择
    }
	if(right > 0){
          // 尝试放一个右括号
        track.push_back(')'); // 选择
        backtrack(left, right - 1, track, res);
        track.pop_back(); ；// 撤消选择  
    }

}
```



这样，我们的算法就完成了，算法的复杂度是多少呢？这个比较难分析，**对于递归相关的算法，时间复杂度这样计算（递归次数）\*（递归函数本身的时间复杂度）**。

`backtrack` 就是我们的递归函数，其中没有任何 for 循环代码，所以递归函数本身的时间复杂度是 O(1)，但关键是这个函数的递归次数是多少？换句话说，给定一个 `n`，`backtrack` 函数递归被调用了多少次？

我们前面怎么分析动态规划算法的递归次数的？主要是看「状态」的个数对吧。其实回溯算法和动态规划的本质都是穷举，只不过动态规划存在「重叠子问题」可以优化，而回溯算法不存在而已。

所以说这里也可以用「状态」这个概念，**对于** **`backtrack`** **函数，状态有三个，分别是** **`left, right, track`**，这三个变量的所有组合个数就是 `backtrack` 函数的状态个数（调用次数）。

`left` 和 `right` 的组合好办，他俩取值就是 0~n 嘛，组合起来也就 `n^2` 种而已；这个 `track` 的长度虽然取在 0~2n，但对于每一个长度，它还有指数级的括号组合，这个是不好算的。

说了这么多，就是想让大家知道这个算法的复杂度是指数级，而且不好算，这里就不具体展开了，是 $\frac{4^{n}}{\sqrt{n}}$.



如果没有剪枝，每次都先添加左右括号，生成完整序列后再判断序列是否合法，时间复杂度：$O(2^{2n}n)$，对于 $2^{2n}$ 个序列中的每一个，我们用于建立和验证该序列的复杂度为 $O(n)$。有了left、right后可以进行剪枝，只在序列仍然保持有效时才添加 `'('` or `')'`，时间复杂度简化为$\frac{4^{n}}{\sqrt{n}}$



