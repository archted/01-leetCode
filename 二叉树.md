[TOC]

## ==需要复习的题型==



## 目录导航

![image-20210607094318969](C:\Users\a00575982\AppData\Roaming\Typora\typora-user-images\image-20210607094318969.png)



## 二叉树理论

* 种类：
  * 满二叉树
  * 完全二叉树：堆就是一棵完全二叉树
  * 二叉搜索树
  * 平衡二叉搜索树：**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树(红黑树)**，unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。

* 存储方式：
  * 链式存储
  * 顺序存储

# 二叉树的遍历

## 遍历方式

### 1、DFS(回溯)

他的访问顺序是：先访根节点，然后左结点，一直往下，直到最左结点没有子节点的时候然后往上退一步到父节点，然后父节点的右子节点在重复上面步骤……

DFS包含了前序遍历、中序遍历和后序遍历，一般使用前序遍历进行DFS，以方便进行回溯。

#### 1.1前序遍历

1、前序遍历：递归、迭代、统一风格迭代；

a)递归遍历

* 递归三部曲：确定递归函数的参数和返回值；确定终止条件；确定单层递归的逻辑

b)迭代遍历

* 使用栈完成

c)统一风格的迭代遍历

我们以中序遍历为例，使用栈的话，**无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况**。

**那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。** 这种方法也可以叫做标记法。

---

他的访问顺序是：根节点→左子树→右子树

a)递归

```c
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}
```

b)迭代  

前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。

不难写出如下代码: （**注意代码中空节点不入栈**）

```c
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

c)统一风格迭代，中左右  压栈顺序： 右→左→中

可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。

```c
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

#### 1.2中序遍历

2、中序遍历：递归、迭代、统一风格迭代；

a)递归

```c
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```

b)迭代：

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**因此使用指针访问节点，使用栈处理节点中的值。

```c
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else if(cur == NULL){
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

c)统一风格迭代，左中右  压栈顺序： 右→中→左

可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。

```c
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};
```

#### 1.3后序遍历

3、后序遍历：递归、迭代、统一风格迭代；

a)递归

```c
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

b)迭代

前序遍历中左右->中右左->左右中，也就是在前序遍历中改为先压左孩子再压右孩子，最后将结果翻转

```c
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

c)统一风格迭代，左右中  压栈顺序： 中→右→左

可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。

```c
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);

                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

### 2、BFS(层序遍历)

层序遍历：递归、迭代；

他的访问顺序是：先访问上一层，在访问下一层，一层一层的往下访问

a)迭代：使用队列完成

```c
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};

```

b)递归

```java
class Solution {
    private static int depth(TreeNode tree) {
        if (tree == null)
            return 0;
        int leftDepth = depth(tree.left);
        int rightDepth = depth(tree.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }

    public static List<List<TreeNode>> levelOrder(TreeNode tree) {
        int depth = depth(tree);
        List<List<TreeNode>> ret = new LinkedList<>();
        for (int level = 0; level < depth; level++) {
            List<TreeNode> list = new LinkedList<>();
            saveLevel(tree, level, list);
            ret.add(list);
        }
        return ret;
    }

    // 回溯
    private static void saveLevel(TreeNode tree, int level, List<TreeNode> list) {
        if (tree == null)
            return;
        if (level == 0) {
            list.add(tree);
        } else {
            saveLevel(tree.left, level - 1, list);
            saveLevel(tree.right, level - 1, list);
        }
    }
}
```

如果想把遍历的结果存放到list中，我们还可以这样写

```java
public static List<List<Integer>> levelOrder(TreeNode tree) {
    if (tree == null)
        return null;
    List<List<Integer>> list = new ArrayList<>();
    bfs(tree, 0, list);
    return list;
}

private static void bfs(TreeNode tree, int level, List<List<Integer>> list) {
    if (tree == null)
        return;
    if (level >= list.size()) {
        List<Integer> subList = new ArrayList<>();
        subList.add(tree.val);
        list.add(subList);
    } else {
        list.get(level).add(tree.val);
    }
    bfs(tree.left, level + 1, list);
    bfs(tree.right, level + 1, list);
}
```



### 3、Morris（莫里斯）的前中后3种遍历方式



# 二叉树遍历的应用

### 层序遍历应用

下面的题目都比较easy

- 102.二叉树的层序遍历
- 107.二叉树的层次遍历II
- 199.二叉树的右视图
- 637.二叉树的层平均值
- 429.N叉树的前序遍历
- 515.在每个树行中找最大值
- 116.填充每个节点的下一个右侧节点指针
- [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

#### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

给定一个二叉树

```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

---

1、使用队列完成层序遍历

对层序遍历程序稍加修改，记录该层中上个节点pre，然后完成next指针赋值即可。

```c
class Solution {
public:
    Node *connect(Node *root)
    {
        queue<Node *> que;
        if (root != NULL)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            Node *pre = nullptr;  //上个节点
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                Node *node = que.front();
                que.pop();
                if (pre)
                    pre->next = node;
                pre = node;
                vec.push_back(node->val);
                if (node->left)
                    que.push(node->left);
                if (node->right)
                    que.push(node->right);
            }
        }
        return root;
    }
};
```

**2、进阶：**

- 你只能使用常量级额外空间。

上面运行效率并不是很高，这是因为我们把节点不同的入队然后再不停的出队，其实可以不需要队列，每一行都可以看成一个链表比如第一行就是只有一个节点的链表，第二行是只有两个节点的链表（假如根节点的左右两个子节点都不为空）……

思路：在cur遍历上层节点时，使用指针pre将下层节点串起来，并使用哑节点dummy保存该链表虚拟头结点；cur遍历完本层节点后，`cur=dummy.next`继续遍历下层节点。

![image.png](assets/1601259285-fJOatB-image.png)

```java
    public Node connect(Node root) {
        if (root == null)
            return root;
        //cur我们可以把它看做是每一层的链表
        Node cur = root;
        while (cur != null) {
            //遍历当前层的时候，为了方便操作在下一层前面添加一个哑结点（注意这里是访问当前层的节点，然后把下一层的节点串起来）
            Node dummy = new Node(0);
            //pre表示访下一层节点的前一个节点
            Node pre = dummy;
            //然后开始遍历当前层的链表
            while (cur != null) {
                if (cur.left != null) {
                    //如果当前节点的左子节点不为空，就让pre节点的next指向他，也就是把它串起来
                    pre.next = cur.left;
                    //然后再更新pre
                    pre = pre.next;
                }
                //同理参照左子树
                if (cur.right != null) {
                    pre.next = cur.right;
                    pre = pre.next;
                }
                //继续访问这一行的下一个节点
                cur = cur.next;
            }
            //把下一层串联成一个链表之后，让他赋值给cur，后续继续循环，直到cur为空为止
            cur = dummy.next;
        }
        return root;
    }
```



## 101. 对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

---

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**

1、前序遍历的递归法

```c
class Solution {
public:
    bool isSymmetric(TreeNode *root)
    {
        if (root == nullptr)
            return true;
        return isSymmetric(root->left, root->right);
    }
    //前序遍历：先判断父再判断左右孩子
    bool isSymmetric(TreeNode *left, TreeNode *right)
    {
        //中（包含了终止条件）
        if (!left && !right)  //都为空
            return true;
        else if ((!left && right) || (left && !right))  //一个为空
            return false;
        else if (left->val != right->val)  //都不为空且数值不相等
            return false;
        //                   左                                          右
        else return true && isSymmetric(left->left, right->right) && isSymmetric(left->right, right->left);
    }
};
```

2、使用队列/栈将两个节点顺序放入容器中进行比较

2.1）使用栈的迭代法

```c
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        stack<TreeNode*> st; // 这里改成了栈
        st.push(root->left);
        st.push(root->right);
        while (!st.empty()) {
            TreeNode* leftNode = st.top(); st.pop();
            TreeNode* rightNode = st.top(); st.pop();
            if (!leftNode && !rightNode) {
                continue;
            }
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            st.push(leftNode->left);
            st.push(rightNode->right);
            st.push(leftNode->right);
            st.push(rightNode->left);
        }
        return true;
    }
};

```

2.2）使用queue结构（类似层序遍历）的迭代法

```c
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        while (!que.empty()) {  // 接下来就要判断这这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

4、前序遍历更高效，没必要采用后序遍历

* 相似题目：
  * 100.相同的树
  * 572.另一个树的子树

## [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:

```js
     3
    / \
   4   5
  / \
 1   2
```

给定的树 t：

```js
   4 
  / \
 1   2
```

返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

示例 2:
给定的树 s：

```js
     3
    / \
   4   5
  / \
 1   2
    /
   0
```

给定的树 t：

```
   4
  / \
 1   2
```

返回 false。



```c
class Solution {
public:
    // 判断subRoot和root某个子树是否相等
    bool isSubtree(TreeNode *root, TreeNode *subRoot)
    {
        if (!root && !subRoot)
            return true;
        if ((!root && subRoot) || (root && !subRoot)) //因为s 的一个子树包括 s 的一个节点和这个节点的所有子孙
            return false;
        // subRoot和root为根的子树相等
        return isSameTree(root, subRoot) || isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
    //判断tree1是否和tree2相等
    bool isSameTree(TreeNode *tree1, TreeNode *tree2)
    {
        if (!tree1 && !tree2)
            return true;
        if ((tree1 && !tree2) || (!tree1 && tree2) || (tree1->val != tree2->val))
            return false;
        return true && isSameTree(tree1->left, tree2->left) && isSameTree(tree1->right, tree2->right);
    }
};
```

* [前缀和]一章的[437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/solution/qian-zhui-he-di-gui-hui-su-by-shi-huo-de-xia-tian/)解法和本题相似，也是使用两个递归函数去解决问题。

## 104.二叉树最大深度/高度

* 博客：[先序遍历回溯/隐式回溯求深度、后序遍历求高度.md](https://my.oschina.net/archted/blog/5014367)

**因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）**

这里强调一波概念：

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的节点个数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的节点个数。

二叉树的最大深度就是根节点的高度，因此二叉树最大深度/二叉树高度问题可以互相转换

> 104.二叉树的最大深度
>
> 二叉树高度

### 1、二叉树的最大深度

求深度可以从上到下去查 所以需要前序遍历（中左右）

a) BFS

```c
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

b.1) 隐式回溯法 ， 深度优先遍历(中左 --> 中右，可看做前序变种)

```c
class Solution {
private:
    int ans = 0;

public:
    int maxDepth(TreeNode *root)
    {
        backtracking(root, 0);
        return ans;
    }
    //函数意义：root节点到根节点的距离为depth，求叶节点到根节点的最大距离
    void backtracking(TreeNode *root, int depth)
    {
        if (root == NULL) {  // 直接返回
            ans = max(ans, depth);
            return;
        }
        backtracking(root->left, depth + 1);
        backtracking(root->right, depth + 1);
    }
};
```

b.2) 显式回溯法， 深度优先遍历(中左 --> 中右，可看做前序变种)

```c
class Solution {
private:
    int ans = 0;

public:
    int maxDepth(TreeNode *root)
    {
        backtracking(root, 0);
        return ans;
    }
    //函数意义：求二叉树最大深度
    //参数：根节点到root节点的距离为depth
    void backtracking(TreeNode *root, int depth)
    {
        if (root == NULL) {  // 直接返回
            ans = max(ans, depth);
            return;
        }
        depth++;
        backtracking(root->left, depth);
/* 省略
        depth--;
        depth++;
*/
        backtracking(root->right, depth);
        depth--;
    }
};

```



### 2、二叉树高度

高度只能从下到上去查，所以只能后序遍历（左右中）

a）函数返回子树高度，因此是后序遍历的递归法

```c
class Solution {
public:
    //函数意义：返回node树的高度
    int getDepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftDepth = getDepth(node->left);       // 左
        int rightDepth = getDepth(node->right);     // 右
        int depth = 1 + max(leftDepth, rightDepth); // 中
        return depth;
    }
    int maxDepth(TreeNode* root) {
        return getDepth(root);
    }
};

```

b) 后序遍历的迭代法**(没看懂)**

```python
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        st = []
        if root:
            st.append(root)
        depth = 0
        result = 0
        while st:
            node = st.pop()
            if node != None:
                st.append(node) #中
                st.append(None)
                depth += 1
                for i in range(len(node.children)): #处理孩子
                    if node.children[i]:
                        st.append(node.children[i])
                    
            else:
                node = st.pop()
                depth -= 1
            result = max(result, depth)
        return result
```

### 3、对前序/后序遍历的思考

dfs(先序)求二叉树所有叶节点最大深度时，需要使用path记录路径以便于回溯，因此函数格式`void backtracking(TreeNode *root, int depth)`,函数无返回值

后序遍历求二叉树根节点高度时，需要返回子树的高度，因此函数格式`int getDepth(TreeNode* node) `,函数返回子树的高度完成与父树高度关系的赋值



## 110.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

咋眼一看这道题目和104.二叉树的最大深度很像，其实有很大区别。

这里强调一波概念：

- 二叉树节点的深度：指从根节点到该节点路径上的节点个数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的节点个数。

因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）

1、后序遍历求高度的递归法

此时大家应该明白了既然要求比较高度，必然是要后序遍历。

```c
class Solution {
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是二叉搜索树了则返回-1
    int getDepth(TreeNode* node) {
        if (node == NULL) {
            return 0; //高度为0
        }
        int leftDepth = getDepth(node->left);
        if (leftDepth == -1) return -1; // 说明左子树已经不是二叉平衡树
        int rightDepth = getDepth(node->right);
        if (rightDepth == -1) return -1; // 说明右子树已经不是二叉平衡树
        //中
        return abs(leftDepth - rightDepth) > 1 ? -1 : 1 + max(leftDepth, rightDepth);
    }
    bool isBalanced(TreeNode* root) {
        return getDepth(root) == -1 ? false : true;
    }
};
```

2、后续遍历更高效，先序遍历求深度不推荐

做法：对每个节点，使用getDepth()函数计算它左右孩子的高度，然后比较其高度是否差值大于1，先序遍历整棵树。

## 111.二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到**最近叶子节点**的最短路径上的节点数量。

<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230333135353830303530332e706e67" alt="111.二叉树的最小深度" style="zoom:33%;" />

**求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。**

1、因为函数返回子树高度，所以是后序遍历的递归法

```c
class Solution {
public:
    int minDepth(TreeNode *node)
    {
        if (node == NULL) //空节点
            return 0;
        int leftDepth = minDepth(node->left);    // 左
        int rightDepth = minDepth(node->right);  // 右
                                                 // 中，下面都是中（父亲树）的逻辑
        if (node->left == NULL && node->right == NULL) {
            return 1;
        }
        // 当左子树为空，node最小高度取决于右子树
        if (node->left == NULL) {
            return 1 + rightDepth;
        }

        // 当右子树为空，node最小高度取决于左子树
        if (node->right == NULL) {
            return 1 + leftDepth;
        }
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }
};
```

2、层序遍历的迭代法

**需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

```c
class Solution {
public:

    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录最小深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
                if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出
                    return depth;
                }
            }
        }
        return depth;
    }
};
```

3、也可以使用前序遍历来实现

## 222.完全二叉树的节点个数

给出一个完全二叉树，求出该树的节点个数。

示例: 示例 1： 输入：root = [1,2,3,4,5,6] 输出：6

示例 2： 输入：root = [] 输出：0

示例 3： 输入：root = [1] 输出：1

提示：

- 树中节点的数目范围是[0, 5 * 10^4]

- 0 <= Node.val <= 5 * 10^4

- 题目数据保证输入的树是 完全二叉树

  

  

首先来看一下如何求普通二叉树的节点个数

* 因为递归函数返回子树节点个数，所以后序遍历的迭代

```c
// 版本一
class Solution {
private:
    int getNodesNum(TreeNode* cur) {
        if (cur == 0) return 0;
        int leftNum = getNodesNum(cur->left);      // 左
        int rightNum = getNodesNum(cur->right);    // 右
        int treeNum = leftNum + rightNum + 1;      // 中
        return treeNum;
    }
public:
    int countNodes(TreeNode* root) {
        return getNodesNum(root);
    }
};

```

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^(树深度) - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132343039323534333636322e706e67" alt="222.完全二叉树的节点个数" style="zoom:33%;" />



可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

先序遍历的递归法：

```c
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        //中
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftHeight = 0, rightHeight = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftHeight++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightHeight++;
        }
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        //左                           右
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

开头说了，这个算法的时间复杂度是 O(logN*logN)，这是怎么算出来的呢？

直觉感觉好像最坏情况下是 O(N*logN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：

```js
return 1 + countNodes(root.left) + countNodes(root.right);
```

**关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发** **`hl == hr`** **而立即返回，不会递归下去**。

为什么呢？原因如下：

**一棵完全二叉树的两棵子树，至少有一棵是满二叉树**：

<img src="assets/image-20210618095004665.png" alt="image-20210618095004665" style="zoom:80%;" />

看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 `hl == hr`，只消耗 O(logN) 的复杂度而不会继续递归。

综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。

所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。

## [404.左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

```js
示例：

    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

1、后序遍历

```c
class Solution {
public:
    int sumOfLeftLeaves(TreeNode *root)
    {
        if (root == NULL)
            return 0;

        int leftValue = sumOfLeftLeaves(root->left);    // 左
        int rightValue = sumOfLeftLeaves(root->right);  // 右
        int res = 0;
        if (root->left && !root->left->left && !root->left->right) {  
            res = root->left->val;
        }
        res = res + leftValue + rightValue;// 中
        return res;
    }
};
```

2、下面的写法是先序遍历还是后序遍历？我觉得是后序遍历，因为父亲节点左叶子之和依赖于左子树左叶子之和和右子树左叶子之和，必须得先处理完左右，最后才返回中。左右子树上面的逻辑只是中的一部分，最后返回res才是完成了父亲树的遍历。

```c
class Solution {
public:
    int sumOfLeftLeaves(TreeNode *root)
    {
        if (root == NULL)
            return 0;
        int res = 0;
        if (root->left && !root->left->left && !root->left->right) {  
            res = root->left->val;
        }
        int leftValue = sumOfLeftLeaves(root->left);    // 左
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        res = res + leftValue + rightValue;
        return res;
    }
};
```



## [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

给定一个二叉树，在树的最后一行找到最左边的值。

1、层序遍历，最后一层第一个元素即是答案

```c
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```



2、递归

我们来分析一下题目：在树的**「最后一行」**找到**「最左边的值」**。

首先要是最后一行，然后是最左边的值。

如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行，所以要找深度最大的叶子节点。

那么如果找最左边的呢？可以使用前序遍历，这样才先优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。

```c
class Solution {
public:
    int maxLen = INT_MIN;
    int maxleftValue;
    void traversal(TreeNode *root, int leftLen)
    {
        if (!root)
            return;  //直接返回
        if (root->left == NULL && root->right == NULL) {
            if (leftLen > maxLen) {
                maxLen = leftLen;
                maxleftValue = root->val;
            }
            return;
        }
        traversal(root->left, leftLen + 1);   // 隐藏着回溯
        traversal(root->right, leftLen + 1);  // 隐藏着回溯
    }
    int findBottomLeftValue(TreeNode *root)
    {
        traversal(root, 0);
        return maxleftValue;
    }
};
```

## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

<img src="assets/image-20210608194938889.png" alt="image-20210608194938889" style="zoom:50%;" />

1、回溯法

```java
public Solution(){
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        traversal(root, "", res);
        return res;
    }
    
	//root为根节点的树的所有路径
    private void traversal(TreeNode root, String path, List<String> res) {
        //如果为空树，直接返回
        if (root == null)
            return;
        //如果是叶子节点，说明找到了一条路径，把它加入到res中
        if (root.left == null && root.right == null) {
            res.add(path + root.val);
            return;
        }
        //如果不是叶子节点，在分别遍历他的左右子节点
        traversal(root.left, path + root.val + "->", res);
        traversal(root.right, path + root.val + "->", res);
    }
}
```

**把 `path + "->"`作为函数参数就是可以的，因为并有没有改变path的数值，执行完递归函数之后，path依然是之前的数值（相当于回溯了）**

2、前序遍历的迭代法

我们可以依然可以使用前序遍历的迭代方式来模拟遍历路径的过程,这里除了模拟递归需要一个栈，同时还需要一个栈来存放对应的遍历路径。

```c
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> treeSt;// 保存树的遍历节点
        stack<string> pathSt;   // 保存遍历路径的节点
        vector<string> result;  // 保存最终路径集合
        if (root == NULL) return result;
        treeSt.push(root);
        pathSt.push(to_string(root->val));
        while (!treeSt.empty()) {
            TreeNode* node = treeSt.top();
            treeSt.pop(); // 取出节点 中
            string path = pathSt.top();
            pathSt.pop();    // 取出该节点对应的路径
            if (node->left == NULL && node->right == NULL) { // 遇到叶子节点
                result.push_back(path);
            }
            if (node->right) { // 右
                treeSt.push(node->right);
                pathSt.push(path + "->" + to_string(node->right->val));
            }
            if (node->left) { // 左
                treeSt.push(node->left);
                pathSt.push(path + "->" + to_string(node->left->val));
            }
        }
        return result;
    }
};
```
## [总结]path全局变量、传递引用与传递值的情况
* 博客：[【257.二叉树所有路径】path全局变量、传递引用与传递值的情况.md](https://my.oschina.net/archted/blog/5014376)

**先说结论：**
1、回溯函数中传递path引用作为参数相当于将path作为全局变量；

2、回溯函数只传递path值作为参数时，每层递归函数中的path是局部变量，相当于每层递归都有一个path缓存，即隐回溯；换句话说要使用隐回溯，最好将path作为递归函数参数。



## [总结]递归函数什么时候需要返回值

递归函数什么时候需要返回值，什么时候不要返回值？**如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。**还有一种就是后序遍历需要根据左右递归的返回值推出中间节点的状态，这种需要有返回值。

### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

 

示例 1：

<img src="assets/pathsum1.jpg" alt="img" style="zoom:33%;" />

输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true

---



1、显式回溯

```c
class Solution {
public:
    int acc = 0;
    //在root为根的树上求是否有root到叶子节点的路径和为sum的路线
    bool traversal(TreeNode *root, int sum)
    {
        if (root == nullptr) {  //空
            return false;
        }
        if (!root->left && !root->right) {
            acc += root->val;
            bool ret = acc == sum ? true : false;
            acc -= root->val;
            return ret;
        }
        acc += root->val;
        if (traversal(root->left, sum))
            return true;
        if (traversal(root->right, sum))
            return true;
        acc -= root->val;
        return false;
    }
    bool hasPathSum(TreeNode *root, int sum)
    {
        if (root == NULL)
            return false;
        return traversal(root, sum);
    }
};
```

2、隐式回溯

```c
class Solution {
public:
    //在root为根的树上求是否有root到叶子节点的路径和为sum的路线
    bool traversal(TreeNode *root, int sum)
    {
        if (root == nullptr) {  //空
            return false;
        }
        if (!root->left && !root->right) {
            return sum == root->val;
        }
        if (traversal(root->left, sum - root->val))
            return true;
        if (traversal(root->right, sum - root->val))
            return true;
        return false;
    }
    bool hasPathSum(TreeNode *root, int sum)
    {
        if (root == NULL)
            return false;
        return traversal(root, sum);
    }
};
```

3、dfs的迭代写法

1、定义元素为：`pair<TreeNode*, int>` pair<节点指针，路径数值>,即可将node和path一块压进去

2、java中定义`Stack<Object>stack`,前后压入TreeNode 和 int

3、使用两个栈分别压node和path，即一个栈模拟递归，一个栈来存放对应的遍历路径

```c
class Solution {

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        // 此时栈里要放的是pair<节点指针，路径数值>
        stack<pair<TreeNode*, int>> st;
        st.push(pair<TreeNode*, int>(root, root->val));
        while (!st.empty()) {
            pair<TreeNode*, int> node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first->left && !node.first->right && sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->right) {
                st.push(pair<TreeNode*, int>(node.first->right, node.second + node.first->right->val));
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->left) {
                st.push(pair<TreeNode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }
        return false;
    }
};

```



* **先说结论：若题目需要判断叶节点，使用回溯方法并且需要在叶节点逻辑判断时，如果是显式回溯，记得在叶节点也进行回溯操作。**示例代码：

```c
//在root为根的树上求是否有root到叶子节点的路径和为sum的路线
bool traversal(TreeNode *root, int sum)
{
    if (root == nullptr) {  //空
        return false;
    }
    if (!root->left && !root->right) {
        acc += root->val;
        bool ret = acc == sum ? true : false;
        acc -= root->val;  //记得回溯
        return ret;
    }
    acc += root->val;
    if (traversal(root->left, sum))
        return true;
    if (traversal(root->right, sum))
        return true;
    acc -= root->val;
    return false;
}
```

  

### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

示例: 给定如下二叉树，以及目标和 sum = 22，

示例 1：

<img src="assets/pathsumii1.jpg" alt="img" style="zoom:33%;" />

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]



113.路径总和II要遍历整个树，找到所有路径，**所以递归函数不要返回值！**
感觉隐式回溯好像更简洁点？

1、回溯

```c
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    //在root为根的树上找到所有root到叶子节点的路径和为sum的路径
    void traversal(TreeNode *root, int sum)
    {
        if (root == nullptr) {  //空
            return;
        }
        if (!root->left && !root->right) {
            if (sum == root->val) {
                path.push_back(root->val);
                result.push_back(path);
                path.pop_back();
            }
            return;
        }
        path.push_back(root->val);
        sum -= root->val;
        traversal(root->left, sum);
        traversal(root->right, sum);
        sum += root->val;
        path.pop_back();
    }
    vector<vector<int>> pathSum(TreeNode *root, int sum)
    {
        if (root == NULL)
            return {};
        traversal(root, sum);
        return result;
    }
};
```



# 二叉树的修改与构造

**注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下表索引直接在原数组上操作，这样可以节约时间和空间上的开销。**

## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```js
翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

后序和前序遍历都可以，[二叉树的修改与构造]一般不使用中序遍历的方式，不然会使得逻辑笔记复杂。

1、后序遍历的递归法

```swift
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    // 保存右子树
    TreeNode rightTree = root.right;
    // 交换左右子树的位置
    root.right = invertTree(root.left);
    root.left = invertTree(rightTree);
    return root;
}
}
```

2、前序遍历的迭代法

```c
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

3、前序遍历的统一风格迭代法

```c
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                swap(node->left, node->right);          // 节点处理逻辑
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
            }
        }
        return root;
    }
};
```

4、层序遍历/BFS

```c
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left, node->right); // 节点处理
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

## [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

根据一棵树的中序遍历与后序遍历构造二叉树。

注意: 你可以假设树中没有重复的元素。

例如，给出

中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3]

```js
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

---

以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。

难点是如何根据中序数组，反过来在切后序数组？中序数组我们都切成了左中序数组和右中序数组了，那么**后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。**

1、常规做法

```c
class Solution {
private:
    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {
        if (postorder.size() == 0) return NULL;

        // 后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(rootValue);

        // 叶子节点
        if (postorder.size() == 1) return root;

        // 找到中序遍历的切割点
        int delimiterIndex;
        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }

        // 切割中序数组
        // 左闭右开区间：[0, delimiterIndex)
        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        // [delimiterIndex + 1, end)
        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );

        // postorder 舍弃末尾元素
        postorder.resize(postorder.size() - 1);

        // 切割后序数组
        // 依然左闭右开，注意这里使用了左中序数组大小作为切割点
        // [0, leftInorder.size)
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        // [leftInorder.size(), end)
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        root->left = traversal(leftInorder, leftPostorder);
        root->right = traversal(rightInorder, rightPostorder);

        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, postorder);
    }
};


```

2、优化版本

下面给出用下表索引写出的代码版本：（思路是一样的，只不过不用重复定义vector了，每次用下表索引来分割）

```c
class Solution {
private:
    // 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)
    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {
        if (postorderBegin == postorderEnd) return NULL;

        int rootValue = postorder[postorderEnd - 1];
        TreeNode* root = new TreeNode(rootValue);

        if (postorderEnd - postorderBegin == 1) return root;

        int delimiterIndex;
        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }
        // 切割中序数组
        // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;

        // 切割后序数组
        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin =  postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size
        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);
        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了

        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);

        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        // 左闭右开的原则
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
};

```

python代码

```python
//递归法
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
            if not preorder: return None  //特殊情况
            root = TreeNode(preorder[0])  //新建父节点
            p=inorder.index(preorder[0])  //找到父节点在中序遍历的位置(因为没有重复的元素，才可以这样找)
            root.left = self.buildTree(preorder[1:p+1],inorder[:p])  //注意左节点时分割中序数组和前续数组的开闭环
            root.right = self.buildTree(preorder[p+1:],inorder[p+1:])  //分割中序数组和前续数组
            return root
```



## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
```js
    3
   / \
  9  20
    /  \
   15   7
```

本题和106是一样的道理。

```c
TreeNode buildTree(int[] preorder, int preStart, int preEnd, 
    int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {

    if(preStart > preEnd || inStart > inEnd) return null;

    TreeNode root = new TreeNode(preorder[preStart]);
    int inRoot = inMap.get(root.val);
    int numsLeft = inRoot - inStart;

    root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, 
                          inorder, inStart, inRoot - 1, inMap);
    root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, 
                          inorder, inRoot + 1, inEnd, inMap);
    return root;
}
```

python代码

```python
//递归法
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
            if not preorder: return None  //特殊情况
            root = TreeNode(preorder[0])  //新建父节点
            p=inorder.index(preorder[0])  //找到父节点在中序遍历的位置(因为没有重复的元素，才可以这样找)
            root.left = self.buildTree(preorder[1:p+1],inorder[:p])  //注意左节点时分割中序数组和前续数组的开闭环
            root.right = self.buildTree(preorder[p+1:],inorder[p+1:])  //分割中序数组和前续数组
            return root
```



* 思考部分

前序和中序可以唯一确定一颗二叉树。

后序和中序可以唯一确定一颗二叉树。

那么前序和后序可不可以唯一确定一颗二叉树呢？

**前序和后序不能唯一确定一颗二叉树！**，因为没有中序遍历无法确定左右部分，也就是无法分割。

## [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：

二叉树的根是数组 nums 中的最大元素。
左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
返回有给定数组 nums 构建的 最大二叉树 。

 

示例 1：

<img src="assets/tree1.jpg" alt="img" style="zoom:50%;" />

输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：

- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。

示例 2：

<img src="assets/tree2.jpg" alt="img" style="zoom: 50%;" />

输入：nums = [3,2,1]
输出：[3,null,2,null,1]


提示：

1 <= nums.length <= 1000
0 <= nums[i] <= 1000
nums 中的所有整数 互不相同

---

思路比较简单，直接给出代码：

```c
class Solution {
private:
    // 在左闭右开区间[left, right)，构造二叉树
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left >= right) return nullptr;

        // 分割点下表：maxValueIndex
        int idx = left;
        for (int i = left + 1; i < right; ++i) {
            if (nums[i] > nums[idx]) idx = i;
        }

        TreeNode* root = new TreeNode(nums[idx]);

        // 左闭右开：[left, idx)
        root->left = traversal(nums, left, idx);

        // 左闭右开：[idx + 1, right)
        root->right = traversal(nums, idx + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```

时间复杂度：$O(nlogn)$

本来想着先定义`pair<int,int>p`排序存在`priority_queue<int>q`中，每次递归的时候从容器q中取出最大值即可，这种时间复杂度也是$O(nlogn)$，实现稍显麻烦。

```c
class Solution {
public:
    struct greater;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater> queue1;
    
    struct greater {
        bool operator()(const pair<int, int> &iLeft, const pair<int, int> &iRight)
        {
            return (iLeft.first > iRight.first);
        }
    };

    TreeNode *reversal(vector<int> &nums)
    {
        return nullptr;
    }
    
    

    TreeNode *constructMaximumBinaryTree(vector<int> &nums)
    {
        pair<int, int> piar1;
        for (int i = 0; i < nums.size(); i++) {
            queue1.push(pair<int, int>(i, nums[i]));
        }
        return reversal;
    }
};
```



## [617.合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

```js
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```
注意: 合并必须从两个树的根节点开始。

思路简单，对两棵树同时进行操作。

tips：我们用重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。

直接给出代码：

```c
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
        // 修改了t1的数值和结构
        t1->val += t2->val;                             // 中
        t1->left = mergeTrees(t1->left, t2->left);      // 左
        t1->right = mergeTrees(t1->right, t2->right);   // 右
        return t1;
    }
};
```

* 总结：操作两棵树的题目：101. 对称二叉树、617.合并二叉树

  递归法中，使用DFS。
  
  迭代法中，一般一起操作两个树都是使用队列模拟BFS/使用栈模拟DFS，同时处理两个树的节点，递归法中BFS最好理解。

# 二叉搜索树BST

二叉搜索树BST->有序数组（中序遍历）

**针对 BST 的遍历框架**：

```c
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

## [700.二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

例如，

给定二叉搜索树:

```js
    4
   / \
  2   7
 / \
1   3
```

和值: 2
你应该返回如下子树:

```php
  2     
 / \   
1   3
```
在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。

1、思路简单，递归法：

```c
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == NULL || root->val == val) return root;
        if (root->val > val) return searchBST(root->left, val);
        else return searchBST(root->right, val);
    }
};

```

2、迭代法

**对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。因此，二叉搜索树的迭代法操作就可以看成对链表的操作。**

```c
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```

## [98.验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

```php
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

1、利用中序遍历元素递增性质

性质：中序遍历下，输出的二叉搜索树节点的数值是有序序列。

因此可以在中序遍历下把二叉树转变为数组来判断数组是否单调递增；或者在中序遍历的过程中检查遍历元素是否递增

1.1）把二叉树转变为数组来判断数组是否单调递增

1.2)对空间复杂度进行优化，在中序遍历的过程中检查遍历元素是否递增

* 技巧：`TreeNode* pre = NULL; // 用来记录前一个节点`

```c
class Solution {
public:
    TreeNode* pre = NULL; // 用来记录前一个节点
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        
        if (!isValidBST(root->left)) return false;
        
        if (pre != NULL && pre->val >= root->val) return false;
        pre = root; // 记录前一个节点

        if (!isValidBST(root->right)) return false;
    }
};
```

2、对于某一个节点 root，他只能管得了自己的左右子节点，怎么把 root 的约束传递给左右子树呢？
请看正确的代码：

```c
boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

/* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) return true;
    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
    if (min != null && root.val <= min.val) return false;
    if (max != null && root.val >= max.val) return false;
    // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);
}
```

3、迭代法中使用栈模拟BST的中序遍历

```c
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL; // 记录前一个节点
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur->left;                // 左
            } else {
                cur = st.top();                 // 中
                st.pop();
                if (pre != NULL && cur->val <= pre->val)
                return false;
                pre = cur; //保存前一个访问的结点

                cur = cur->right;               // 右
            }
        }
        return true;
    }
};

```



这道题目比较容易陷入两个陷阱：

- 陷阱1 **不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了**。**我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。**

```c
class Solution {
public:
    bool isValidBST(TreeNode *root)
    {
        if (root == nullptr) {
            return true;
        }
        if (!(root->left == NULL || root->left->val < root->val)) {
            return false;
        }
        if (!(root->right == NULL || root->right->val > root->val)) {
            return false;
        }
        return isValidBST(root->left) && isValidBST(root->right);
    }
};
```

例如： [10,5,15,null,null,6,20] 这个case：

<img src="assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303831323139313530313431392e706e67" alt="二叉搜索树" style="zoom:67%;" />

节点10小于左节点5，大于右节点15，但右子树里出现了一个6 这就不符合了！

- 陷阱2

样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。

此时可以初始化比较元素为longlong的最小值。推荐要通过前一个数值（pre）和后一个数值比较（cur），得出最值。

## [530.二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

 

示例：

```js
输入：

   1
    \
     3
    /
   2

输出：
1
```

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。


提示：

树中至少有 2 个节点。

---



对BST进行中序遍历，题目转换为求在有序数组上的最小绝对差，那就是求相邻元素的最小绝对差，直接给出代码

```c
class Solution {
private:
int result = INT_MAX;
TreeNode* pre;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);   // 左
    if (pre != NULL){       // 中
        result = min(result, root->val - pre->val);
    }
    pre = root; // 记录前一个
    traversal(root->right);  // 右
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```



## [501.二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/)

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
例如：

```js
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2
返回[2].
```



提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

---

1.先看下如何求普通二叉树的众数

给定一个二叉树，找出 二叉树中的所有众数（出现频率最高的元素）。

因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？

应该是先对二叉树进行遍历得到一个数组，遍历一遍数组，找出最大频率（maxCount），然后再重新遍历一遍数组把出现频率为maxCount的元素放进集合。（因为众数有多个）



```java
class Solution {
private:
    void searchBST(TreeNode *cur, unordered_map<int, int> &map)
    {  // 前序遍历
        if (cur == NULL)
            return;
        map[cur->val]++;  // 统计元素频率
        searchBST(cur->left, map);
        searchBST(cur->right, map);
        return;
    }

public:
    vector<int> findMode(TreeNode *root)
    {
        unordered_map<int, int> map;  // key:元素，value:出现频率
        vector<int> result;
        if (root == NULL)
            return result;
        searchBST(root, map);
        int maxNum = 0;
        for (const auto &p1 : map) {
            maxNum = max(maxNum, p1.second);
        }
        for (const auto &p1 : map) {
            if (p1.second == maxNum) {
                result.push_back(p1.first);
            }
        }
        return result;
    }
};
```

这样时间复杂度为$O(n)$

2、再思考如何求二叉搜索树的众数

对BST进行中序遍历可以找到出现频率最高的元素，但如何求最大频率的元素集合呢。

因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？

应该是先遍历一遍数组，找出最大频率（maxCount），然后再重新遍历一遍数组把出现频率为maxCount的元素放进集合。（因为众数有多个）

这种方式遍历了两遍数组。

那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。

但这里其实只需要遍历一次就可以找到所有的众数。

那么如何只遍历一遍呢？

如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），代码如下：

```c
if (count == maxCount) { // 如果和最大值相同，放进result中
    result.push_back(cur->val);
}
```

是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。

所以下面要做如下操作：

频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。

```c
if (count > maxCount) { // 如果计数大于最大值
    maxCount = count;   // 更新最大频率
    result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
    result.push_back(cur->val);
}
```

关键代码都讲完了，完整代码如下：（**只需要遍历一遍二叉搜索树，就求出了众数的集合**）

```c
class Solution {
private:
    int maxCount; // 最大频率
    int count; // 统计频率
    TreeNode* pre;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur->left);       // 左
                                    // 中
        if (pre == NULL) { // 第一个节点
            count = 1;
        } else if (pre->val == cur->val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.push_back(cur->val);
        }

        if (count > maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur->val);
        }

        searchBST(cur->right);      // 右
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        TreeNode* pre = NULL; // 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    }
};
```





# 最近公共祖先

## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

 

示例 1：

![img](assets/binarytree.png)

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2：

![img](assets/binarytree.png)

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：

输入：root = [1,2], p = 1, q = 2
输出：1


提示：

树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。

1.后序遍历返回最近祖先

```c
class Solution {
public:
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        if (root == p || root == q || root == NULL) {
            return root;
        }

        TreeNode *left = lowestCommonAncestor(root->left, p, q); // 左
        TreeNode *right = lowestCommonAncestor(root->right, p, q); // 右
		//中
        if (!left && !right) {
            return root;
        }
        if (left) {
            return left;
        }
        return right;
    }
};
```



## [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![img](assets/binarysearchtree_improved.png)

 

示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

---

1.先序遍历的递归方法

利用二叉搜索树特点，使用先序遍历，判断p、q与root值之间的关系，逐渐向下逼近最近公共祖先。

```c
class Solution {
public:
    //先序遍历
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
    {
        if ((root->val - p->val) * (root->val - q->val) <= 0) {
            return root;
        }
        if (p->val < root->val && q->val < root->val) {
            return lowestCommonAncestor(root->left, p, q);
        } else {  // else if(p->val>root->val&&q->val>root->val)
            return lowestCommonAncestor(root->right, p, q);
        }
    }
};
```

# 二叉搜索树的修改与改造

* 一般使用前序遍历

对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。
我们总结了 BST 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。一旦涉及「改」，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。

## [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

 

示例 1：

<img src="assets/insertbst.jpg" alt="img" style="zoom:67%;" />

输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：

<img src="assets/bst.jpg" alt="img" style="zoom:50%;" />

提示：

给定的树上的节点数介于 0 和 10^4 之间
每个节点都有一个唯一整数值，取值范围从 0 到 10^8
-10^8 <= val <= 10^8
新值和原始二叉搜索树中的任意节点值都不同

---

步骤：按照二叉搜索树特点从上到下找到适合插入的叶子节点位置，采取插在叶节点之后的策略，进行插入即可。

1.**通过递归函数返回值完成了新加入节点的父子关系赋值操作**

```c
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        if (root->val > val) root->left = insertIntoBST(root->left, val);
        if (root->val < val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```

2.递归函数不用返回值也可以，找到插入的节点位置，直接让其父节点指向插入节点，结束递归。

2.1）使用parent指针记录上个节点

```c
class Solution {
private:
    TreeNode* parent;
    void traversal(TreeNode* cur, int val) {
        if (cur == NULL) {
            TreeNode* node = new TreeNode(val);
            if (val > parent->val) parent->right = node;
            else parent->left = node;
            return;
        }
        parent = cur;
        if (cur->val > val) traversal(cur->left, val);
        if (cur->val < val) traversal(cur->right, val);
        return;
    }

public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        parent = new TreeNode(0);
        if (root == NULL) {
            root = new TreeNode(val);
        }
        traversal(root, val);
        return root;
    }
};

```

2.2）直接在叶子节点完成赋值即可。**比较麻烦，不推荐。**

太复杂了，还没有过，放弃该方法。

```js
val = 4;
val=5.5
    5
    /\
   *   6
       /\
      *  7
```



```c
class Solution {
public:
    void traversal(TreeNode *root, int val)
    {
        //需要考虑两种情况：a)一路找到叶子节点，在叶子节点上插入；b)叶子节点的父亲只有一个孩子是叶节点，该值需插入作为叶节点父亲的另一个孩子
        if ((root && !root->left && !root->right) ||
            ((!root->left && root->right && !root->right->left && !root->right->right) ||    //左孩子为空,右孩子是叶子节点
                (!root->right && root->left && !root->left->left && !root->left->right))) {  //右孩子为空，左孩子是叶子节点
            TreeNode *node = new TreeNode(val);
            if (val < root->val) {
                root->left = node;
            } else {
                root->right = node;
            }
            return;
        }
        if (val < root->val) {
            insertIntoBST(root->left, val);
        } else {
            insertIntoBST(root->right, val);
        }
    }
    TreeNode *insertIntoBST(TreeNode *root, int val)
    {
        if (root == NULL) {
            root = new TreeNode(val);
        }
        traversal(root, val);
        return root;
    }
};
```



## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。
说明： 要求算法时间复杂度为 O(h)，h 为树的高度。

示例:

```js
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7
```

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

```js
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
```
---

有以下五种情况：

- 第一种情况：没找到删除的节点，遍历到空节点直接返回了
- 找到删除的节点
  - 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
  - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
  - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
  - 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

第五种情况有点难以理解，看下面动画：

![image-20210615091826345](assets/image-20210615091826345.png)<img src="assets/image-20210615091841485.png" alt="image-20210615091841485" style="zoom:80%;" />

1、移花接木法

```c
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root->val == key) {
			//情况2/3/4：左右孩子至少有一个为空或者全为空
            if (root->left == nullptr) return root->right;
            else if (root->right == nullptr) return root->left;
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点，右孩子为新的根节点。
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while(cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除
                root = root->right;     // 返回旧root的右孩子作为新root
                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};

```

2、交换节点法

使用右子树中最小的那个节点`minNode`的值来接替自己，并在`root.right`树中删除节点`minNode`。

```c
TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null;
    if (root.val == key) {
        // 这两个 if 把情况 1 和 2 都正确处理了 :左右孩子至少有一个为空或者全为空
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        // 处理情况 3 左右孩子节点都不为空
        TreeNode minNode = getMin(root.right); 
        root.val = minNode.val;
        root.right = deleteNode(root.right, minNode.val);
    } else if (root.val > key) {
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        root.right = deleteNode(root.right, key);
    }
    return root;
}

TreeNode getMin(TreeNode node) {
    // BST 最左边的就是最小的
    while (node.left != null) node = node.left;
    return node;
}
```

3、迭代法

```java
代码如下：

class Solution {
private:
    // 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上
    // 并返回目标节点右孩子为新的根节点
    // 是动画里模拟的过程
    TreeNode* deleteOneNode(TreeNode* target) {
        if (target == nullptr) return target;
        if (target->right == nullptr) return target->left;
        TreeNode* cur = target->right;
        while (cur->left) {
            cur = cur->left;
        }
        cur->left = target->left;
        return target->right;
    }
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        TreeNode* cur = root;
        TreeNode* pre = nullptr; // 记录cur的父节点，用来删除cur
        while (cur) {
            if (cur->val == key) break;
            pre = cur;
            if (cur->val > key) cur = cur->left;
            else cur = cur->right;
        }
        if (pre == nullptr) { // 如果搜索树只有头结点
            return deleteOneNode(cur);
        }
        // pre 要知道是删左孩子还是右孩子
        if (pre->left && pre->left->val == key) {
            pre->left = deleteOneNode(cur);
        }
        if (pre->right && pre->right->val == key) {
            pre->right = deleteOneNode(cur);
        }
        return root;
    }
};
```

读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。

因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整。

**这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚**。

* 博客：[二叉树递归三部曲详解](https://my.oschina.net/archted/blog/5022366)   讲解了669. 修剪二叉搜索树和669. 修剪二叉搜索树使用递归三部曲进行求解。

## [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

示例 1：

![](assets/up-12a298f9f0c713236bc371980ad94d8eae9.png)

输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]

示例 2：

<img src="assets/up-e4da41d6e3d49e06eda317e95d496a4ecfe.png" style="zoom:67%;" />

输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]

---

确定单层递归的逻辑
如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。

如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。

接下来要将下一层处理完左子树的结果赋给root->left，处理完右子树的结果赋给root->right。

<img src="assets/image-20210615102447357.png" alt="image-20210615102447357" style="zoom:50%;" />

如下代码相当于把节点0的右孩子（节点2）返回给上一层，

```c
if (root->val < low) {
    TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
    return right;
}
```

然后如下代码相当于用节点3的左孩子 把下一层返回的 节点0的右孩子（节点2） 接住。

```c
root->left = trimBST(root->left, low, high);
```

此时节点3的右孩子就变成了节点2，将节点0从二叉树中移除了。

最后整体代码如下：

```java
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr ) return nullptr;
        if (root->val < low) {
            TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
            return right;
        }
        if (root->val > high) {
            TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点
            return left;
        }
        root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子
        root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子
        return root;
    }
};

```



## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树

示例 1：

<img src="assets/up-09cdbbbddfdd92f86dbf2e5ecca20e906b4.png" alt="img" style="zoom:67%;" /> <img src="assets/up-2dcca85eeb44d6ca9e451b3d394e75050c0.png" alt="img" style="zoom:67%;" />

输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案

---

和二叉树的修改与构造中【654. 最大二叉树】、【106. 从中序与后序遍历序列构造二叉树】 思路一致，直接给出代码

[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

- 递归整体代码如下：

```c
class Solution {
private:
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left > right) return nullptr;
        int mid = left + ((right - left) / 2);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = traversal(nums, left, mid - 1);
        root->right = traversal(nums, mid + 1, right);
        return root;
    }
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = traversal(nums, 0, nums.size() - 1);
        return root;
    }
};
```

## 538.把二叉搜索树转换为累加树

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为**累加树**（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。

示例 1：

<img src="assets/image-20210615110647520.png" alt="image-20210615110647520" style="zoom:67%;" />

输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

---


右中左进行遍历，逐个相加即可，思路简单，直接给出代码
```c
class Solution {
private:
    int pre; // 记录前一个节点的数值
    void traversal(TreeNode* cur) { // 右中左遍历
        if (cur == NULL) return;
        traversal(cur->right);
        cur->val += pre;
        pre = cur->val;
        traversal(cur->left);
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        pre = 0;
        traversal(root);
        return root;
    }
};
```

# [BST总结]

简单总结下吧，BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求，也就这么些事儿吧。



# 《labuladong》

# 二叉树遍历的应用

## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

![image-20210615161710004](assets/image-20210615161710004.png)

如何按题目要求把一棵树拉平成一条链表？很简单，以下流程：

1、将 root 的左子树和右子树拉平。

2、将 root 的右子树接到左子树下方，然后将整个左子树作为右子树。

![image-20210617150906627](assets/image-20210617150906627.png)

1、使用无返回值的递归函数实现

```python
// 定义：将以 root 为根的树拉平为链表
void flatten(TreeNode root) {
    // base case
    if (root == null) return;

    flatten(root.left);
    flatten(root.right);

    /**** 后序遍历位置 ****/
    // 1、左右子树已经被拉平成一条链表
    TreeNode left = root.left;
    TreeNode right = root.right;

    // 2、将左子树作为右子树
    root.left = null;
    root.right = left;

    // 3、将原先的右子树接到当前右子树的末端
    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
}
```

2、递归函数返回链表头结点和尾节点，分为四种情况：1.左右孩子都不为空；2.左孩子不为空；3.右孩子不为空； 4.左右孩子都为空，分别进行讨论，代码实现略复杂。

```c
class Solution {
public:
    void flatten(TreeNode *root)
    {
        if (root == NULL)
            return;
        vector<TreeNode *> v1 = traversal(root);
        root = v1[0];
        return;
    }
    //函数定义：将root按前序遍历展开成链表，分别返回链表头结点和尾节点(可能为空)
    //返回值：{head,tail}
    vector<TreeNode *> traversal(TreeNode *root)
    {
        vector<TreeNode *> vleft;
        vector<TreeNode *> vright;

        if (root == NULL) {
            return {root, root};
        }
        vleft = traversal(root->left);
        vright = traversal(root->right);
        // 1.左右孩子都不为空
        if (vleft[0] && vright[0]) {
            root->left = NULL;
            root->right = vleft[0];
            vleft[1]->right = vright[0];
            return {root, vright[1]};
            // 2.左孩子不为空
        } else if (vleft[0] && vright[0] == NULL) {
            root->left = NULL;
            root->right = vleft[0];
            return {root, vleft[1]};
            // 3.右孩子不为空
        } else if (vright[0] && vleft[0] == NULL) {
            root->left = NULL;
            root->right = vright[0];
            return {root, vright[1]};
        } else {
            // 4.左右孩子都为空
            return {root, root};
        }
    }
};
```



## 652. 寻找重复的子树

![image-20210615164330370](assets/image-20210615164330370.png)

`List<TreeNode> findDuplicateSubtrees(TreeNode root);`

首先需要明确一个问题：什么情况下root1树和root2树相等？

root1和root2相等并且root1和root2的孩子相等时就说root1与root2相等。

```c
    bool isEqualTree(TreeNode *root1, TreeNode *root2)
    {
        bool res = true;
        if (!root1 && !root2) {
            res = true;
        }
        if (!root1 || !root2 || root1->val != root2->val) {
            return false;
        }

        return isEqualTree(root1->left, root2->left) && isEqualTree(root1->right, root2->right);
    }
```

如果你想知道以自己为根的子树是不是重复的，是否应该被加入结果列表中，你需要知道什么信息？

**你需要知道以下两点**：

**1、以我为根的这棵二叉树（子树）长啥样**？

可以通过拼接字符串的方式把二叉树序列化

**2、以其他节点为根的子树都长啥样**？

借助一个外部数据结构，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就可以知道有没有其他节点的子树和自己重复了么？

```java
// 记录所有子树以及出现的次数
HashMap<String, Integer> memo = new HashMap<>();
// 记录重复的子树根节点
LinkedList<TreeNode> res = new LinkedList<>();

/* 主函数 */
List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    traverse(root);
    return res;
}

/* 辅助函数 */
String traverse(TreeNode root) {
    if (root == null) {
        return "#";
    }

    String left = traverse(root.left);
    String right = traverse(root.right);

    String subTree = left + "," + right+ "," + root.val;

    int freq = memo.getOrDefault(subTree, 0);
    // 多次重复也只会被加入结果集一次
    if (freq == 1) {
        res.add(root);
    }
    // 给子树对应的出现次数加一
    memo.put(subTree, freq + 1);
    return subTree;
}
```

## 【总结】二叉树递归函数返回值与使用path的思考

以二叉树的序列化为例，说下二叉树递归函数返回值与使用path记录回溯过程的区别。

1、以前序遍历为例，使用path记录回溯过程

```java
String SEP = ",";
String NULLStr = "#";

/* 主函数，将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    String res = sb.toString();
    return res.substring(0,res.length()-1);
        
}

/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULLStr).append(SEP);
        return;
    }

    /****** 前序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}
```

序列化结果：1,2,#,4,#,#,3,#,#

2、递归函数返回值,因为要进行关系赋值，所以只能采用后序遍历的方式，最终字符串序列化结果还是按照前序遍历的顺序来拼接。

```java
public class Solution {
    /* 主函数，将二叉树序列化为字符串 */
    String serialize(TreeNode root) {
        if (root == null) {
            return "#";
        }
        String left = serialize(root.left);
        String right = serialize(root.right);
        return root.val + ',' + left + ',' + right;// 按 根,左,右 拼接字符串
    }
}
```

从上面的代码可以得出以下几个**结论**：

**1、递归函数使用path记录回溯路径时，二叉树遍历方式选择前序、中序、后序和层序遍历都可以；**

**2、递归函数使用返回值完成关系赋值时，只能采用后序遍历的方式；**

## [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

![image-20210617105412716](assets/image-20210617105412716.png)

**所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式**。

二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。

1、前序遍历

![image-20210617115700689](assets/image-20210617115700689.png)

写出序列化函数 `serialize` 的代码了：

```java
String SEP = ",";

/* 主函数，将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append("#").append(SEP);
        return;
    }

    /****** 前序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}
```

那么，反序列化过程也是一样，**先确定根节点 `root`，然后遵循前序遍历的规则，递归生成左右子树即可**：

```java
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    // 将字符串转化成列表
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;

    /****** 前序遍历位置 ******/
    // 列表最左侧就是根节点
    String first = nodes.removeFirst();
    if (first.equals("#")) return null;
    TreeNode root = new TreeNode(Integer.parseInt(first));
    /***********************/

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    return root;
}
```

2、后序遍历，类似先序遍历

3、中序遍历行不通，因为无法实现反序列化方法 `deserialize`。

`root` 的值被夹在两棵子树的中间，也就是在 `nodes` 列表的中间，我们不知道确切的索引位置，所以无法找到 `root` 节点，也就无法进行反序列化。

4、层序遍历

![image-20210617161438434](assets/image-20210617161438434.png)

a)序列化

```java
public class Solution {
    String SEP = ",";
    String NULL = "#";

    /* 将二叉树序列化为字符串 */
    String serialize(TreeNode root) {
        if (root == null)
            return "";
        StringBuilder sb = new StringBuilder();
        // 初始化队列，将 root 加入队列
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while (!q.isEmpty()) {
            TreeNode cur = q.poll();
            if (cur == null) {
                sb.append("#").append(SEP);
            } else {
                sb.append(cur.val).append(SEP);
                q.offer(cur.left);
                q.offer(cur.right);
            }
        }
        return sb.toString();
    }
}
```

b)反序列化

除了第一个是根节点的值，其他节点值都是成对的，对应左右子节点。

难点在于层次遍历的反序列化。不容易想清楚重建的顺序应该是怎么样的。


```js
    1
   / \
  2   3
     / \
    4   5
```
序列化后， 1 2 3 # # 4 5 # # # # 。

第一个节点是1，是根节点。但是还未完成，其还有两个子节点。

此时，只能将存入队列。

接着是2，其是1的左子节点。

接着是3，其是1的右子节点。

可以看出，除了根节点，后面的节点必须成对出现，且第一个是某节点的左子节点，第二个是其右子节点。

同样，2和3的子节点也还没有出现，同样要先入队列。

```java
/* 将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    if (data.isEmpty()) return null;
    String[] nodes = data.split(SEP);
    // 第一个元素就是 root 的值
    TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));

    // 队列 q 记录父节点，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    for (int i = 1; i < nodes.length; ) {
        // 队列中存的都是父节点
        TreeNode parent = q.poll();
        // 父节点对应的左侧子节点的值
        String left = nodes[i++];
        if (!left.equals(NULL)) {
            parent.left = new TreeNode(Integer.parseInt(left));
            q.offer(parent.left);
        } else {
            parent.left = null;
        }
        // 父节点对应的右侧子节点的值
        String right = nodes[i++];
        if (!right.equals(NULL)) {
            parent.right = new TreeNode(Integer.parseInt(right));
            q.offer(parent.right);
        } else {
            parent.right = null;
        }
    }
    return root;
}
```

这段代码可以考验一下你的框架思维。仔细看一看 for 循环部分的代码，发现这不就是标准层级遍历的代码衍生出来的嘛：

```java
while (!q.isEmpty()) {
    TreeNode cur = q.poll();

    if (cur.left != null) {
        q.offer(cur.left);
    }

    if (cur.right != null) {
        q.offer(cur.right);
    }
}
```

只不过，标准的层级遍历在操作二叉树节点 `TreeNode`，而我们的函数在操作 `nodes[i]`，这也恰恰是反序列化的目的嘛。

## [341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)

![image-20210617163334660](assets/image-20210617163334660.png)

一、题目描述

我来描述一下题目：

首先，现在有一种数据结构`NestedInteger`，**这个结构中存的数据可能是一个`Integer`整数，也可能是一个`NestedInteger`列表**。注意，这个列表里面装着的是`NestedInteger`，也就是说这个列表中的每一个元素可能是个整数，可能又是个列表，这样无限递归嵌套下去……

`NestedInteger`有如下 API：

```java
public class NestedInteger {
    // 如果其中存的是一个整数，则返回 true，否则返回 false
    public boolean isInteger();

    // 如果其中存的是一个整数，则返回这个整数，否则返回 null
    public Integer getInteger();

    // 如果其中存的是一个列表，则返回这个列表，否则返回 null
    public List<NestedInteger> getList();
}
```

我们的算法会被输入一个`NestedInteger`列表，我们需要做的就是写一个迭代器类，将这个带有嵌套结构`NestedInteger`的列表「拍平」：

```java
public class NestedIterator implements Iterator<Integer> {
    // 构造器输入一个 NestedInteger 列表
    public NestedIterator(List<NestedInteger> nestedList) {}

    // 返回下一个整数
    public Integer next() {}

    // 是否还有下一个整数？
    public boolean hasNext() {}
}
```

我们写的这个类会被这样调用，**先调用`hasNext`方法，后调用`next`方法**：

```java
NestedIterator i = new NestedIterator(nestedList);
while (i.hasNext())
    print(i.next());
```

比如示例 1，输入的列表里有三个`NestedInteger`，两个列表型的`NestedInteger`和一个整数型的`NestedInteger`。

二、解题思路

显然，`NestedInteger`这个神奇的数据结构是问题的关键，不过题目专门提醒我们：

```
You should not implement it, or speculate about its implementation.
```

我不应该去尝试实现`NestedInteger`这个结构，也不应该去猜测它的实现？**为什么？凭什么？是不是题目在误导我？是不是我进行推测之后，这道题就不攻自破**了？

你看，labuladong 可不是什么好孩子，你不让推测，我就偏偏要去推测！我反手就把`NestedInteger`这个结构给实现出来：

```java
public class NestedInteger {
    private Integer val;
    private List<NestedInteger> list;

    public NestedInteger(Integer val) {
        this.val = val;
        this.list = null;
    }
    public NestedInteger(List<NestedInteger> list) {
        this.list = list;
        this.val = null;
    }

    // 如果其中存的是一个整数，则返回 true，否则返回 false
    public boolean isInteger() {
        return val != null;
    }

    // 如果其中存的是一个整数，则返回这个整数，否则返回 null
    public Integer getInteger() {
        return this.val;
    }

    // 如果其中存的是一个列表，则返回这个列表，否则返回 null
    public List<NestedInteger> getList() {
        return this.list;
    }
}
```

嗯，其实这个实现也不难嘛，写出来之后，我不禁翻出前文 [学习数据结构和算法的框架思维](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484852&idx=1&sn=85b50b8b0470bb4897e517955f4e5002&chksm=9bd7fbbcaca072aa75e2a241064a403fde1e579d57ab846cd8537a54253ceb2c8b93cc3bf38e&scene=21#wechat_redirect)，发现这玩意儿竟然……

```
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}
```

**这玩意儿不就是棵 N 叉树吗？叶子节点是`Integer`类型，其`val`字段非空；其他节点都是`List<NestedInteger>`类型，其`val`字段为空，但是`list`字段非空，装着孩子节点**。

比如说输入是`[[1,1],2,[1,1]]`，其实就是如下树状结构：

<img src="assets/image-20210617165829564.png" alt="image-20210617165829564" style="zoom: 67%;" />

好的，刚才题目说什么来着？把一个`NestedInteger`扁平化对吧？**这不就等价于遍历一棵 N 叉树的所有「叶子节点」吗**？我把所有叶子节点都拿出来，不就可以作为迭代器进行遍历了吗？

N 叉树的遍历怎么整？

```java
void traverse(TreeNode root) {
    for (TreeNode child : root.children)
        traverse(child);
```

这个框架可以遍历所有节点，而我们只对整数型的`NestedInteger`感兴趣，也就是我们只想要「叶子节点」，所以`traverse`函数只要在到达叶子节点的时候把`val`加入结果列表即可：

```java
class NestedIterator implements Iterator<Integer> {

    private Iterator<Integer> it;

    public NestedIterator(List<NestedInteger> nestedList) {
        // 存放将 nestedList 打平的结果
        List<Integer> result = new LinkedList<>();
        for (NestedInteger node : nestedList) {
            // 以每个节点为根遍历
            traverse(node, result);
        }
        // 得到 result 列表的迭代器
        this.it = result.iterator();
    }

    public Integer next() {
        return it.next();
    }

    public boolean hasNext() {
        return it.hasNext();
    }    

    // 遍历以 root 为根的多叉树，将叶子节点的值加入 result 列表
    private void traverse(NestedInteger root, List<Integer> result) {
        if (root.isInteger()) {
            // 到达叶子节点
            result.add(root.getInteger());
            return;
        }
        // 遍历框架
        for (NestedInteger child : root.getList()) {
            traverse(child, result);
        }
    }
}

```

这样，我们就把原问题巧妙转化成了一个 N 叉树的遍历问题，并且得到了解法。

三、进阶思路

**以上解法虽然可以通过，但是在面试中，也许是有瑕疵的。**

我们的解法中，一次性算出了所有叶子节点的值，全部装到`result`列表，也就是内存中，`next`和`hasNext`方法只是在对`result`列表做迭代。如果输入的规模非常大，构造函数中的计算就会很慢，而且很占用内存。

一般的迭代器求值应该是「惰性的」，也就是说，如果你要一个结果，我就算一个（或是一小部分）结果出来，而不是一次把所有结果都算出来。

如果想做到这一点，使用递归函数进行 DFS 遍历肯定是不行的，而且我们其实只关心「叶子节点」，所以传统的 BFS 算法也不行。实际的思路很简单：

**调用`hasNext`时，如果`nestedList`的第一个元素是列表类型，则不断展开这个元素，直到第一个元素是整数类型**。

由于调用`next`方法之前一定会调用`hasNext`方法，这就可以保证每次调用`next`方法的时候第一个元素是整数型，直接返回并删除第一个元素即可。

看一下代码：

```java
public class NestedIterator implements Iterator<Integer> {
    private LinkedList<NestedInteger> list;

    public NestedIterator(List<NestedInteger> nestedList) {
        // 不直接用 nestedList 的引用，是因为不能确定它的底层实现
        // 必须保证是 LinkedList，否则下面的 addFirst 会很低效
        list = new LinkedList<>(nestedList);
    }

    public Integer next() {
        // hasNext 方法保证了第一个元素一定是整数类型
        return list.remove(0).getInteger();
    }

    public boolean hasNext() {
        // 循环拆分列表元素，直到列表第一个元素是整数类型
        while (!list.isEmpty() && !list.get(0).isInteger()) {
            // 当列表开头第一个元素是列表类型时，进入循环
            List<NestedInteger> first = list.remove(0).getList();
            // 将第一个列表打平并按顺序添加到开头
            for (int i = first.size() - 1; i >= 0; i--) {
                list.addFirst(first.get(i));
            }
        }
        return !list.isEmpty();
    }
}
```

以这种方法，符合迭代器惰性求值的特性，是比较好的解法，建议拿小本本记下来！



# BST

直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

![image-20210615203656431](assets/image-20210615203656431.png)

![image-20210615203742018](assets/image-20210615203742018.png)



1、一个直接的思路就是中序遍历BST，遍历过程中节点升序排序，然后找第k个元素呗。

```c
int kthSmallest(TreeNode root, int k) {
    // 利用 BST 的中序遍历特性
    traverse(root, k);
    return res;
}

// 记录结果
int res = 0;
// 记录当前元素的排名
int rank = 0;
void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    traverse(root.left, k);
    /* 中序遍历代码位置 */
    rank++;
    if (k == rank) {
        // 找到第 k 小的元素
        res = root.val;
        return;
    }
    /*****************/
    traverse(root.right, k);
}
```

最坏的时间复杂度是`O(N)`，`N`是 BST 的节点个数。

2、进阶

利用「BST 中序遍历就是升序排序结果」这个性质，每次寻找第`k`小的元素都要中序遍历一次，最坏的时间复杂度是`O(N)`，`N`是 BST 的节点个数。

要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是`O(logN)`的复杂度，让你算一个第`k`小元素，时间复杂度竟然要`O(N)`，有点低效了。

我们想一下 BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST 的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到对数级复杂度。

因此我们需要引入一种新的BST结点，它除了拥有结点值和左右子结点指针等变量外，还新增了另外两个变量leftchilds和rightchilds，分别记录了该结点左子树和右子树中结点的数量。

步骤：

 a)记忆化BST的维护

```c
//该结点的定义
/*
struct BstMemoNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    int leftchilds;
    int rightchilds;
    BstMemoNode(int x) : val(x), left(NULL), right(NULL), leftchilds(0), rightchilds(0)
    {}
};
*/
//由于本题中已经定义好了BST的结点，使用两个map维护
unordered_map<TreeNode *, int> leftchilds;
unordered_map<TreeNode *, int> rightchilds;
```

在二叉树的插入/删除的过程中，我们都可以很方便地维护这两个变量。

```c
//701. 二叉搜索树中的插入操作
TreeNode *insertNode(TreeNode *&root, int key)
{
    if (root == NULL) {
        return new TreeNode(key);
    }
    if (key < root->val) {
        leftchilds[root]++;
        root->left = insertNode(root->left, key);
    }
    if (key > root->val) {
        rightchilds[root]++;
        root->right = insertNode(root->right, key);
    }
    return root;
}
//450. 删除二叉搜索树中的节点
TreeNode *deleteNode(TreeNode *root, int key)
{
    if (root == nullptr)
        return root;  // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
    if (root->val == key) {
        // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
        // 第三种情况：其左孩子为空，删除节点，右孩子补位 ，返回右孩子为根节点
        if (root->left == nullptr)
            return root->right;
        // 第四种情况：其右孩子为空，删除节点，左孩子补位，返回左孩子为根节点
        else if (root->right == nullptr)
            return root->left;
        // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
        // 并返回删除节点右孩子为新的根节点。
        else {
            TreeNode *cur = root->right;  // 找右子树最左面的节点
            while (cur->left != nullptr) {
                cur = cur->left;
            }
            cur->left = root->left;  // 把要删除的节点（root）左子树放在cur的左孩子的位置
            TreeNode *tmp = root;    // 把root节点保存一下，下面来删除
            root = root->right;      // 返回旧root的右孩子作为新root
            delete tmp;  // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
            return root;
        }
    }
    if (root->val > key)
        root->left = deleteNode(root->left, key);
    if (root->val < key)
        root->right = deleteNode(root->right, key);
    return root;
}
```

b)记忆化BST查找第k小的元素

假设我们已经建立好一棵记忆化的二叉搜索树（或者将一棵普通的BST记忆化后），要如何找到树中第K小的元素呢？我们可以利用结点的leftchilds和rightchilds这两个变量实现一个简单的二分查找：

初始化工作指针cur和变量rank，其中cur一开始指向根结点，rank是cur当前指向结点的排名（即第rank小）。因为根结点的左子树元素都是比根结点小的，故rank的初始化为x`cur -> rightchilds + 1`。

当k != rank的时候自顶向下查找:

当前的k小于rank，要找的结点在左子树中，cur指向`cur -> left`，因为上一个根结点和当前根结点的右子树结点都排在当前结点后面，当前结点的排名相当于前进了`cur -> rightchilds + 1`个位置，所以新的排名：
`rank = rank - cur -> rightchilds - 1`。

当前的k大于rank，要找的结点在右子树中，cur指向`cur -> right`，因为上一个根结点和当前根结点的左子树结点都排在当前结点前面，当前结点的排名相当于后退了`cur -> leftchilds + 1`个位置，所以新的排名：
`rank = rank + cur -> leftchilds + 1`。

以在下面二叉树中搜索第4小的元素为例

<img src="assets/image-20210616095919860.png" alt="image-20210616095919860" style="zoom:50%;" /><img src="assets/image-20210616095932906.png" alt="image-20210616095932906" style="zoom:50%;" />

<img src="assets/image-20210616095941812.png" alt="image-20210616095941812" style="zoom:50%;" /><img src="assets/image-20210616095952120.png" alt="image-20210616095952120" style="zoom:50%;" />
解题代码如下：

```c
class Solution {
private:
    unordered_map<TreeNode*,int> leftchilds;
    unordered_map<TreeNode*,int> rightchilds;
public:
    //根据记忆化结果查找第K小元素
    int myKthSmallest(TreeNode* root,int k){
        TreeNode* cur = root;
        int rank = leftchilds[cur] + 1;
        while(k != rank){
            if(k < rank){
                cur = cur -> left;
                rank -= rightchilds[cur] + 1;
            }else{
                cur = cur -> right;
                rank += leftchilds[cur] + 1;
            }
        }
        return cur -> val;
    }
    //遍历BST，生成leftchilds 和 rightchilds
    int memoTree(TreeNode* root){
        if(!root){
            return 0;
        }
        leftchilds[root] = memoTree(root -> left);
        rightchilds[root] = memoTree(root -> right);
        return leftchilds[root] + rightchilds[root] + 1;
    }

    int kthSmallest(TreeNode* root, int k) {
        if(!root){
            return 0;
        }
        memoTree(root);
        return myKthSmallest(root,k);      
    }
    
};
```

>当然，变量`leftchilds`和`rightchilds`需要在增删元素的时候需要被正确维护，力扣没有提供`insertNode()`和`deletNode()`的API，所以我们这道题就只能利用 BST 中序遍历的特性实现了，但是我们上面说到的优化思路（解法2）是 BST 的常见操作，还是有必要理解的。

#### 1373. 二叉搜索子树的最大键值和

![image-20210616154025485](assets/image-20210616154025485.png)

![image-20210616154040327](assets/image-20210616154040327.png)

**那么我们想计算子树中 BST 的最大和，站在当前节点的视角，需要做什么呢**？

1、我肯定得知道左右子树是不是合法的 BST，如果这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST，对吧。
2、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。
3、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 争个高下，对吧。
**根据以上三点，站在当前节点的视角，需要知道以下具体信息：**
1、左右子树是否是 BST。
2、左子树的最大值和右子树的最小值。
3、左右子树的节点值之和。
只有知道了这几个值，我们才能满足题目的要求，后面我们会想方设法计算这些值。

现在可以尝试用伪码写出算法的大致逻辑：

```java
// 全局变量，记录 BST 最大节点之和
int maxSum = 0;

/* 主函数 */
public int maxSumBST(TreeNode root) {
    traverse(root);
    return maxSum;
}

/* 遍历二叉树 */
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }

    /******* 前序遍历位置 *******/
    // 判断左右子树是不是 BST
    if (!isBST(root.left) || !isBST(root.right)) {
        goto next;
    }
    // 计算左子树的最大值和右子树的最小值
    int leftMax = findMax(root.left);
    int rightMin = findMin(root.right);
    // 判断以 root 节点为根的树是不是 BST
    if (root.val <= leftMax || root.val >= rightMin) {
        goto next;
    }
    // 如果条件都符合，计算当前 BST 的节点之和
    int leftSum = findSum(root.left);
    int rightSum = findSum(root.right);
    int rootSum = leftSum + rightSum + root.val;
    // 计算 BST 节点的最大和
    this.maxSum = Math.max(maxSum, rootSum);
    /**************************/

    // 递归左右子树
    next:
    traverse(root.left);
    traverse(root.right);
}

/* 计算以 root 为根的二叉树的最大值 */
int findMax(TreeNode root) {}

/* 计算以 root 为根的二叉树的最小值 */
int findMin(TreeNode root) {}

/* 计算以 root 为根的二叉树的节点和 */
int findSum(TreeNode root) {}

/* 判断以 root 为根的二叉树是否是 BST */
boolean isBST(TreeNode root) {}
```

这个代码逻辑应该是不难理解的，代码在前序遍历的位置把之前的分析都实现了一遍。

稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加 traverse 函数本身的递归，可以说是递归上加递归，所以这个解法的复杂度是非常高的。**只要把前序遍历变成后序遍历，让** **`traverse`** **函数把辅助函数做的事情顺便做掉**。

`traverse(root)` 返回一个大小为 4 的 int 数组，我们暂且称它为 `res`，其中：

`res[0]` 记录以 `root` 为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；

`res[1]` 记录以 `root` 为根的二叉树所有节点中的最小值；

`res[2]` 记录以 `root` 为根的二叉树所有节点中的最大值；

`res[3]` 记录以 `root` 为根的二叉树所有节点值之和。

其实这就是把之前分析中说到的几个值放到了 `res` 数组中，**最重要的是，我们要试图通过** **`left`** **和** **`right`** **正确推导出** **`res`** **数组**。

直接看代码实现吧：

```java
int[] traverse(TreeNode root) {
    // base case
    if (root == null) {
        return new int[] {
            1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0
        };
    }

    // 递归计算左右子树
    int[] left = traverse(root.left);
    int[] right = traverse(root.right);

    /******* 后序遍历位置 *******/
    int[] res = new int[4];
    // 这个 if 在判断以 root 为根的二叉树是不是 BST
    if (left[0] == 1 && right[0] == 1 &&
        root.val > left[2] && root.val < right[1]) {
        // 以 root 为根的二叉树是 BST
        res[0] = 1;
        // 计算以 root 为根的这棵 BST 的最小值
        res[1] = Math.min(left[1], root.val);
        // 计算以 root 为根的这棵 BST 的最大值
        res[2] = Math.max(right[2], root.val);
        // 计算以 root 为根的这棵 BST 所有节点之和
        res[3] = left[3] + right[3] + root.val;
        // 更新全局变量
        maxSum = Math.max(maxSum, res[3]);
    } else {
        // 以 root 为根的二叉树不是 BST
        res[0] = 0;
        // 其他的值都没必要计算了，因为用不到
    }
    /**************************/

    return res;
}
```



## 如何计算所有合法 BST

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

![image-20210616140135297](assets/image-20210616140135297.png)

1、递归

举个例子，比如给算法输入 `n = 5`，也就是说用 `{1,2,3,4,5}` 这些数字去构造 BST。

根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。

所以如果固定 `3` 作为根节点，左子树节点就是 `{1,2}` 的组合，右子树就是 `{4,5}` 的组合。

**左子树的组合数和右子树的组合数乘积**就是 `3` 作为根节点时的 BST 个数。

可以写出代码：

```c
/* 主函数 */
int numTrees(int n) {
    // 计算闭区间 [1, n] 组成的 BST 个数
    return count(1, n);
}

/* 计算闭区间 [lo, hi] 组成的 BST 个数 */
int count(int lo, int hi) {
    // base case
    if (lo > hi)
        return 1;

    int res = 0;
    for (int i = lo; i <= hi; i++) {
        // i 的值作为根节点 root
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        // 左右子树的组合数乘积是 BST 的总数
        res += left * right;
    }

    return res;
}
```

注意 base case，显然当 `lo > hi` 闭区间 `[lo, hi]` 肯定是个空区间，也就对应着空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。

2、优化

这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。

前文动态规划相关的问题多次讲过消除重叠子问题的方法，无非就是加一个备忘录：

```java
// 备忘录
int[][] memo;

int numTrees(int n) {
    // 备忘录的值初始化为 0
    memo = new int[n + 1][n + 1];
    return count(1, n);
}

/* 计算闭区间 [lo, hi] 组成的 BST 个数 */
int count(int lo, int hi) {
    if (lo > hi) return 1;
    // 查备忘录
    if (memo[lo][hi] != 0) {
        return memo[lo][hi];
    }

    int res = 0;
    for (int mid = lo; mid <= hi; mid++) {
        int left = count(lo, mid - 1);
        int right = count(mid + 1, hi);
        res += left * right;
    }
    // 将结果存入备忘录
    memo[lo][hi] = res;

    return res;
}
```

3、代码随想录

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

**dp[i] ：1到i为节点组成的二叉搜索树的个数为dp[i]**。`dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]`

```c++
  dp[0] = 1;
  for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= i; j++) {
          dp[i] += dp[j - 1] * dp[i - j];
      }
  }
```

#### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)



![image-20210616143344435](assets/image-20210616143344435.png)

明白了上道题构造合法 BST 的方法，这道题的思路也是一样的：
1、穷举 root 节点的所有可能。
2、递归构造出左右子树的所有合法 BST。
3、给 root 节点穷举所有左右子树的组合。

我们可以直接看代码：

```java
/* 主函数 */
public List<TreeNode> generateTrees(int n) {
    if (n == 0) return new LinkedList<>();
    // 构造闭区间 [1, n] 组成的 BST 
    return build(1, n);
}

/* 构造闭区间 [lo, hi] 组成的 BST */
List<TreeNode> build(int lo, int hi) {
    List<TreeNode> res = new LinkedList<>();
    // base case
    if (lo > hi) {
        res.add(null);
        return res;
    }

    // 1、穷举 root 节点的所有可能。
    for (int i = lo; i <= hi; i++) {
        // 2、递归构造出左右子树的所有合法 BST。
        List<TreeNode> leftTree = build(lo, i - 1);
        List<TreeNode> rightTree = build(i + 1, hi);
        // 3、给 root 节点穷举所有左右子树的组合。
        for (TreeNode left : leftTree) {
            for (TreeNode right : rightTree) {
                // i 作为根节点 root 的值
                TreeNode root = new TreeNode(i);
                root.left = left;
                root.right = right;
                res.add(root);
            }
        }
    }

    return res;
}
```

2、优化，备忘录法

```java
public class Solution {
    private List<List<List<TreeNode>>> memo;

    /* 主函数 */
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) {
            return new LinkedList<>();
        }
        memo = new LinkedList<>();
        for (int i = 0; i <= n; i++) {
            memo.add(new LinkedList<List<TreeNode>>());
            for (int j = 0; j <= n; j++) {
                memo.get(i).add(new LinkedList<TreeNode>());
            }
        }
        // 构造闭区间 [1, n] 组成的 BST
        return build(1, n);
    }

    /* 构造闭区间 [lo, hi] 组成的 BST */
    List<TreeNode> build(int lo, int hi) {
        List<TreeNode> res = new LinkedList<>();
        // base case
        if (lo > hi) {
            res.add(null);
            return res;
        }
        if (memo.get(lo).get(hi) != null && !memo.get(lo).get(hi).isEmpty()) {
            return memo.get(lo).get(hi);
        }

        // 1、穷举 root 节点的所有可能。
        for (int i = lo; i <= hi; i++) {
            // 2、递归构造出左右子树的所有合法 BST。
            List<TreeNode> leftTree = build(lo, i - 1);
            List<TreeNode> rightTree = build(i + 1, hi);
            // 3、给 root 节点穷举所有左右子树的组合。
            for (TreeNode left : leftTree) {
                for (TreeNode right : rightTree) {
                    // i 作为根节点 root 的值
                    TreeNode root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    res.add(root);
                }
            }
        }
        memo.get(lo).set(hi, res);

        return res;
    }
}
```

